
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Institution
 * 
 */
export type Institution = $Result.DefaultSelection<Prisma.$InstitutionPayload>
/**
 * Model UsersOnInstitution
 * 
 */
export type UsersOnInstitution = $Result.DefaultSelection<Prisma.$UsersOnInstitutionPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Student
 * 
 */
export type Student = $Result.DefaultSelection<Prisma.$StudentPayload>
/**
 * Model UserToParent
 * 
 */
export type UserToParent = $Result.DefaultSelection<Prisma.$UserToParentPayload>
/**
 * Model Parent
 * 
 */
export type Parent = $Result.DefaultSelection<Prisma.$ParentPayload>
/**
 * Model StudentDocument
 * 
 */
export type StudentDocument = $Result.DefaultSelection<Prisma.$StudentDocumentPayload>
/**
 * Model TeacherOnInstitution
 * 
 */
export type TeacherOnInstitution = $Result.DefaultSelection<Prisma.$TeacherOnInstitutionPayload>
/**
 * Model Teacher
 * 
 */
export type Teacher = $Result.DefaultSelection<Prisma.$TeacherPayload>
/**
 * Model TeacherOnClass
 * 
 */
export type TeacherOnClass = $Result.DefaultSelection<Prisma.$TeacherOnClassPayload>
/**
 * Model Class
 * 
 */
export type Class = $Result.DefaultSelection<Prisma.$ClassPayload>
/**
 * Model Enrollment
 * 
 */
export type Enrollment = $Result.DefaultSelection<Prisma.$EnrollmentPayload>
/**
 * Model Attendance
 * 
 */
export type Attendance = $Result.DefaultSelection<Prisma.$AttendancePayload>
/**
 * Model Grade
 * 
 */
export type Grade = $Result.DefaultSelection<Prisma.$GradePayload>
/**
 * Model Timetable
 * 
 */
export type Timetable = $Result.DefaultSelection<Prisma.$TimetablePayload>
/**
 * Model Invoice
 * 
 */
export type Invoice = $Result.DefaultSelection<Prisma.$InvoicePayload>
/**
 * Model Message
 * 
 */
export type Message = $Result.DefaultSelection<Prisma.$MessagePayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Role: {
  SUPER_ADMIN: 'SUPER_ADMIN',
  ADMIN: 'ADMIN',
  TEACHER: 'TEACHER',
  STUDENT: 'STUDENT',
  PARENT: 'PARENT'
};

export type Role = (typeof Role)[keyof typeof Role]


export const InstitutionType: {
  PRIMARY: 'PRIMARY',
  SECONDARY: 'SECONDARY'
};

export type InstitutionType = (typeof InstitutionType)[keyof typeof InstitutionType]


export const InstitutionPlan: {
  BASIC: 'BASIC',
  STANDARD: 'STANDARD',
  PREMIUM: 'PREMIUM'
};

export type InstitutionPlan = (typeof InstitutionPlan)[keyof typeof InstitutionPlan]


export const SubscriptionStatus: {
  ACTIVE: 'ACTIVE',
  INACTIVE: 'INACTIVE'
};

export type SubscriptionStatus = (typeof SubscriptionStatus)[keyof typeof SubscriptionStatus]

}

export type Role = $Enums.Role

export const Role: typeof $Enums.Role

export type InstitutionType = $Enums.InstitutionType

export const InstitutionType: typeof $Enums.InstitutionType

export type InstitutionPlan = $Enums.InstitutionPlan

export const InstitutionPlan: typeof $Enums.InstitutionPlan

export type SubscriptionStatus = $Enums.SubscriptionStatus

export const SubscriptionStatus: typeof $Enums.SubscriptionStatus

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Institutions
 * const institutions = await prisma.institution.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Institutions
   * const institutions = await prisma.institution.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P]): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number }): $Utils.JsPromise<R>

  /**
   * Executes a raw MongoDB command and returns the result of it.
   * @example
   * ```
   * const user = await prisma.$runCommandRaw({
   *   aggregate: 'User',
   *   pipeline: [{ $match: { name: 'Bob' } }, { $project: { email: true, _id: false } }],
   *   explain: false,
   * })
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $runCommandRaw(command: Prisma.InputJsonObject): Prisma.PrismaPromise<Prisma.JsonObject>

  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.institution`: Exposes CRUD operations for the **Institution** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Institutions
    * const institutions = await prisma.institution.findMany()
    * ```
    */
  get institution(): Prisma.InstitutionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.usersOnInstitution`: Exposes CRUD operations for the **UsersOnInstitution** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UsersOnInstitutions
    * const usersOnInstitutions = await prisma.usersOnInstitution.findMany()
    * ```
    */
  get usersOnInstitution(): Prisma.UsersOnInstitutionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.student`: Exposes CRUD operations for the **Student** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Students
    * const students = await prisma.student.findMany()
    * ```
    */
  get student(): Prisma.StudentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userToParent`: Exposes CRUD operations for the **UserToParent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserToParents
    * const userToParents = await prisma.userToParent.findMany()
    * ```
    */
  get userToParent(): Prisma.UserToParentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.parent`: Exposes CRUD operations for the **Parent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Parents
    * const parents = await prisma.parent.findMany()
    * ```
    */
  get parent(): Prisma.ParentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.studentDocument`: Exposes CRUD operations for the **StudentDocument** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StudentDocuments
    * const studentDocuments = await prisma.studentDocument.findMany()
    * ```
    */
  get studentDocument(): Prisma.StudentDocumentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.teacherOnInstitution`: Exposes CRUD operations for the **TeacherOnInstitution** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TeacherOnInstitutions
    * const teacherOnInstitutions = await prisma.teacherOnInstitution.findMany()
    * ```
    */
  get teacherOnInstitution(): Prisma.TeacherOnInstitutionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.teacher`: Exposes CRUD operations for the **Teacher** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Teachers
    * const teachers = await prisma.teacher.findMany()
    * ```
    */
  get teacher(): Prisma.TeacherDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.teacherOnClass`: Exposes CRUD operations for the **TeacherOnClass** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TeacherOnClasses
    * const teacherOnClasses = await prisma.teacherOnClass.findMany()
    * ```
    */
  get teacherOnClass(): Prisma.TeacherOnClassDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.class`: Exposes CRUD operations for the **Class** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Classes
    * const classes = await prisma.class.findMany()
    * ```
    */
  get class(): Prisma.ClassDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.enrollment`: Exposes CRUD operations for the **Enrollment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Enrollments
    * const enrollments = await prisma.enrollment.findMany()
    * ```
    */
  get enrollment(): Prisma.EnrollmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.attendance`: Exposes CRUD operations for the **Attendance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Attendances
    * const attendances = await prisma.attendance.findMany()
    * ```
    */
  get attendance(): Prisma.AttendanceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.grade`: Exposes CRUD operations for the **Grade** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Grades
    * const grades = await prisma.grade.findMany()
    * ```
    */
  get grade(): Prisma.GradeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.timetable`: Exposes CRUD operations for the **Timetable** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Timetables
    * const timetables = await prisma.timetable.findMany()
    * ```
    */
  get timetable(): Prisma.TimetableDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.invoice`: Exposes CRUD operations for the **Invoice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Invoices
    * const invoices = await prisma.invoice.findMany()
    * ```
    */
  get invoice(): Prisma.InvoiceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.message`: Exposes CRUD operations for the **Message** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Messages
    * const messages = await prisma.message.findMany()
    * ```
    */
  get message(): Prisma.MessageDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.19.0
   * Query Engine version: 2ba551f319ab1df4bc874a89965d8b3641056773
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Institution: 'Institution',
    UsersOnInstitution: 'UsersOnInstitution',
    User: 'User',
    Student: 'Student',
    UserToParent: 'UserToParent',
    Parent: 'Parent',
    StudentDocument: 'StudentDocument',
    TeacherOnInstitution: 'TeacherOnInstitution',
    Teacher: 'Teacher',
    TeacherOnClass: 'TeacherOnClass',
    Class: 'Class',
    Enrollment: 'Enrollment',
    Attendance: 'Attendance',
    Grade: 'Grade',
    Timetable: 'Timetable',
    Invoice: 'Invoice',
    Message: 'Message'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "institution" | "usersOnInstitution" | "user" | "student" | "userToParent" | "parent" | "studentDocument" | "teacherOnInstitution" | "teacher" | "teacherOnClass" | "class" | "enrollment" | "attendance" | "grade" | "timetable" | "invoice" | "message"
      txIsolationLevel: never
    }
    model: {
      Institution: {
        payload: Prisma.$InstitutionPayload<ExtArgs>
        fields: Prisma.InstitutionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InstitutionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstitutionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InstitutionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstitutionPayload>
          }
          findFirst: {
            args: Prisma.InstitutionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstitutionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InstitutionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstitutionPayload>
          }
          findMany: {
            args: Prisma.InstitutionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstitutionPayload>[]
          }
          create: {
            args: Prisma.InstitutionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstitutionPayload>
          }
          createMany: {
            args: Prisma.InstitutionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.InstitutionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstitutionPayload>
          }
          update: {
            args: Prisma.InstitutionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstitutionPayload>
          }
          deleteMany: {
            args: Prisma.InstitutionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InstitutionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InstitutionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstitutionPayload>
          }
          aggregate: {
            args: Prisma.InstitutionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInstitution>
          }
          groupBy: {
            args: Prisma.InstitutionGroupByArgs<ExtArgs>
            result: $Utils.Optional<InstitutionGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.InstitutionFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.InstitutionAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.InstitutionCountArgs<ExtArgs>
            result: $Utils.Optional<InstitutionCountAggregateOutputType> | number
          }
        }
      }
      UsersOnInstitution: {
        payload: Prisma.$UsersOnInstitutionPayload<ExtArgs>
        fields: Prisma.UsersOnInstitutionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UsersOnInstitutionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersOnInstitutionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UsersOnInstitutionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersOnInstitutionPayload>
          }
          findFirst: {
            args: Prisma.UsersOnInstitutionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersOnInstitutionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UsersOnInstitutionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersOnInstitutionPayload>
          }
          findMany: {
            args: Prisma.UsersOnInstitutionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersOnInstitutionPayload>[]
          }
          create: {
            args: Prisma.UsersOnInstitutionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersOnInstitutionPayload>
          }
          createMany: {
            args: Prisma.UsersOnInstitutionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UsersOnInstitutionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersOnInstitutionPayload>
          }
          update: {
            args: Prisma.UsersOnInstitutionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersOnInstitutionPayload>
          }
          deleteMany: {
            args: Prisma.UsersOnInstitutionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UsersOnInstitutionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UsersOnInstitutionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersOnInstitutionPayload>
          }
          aggregate: {
            args: Prisma.UsersOnInstitutionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsersOnInstitution>
          }
          groupBy: {
            args: Prisma.UsersOnInstitutionGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsersOnInstitutionGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.UsersOnInstitutionFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.UsersOnInstitutionAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.UsersOnInstitutionCountArgs<ExtArgs>
            result: $Utils.Optional<UsersOnInstitutionCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.UserFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.UserAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Student: {
        payload: Prisma.$StudentPayload<ExtArgs>
        fields: Prisma.StudentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StudentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StudentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          findFirst: {
            args: Prisma.StudentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StudentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          findMany: {
            args: Prisma.StudentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>[]
          }
          create: {
            args: Prisma.StudentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          createMany: {
            args: Prisma.StudentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.StudentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          update: {
            args: Prisma.StudentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          deleteMany: {
            args: Prisma.StudentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StudentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StudentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          aggregate: {
            args: Prisma.StudentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudent>
          }
          groupBy: {
            args: Prisma.StudentGroupByArgs<ExtArgs>
            result: $Utils.Optional<StudentGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.StudentFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.StudentAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.StudentCountArgs<ExtArgs>
            result: $Utils.Optional<StudentCountAggregateOutputType> | number
          }
        }
      }
      UserToParent: {
        payload: Prisma.$UserToParentPayload<ExtArgs>
        fields: Prisma.UserToParentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserToParentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserToParentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserToParentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserToParentPayload>
          }
          findFirst: {
            args: Prisma.UserToParentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserToParentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserToParentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserToParentPayload>
          }
          findMany: {
            args: Prisma.UserToParentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserToParentPayload>[]
          }
          create: {
            args: Prisma.UserToParentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserToParentPayload>
          }
          createMany: {
            args: Prisma.UserToParentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserToParentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserToParentPayload>
          }
          update: {
            args: Prisma.UserToParentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserToParentPayload>
          }
          deleteMany: {
            args: Prisma.UserToParentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserToParentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserToParentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserToParentPayload>
          }
          aggregate: {
            args: Prisma.UserToParentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserToParent>
          }
          groupBy: {
            args: Prisma.UserToParentGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserToParentGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.UserToParentFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.UserToParentAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.UserToParentCountArgs<ExtArgs>
            result: $Utils.Optional<UserToParentCountAggregateOutputType> | number
          }
        }
      }
      Parent: {
        payload: Prisma.$ParentPayload<ExtArgs>
        fields: Prisma.ParentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ParentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ParentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentPayload>
          }
          findFirst: {
            args: Prisma.ParentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ParentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentPayload>
          }
          findMany: {
            args: Prisma.ParentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentPayload>[]
          }
          create: {
            args: Prisma.ParentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentPayload>
          }
          createMany: {
            args: Prisma.ParentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ParentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentPayload>
          }
          update: {
            args: Prisma.ParentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentPayload>
          }
          deleteMany: {
            args: Prisma.ParentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ParentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ParentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentPayload>
          }
          aggregate: {
            args: Prisma.ParentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateParent>
          }
          groupBy: {
            args: Prisma.ParentGroupByArgs<ExtArgs>
            result: $Utils.Optional<ParentGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.ParentFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.ParentAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.ParentCountArgs<ExtArgs>
            result: $Utils.Optional<ParentCountAggregateOutputType> | number
          }
        }
      }
      StudentDocument: {
        payload: Prisma.$StudentDocumentPayload<ExtArgs>
        fields: Prisma.StudentDocumentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StudentDocumentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentDocumentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StudentDocumentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentDocumentPayload>
          }
          findFirst: {
            args: Prisma.StudentDocumentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentDocumentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StudentDocumentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentDocumentPayload>
          }
          findMany: {
            args: Prisma.StudentDocumentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentDocumentPayload>[]
          }
          create: {
            args: Prisma.StudentDocumentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentDocumentPayload>
          }
          createMany: {
            args: Prisma.StudentDocumentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.StudentDocumentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentDocumentPayload>
          }
          update: {
            args: Prisma.StudentDocumentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentDocumentPayload>
          }
          deleteMany: {
            args: Prisma.StudentDocumentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StudentDocumentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StudentDocumentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentDocumentPayload>
          }
          aggregate: {
            args: Prisma.StudentDocumentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudentDocument>
          }
          groupBy: {
            args: Prisma.StudentDocumentGroupByArgs<ExtArgs>
            result: $Utils.Optional<StudentDocumentGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.StudentDocumentFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.StudentDocumentAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.StudentDocumentCountArgs<ExtArgs>
            result: $Utils.Optional<StudentDocumentCountAggregateOutputType> | number
          }
        }
      }
      TeacherOnInstitution: {
        payload: Prisma.$TeacherOnInstitutionPayload<ExtArgs>
        fields: Prisma.TeacherOnInstitutionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TeacherOnInstitutionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherOnInstitutionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TeacherOnInstitutionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherOnInstitutionPayload>
          }
          findFirst: {
            args: Prisma.TeacherOnInstitutionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherOnInstitutionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TeacherOnInstitutionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherOnInstitutionPayload>
          }
          findMany: {
            args: Prisma.TeacherOnInstitutionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherOnInstitutionPayload>[]
          }
          create: {
            args: Prisma.TeacherOnInstitutionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherOnInstitutionPayload>
          }
          createMany: {
            args: Prisma.TeacherOnInstitutionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TeacherOnInstitutionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherOnInstitutionPayload>
          }
          update: {
            args: Prisma.TeacherOnInstitutionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherOnInstitutionPayload>
          }
          deleteMany: {
            args: Prisma.TeacherOnInstitutionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TeacherOnInstitutionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TeacherOnInstitutionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherOnInstitutionPayload>
          }
          aggregate: {
            args: Prisma.TeacherOnInstitutionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTeacherOnInstitution>
          }
          groupBy: {
            args: Prisma.TeacherOnInstitutionGroupByArgs<ExtArgs>
            result: $Utils.Optional<TeacherOnInstitutionGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.TeacherOnInstitutionFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.TeacherOnInstitutionAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.TeacherOnInstitutionCountArgs<ExtArgs>
            result: $Utils.Optional<TeacherOnInstitutionCountAggregateOutputType> | number
          }
        }
      }
      Teacher: {
        payload: Prisma.$TeacherPayload<ExtArgs>
        fields: Prisma.TeacherFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TeacherFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TeacherFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherPayload>
          }
          findFirst: {
            args: Prisma.TeacherFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TeacherFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherPayload>
          }
          findMany: {
            args: Prisma.TeacherFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherPayload>[]
          }
          create: {
            args: Prisma.TeacherCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherPayload>
          }
          createMany: {
            args: Prisma.TeacherCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TeacherDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherPayload>
          }
          update: {
            args: Prisma.TeacherUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherPayload>
          }
          deleteMany: {
            args: Prisma.TeacherDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TeacherUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TeacherUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherPayload>
          }
          aggregate: {
            args: Prisma.TeacherAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTeacher>
          }
          groupBy: {
            args: Prisma.TeacherGroupByArgs<ExtArgs>
            result: $Utils.Optional<TeacherGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.TeacherFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.TeacherAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.TeacherCountArgs<ExtArgs>
            result: $Utils.Optional<TeacherCountAggregateOutputType> | number
          }
        }
      }
      TeacherOnClass: {
        payload: Prisma.$TeacherOnClassPayload<ExtArgs>
        fields: Prisma.TeacherOnClassFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TeacherOnClassFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherOnClassPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TeacherOnClassFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherOnClassPayload>
          }
          findFirst: {
            args: Prisma.TeacherOnClassFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherOnClassPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TeacherOnClassFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherOnClassPayload>
          }
          findMany: {
            args: Prisma.TeacherOnClassFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherOnClassPayload>[]
          }
          create: {
            args: Prisma.TeacherOnClassCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherOnClassPayload>
          }
          createMany: {
            args: Prisma.TeacherOnClassCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TeacherOnClassDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherOnClassPayload>
          }
          update: {
            args: Prisma.TeacherOnClassUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherOnClassPayload>
          }
          deleteMany: {
            args: Prisma.TeacherOnClassDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TeacherOnClassUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TeacherOnClassUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherOnClassPayload>
          }
          aggregate: {
            args: Prisma.TeacherOnClassAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTeacherOnClass>
          }
          groupBy: {
            args: Prisma.TeacherOnClassGroupByArgs<ExtArgs>
            result: $Utils.Optional<TeacherOnClassGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.TeacherOnClassFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.TeacherOnClassAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.TeacherOnClassCountArgs<ExtArgs>
            result: $Utils.Optional<TeacherOnClassCountAggregateOutputType> | number
          }
        }
      }
      Class: {
        payload: Prisma.$ClassPayload<ExtArgs>
        fields: Prisma.ClassFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClassFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClassFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>
          }
          findFirst: {
            args: Prisma.ClassFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClassFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>
          }
          findMany: {
            args: Prisma.ClassFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>[]
          }
          create: {
            args: Prisma.ClassCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>
          }
          createMany: {
            args: Prisma.ClassCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ClassDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>
          }
          update: {
            args: Prisma.ClassUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>
          }
          deleteMany: {
            args: Prisma.ClassDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClassUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ClassUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>
          }
          aggregate: {
            args: Prisma.ClassAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClass>
          }
          groupBy: {
            args: Prisma.ClassGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClassGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.ClassFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.ClassAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.ClassCountArgs<ExtArgs>
            result: $Utils.Optional<ClassCountAggregateOutputType> | number
          }
        }
      }
      Enrollment: {
        payload: Prisma.$EnrollmentPayload<ExtArgs>
        fields: Prisma.EnrollmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EnrollmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnrollmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EnrollmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnrollmentPayload>
          }
          findFirst: {
            args: Prisma.EnrollmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnrollmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EnrollmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnrollmentPayload>
          }
          findMany: {
            args: Prisma.EnrollmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnrollmentPayload>[]
          }
          create: {
            args: Prisma.EnrollmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnrollmentPayload>
          }
          createMany: {
            args: Prisma.EnrollmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.EnrollmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnrollmentPayload>
          }
          update: {
            args: Prisma.EnrollmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnrollmentPayload>
          }
          deleteMany: {
            args: Prisma.EnrollmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EnrollmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EnrollmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnrollmentPayload>
          }
          aggregate: {
            args: Prisma.EnrollmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEnrollment>
          }
          groupBy: {
            args: Prisma.EnrollmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<EnrollmentGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.EnrollmentFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.EnrollmentAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.EnrollmentCountArgs<ExtArgs>
            result: $Utils.Optional<EnrollmentCountAggregateOutputType> | number
          }
        }
      }
      Attendance: {
        payload: Prisma.$AttendancePayload<ExtArgs>
        fields: Prisma.AttendanceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AttendanceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AttendanceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          findFirst: {
            args: Prisma.AttendanceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AttendanceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          findMany: {
            args: Prisma.AttendanceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>[]
          }
          create: {
            args: Prisma.AttendanceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          createMany: {
            args: Prisma.AttendanceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AttendanceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          update: {
            args: Prisma.AttendanceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          deleteMany: {
            args: Prisma.AttendanceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AttendanceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AttendanceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          aggregate: {
            args: Prisma.AttendanceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAttendance>
          }
          groupBy: {
            args: Prisma.AttendanceGroupByArgs<ExtArgs>
            result: $Utils.Optional<AttendanceGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.AttendanceFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.AttendanceAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.AttendanceCountArgs<ExtArgs>
            result: $Utils.Optional<AttendanceCountAggregateOutputType> | number
          }
        }
      }
      Grade: {
        payload: Prisma.$GradePayload<ExtArgs>
        fields: Prisma.GradeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GradeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GradeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradePayload>
          }
          findFirst: {
            args: Prisma.GradeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GradeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradePayload>
          }
          findMany: {
            args: Prisma.GradeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradePayload>[]
          }
          create: {
            args: Prisma.GradeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradePayload>
          }
          createMany: {
            args: Prisma.GradeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.GradeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradePayload>
          }
          update: {
            args: Prisma.GradeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradePayload>
          }
          deleteMany: {
            args: Prisma.GradeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GradeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.GradeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradePayload>
          }
          aggregate: {
            args: Prisma.GradeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGrade>
          }
          groupBy: {
            args: Prisma.GradeGroupByArgs<ExtArgs>
            result: $Utils.Optional<GradeGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.GradeFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.GradeAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.GradeCountArgs<ExtArgs>
            result: $Utils.Optional<GradeCountAggregateOutputType> | number
          }
        }
      }
      Timetable: {
        payload: Prisma.$TimetablePayload<ExtArgs>
        fields: Prisma.TimetableFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TimetableFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimetablePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TimetableFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimetablePayload>
          }
          findFirst: {
            args: Prisma.TimetableFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimetablePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TimetableFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimetablePayload>
          }
          findMany: {
            args: Prisma.TimetableFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimetablePayload>[]
          }
          create: {
            args: Prisma.TimetableCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimetablePayload>
          }
          createMany: {
            args: Prisma.TimetableCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TimetableDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimetablePayload>
          }
          update: {
            args: Prisma.TimetableUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimetablePayload>
          }
          deleteMany: {
            args: Prisma.TimetableDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TimetableUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TimetableUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimetablePayload>
          }
          aggregate: {
            args: Prisma.TimetableAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTimetable>
          }
          groupBy: {
            args: Prisma.TimetableGroupByArgs<ExtArgs>
            result: $Utils.Optional<TimetableGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.TimetableFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.TimetableAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.TimetableCountArgs<ExtArgs>
            result: $Utils.Optional<TimetableCountAggregateOutputType> | number
          }
        }
      }
      Invoice: {
        payload: Prisma.$InvoicePayload<ExtArgs>
        fields: Prisma.InvoiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvoiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvoiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          findFirst: {
            args: Prisma.InvoiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvoiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          findMany: {
            args: Prisma.InvoiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          create: {
            args: Prisma.InvoiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          createMany: {
            args: Prisma.InvoiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.InvoiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          update: {
            args: Prisma.InvoiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          deleteMany: {
            args: Prisma.InvoiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InvoiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InvoiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          aggregate: {
            args: Prisma.InvoiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvoice>
          }
          groupBy: {
            args: Prisma.InvoiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvoiceGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.InvoiceFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.InvoiceAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.InvoiceCountArgs<ExtArgs>
            result: $Utils.Optional<InvoiceCountAggregateOutputType> | number
          }
        }
      }
      Message: {
        payload: Prisma.$MessagePayload<ExtArgs>
        fields: Prisma.MessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findFirst: {
            args: Prisma.MessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findMany: {
            args: Prisma.MessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          create: {
            args: Prisma.MessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          createMany: {
            args: Prisma.MessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.MessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          update: {
            args: Prisma.MessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          deleteMany: {
            args: Prisma.MessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          aggregate: {
            args: Prisma.MessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessage>
          }
          groupBy: {
            args: Prisma.MessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<MessageGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.MessageFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.MessageAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.MessageCountArgs<ExtArgs>
            result: $Utils.Optional<MessageCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $runCommandRaw: {
          args: Prisma.InputJsonObject,
          result: Prisma.JsonObject
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    institution?: InstitutionOmit
    usersOnInstitution?: UsersOnInstitutionOmit
    user?: UserOmit
    student?: StudentOmit
    userToParent?: UserToParentOmit
    parent?: ParentOmit
    studentDocument?: StudentDocumentOmit
    teacherOnInstitution?: TeacherOnInstitutionOmit
    teacher?: TeacherOmit
    teacherOnClass?: TeacherOnClassOmit
    class?: ClassOmit
    enrollment?: EnrollmentOmit
    attendance?: AttendanceOmit
    grade?: GradeOmit
    timetable?: TimetableOmit
    invoice?: InvoiceOmit
    message?: MessageOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type InstitutionCountOutputType
   */

  export type InstitutionCountOutputType = {
    users: number
    classes: number
    students: number
    teachers: number
    invoices: number
    messages: number
  }

  export type InstitutionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | InstitutionCountOutputTypeCountUsersArgs
    classes?: boolean | InstitutionCountOutputTypeCountClassesArgs
    students?: boolean | InstitutionCountOutputTypeCountStudentsArgs
    teachers?: boolean | InstitutionCountOutputTypeCountTeachersArgs
    invoices?: boolean | InstitutionCountOutputTypeCountInvoicesArgs
    messages?: boolean | InstitutionCountOutputTypeCountMessagesArgs
  }

  // Custom InputTypes
  /**
   * InstitutionCountOutputType without action
   */
  export type InstitutionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstitutionCountOutputType
     */
    select?: InstitutionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InstitutionCountOutputType without action
   */
  export type InstitutionCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsersOnInstitutionWhereInput
  }

  /**
   * InstitutionCountOutputType without action
   */
  export type InstitutionCountOutputTypeCountClassesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassWhereInput
  }

  /**
   * InstitutionCountOutputType without action
   */
  export type InstitutionCountOutputTypeCountStudentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentWhereInput
  }

  /**
   * InstitutionCountOutputType without action
   */
  export type InstitutionCountOutputTypeCountTeachersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeacherOnInstitutionWhereInput
  }

  /**
   * InstitutionCountOutputType without action
   */
  export type InstitutionCountOutputTypeCountInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
  }

  /**
   * InstitutionCountOutputType without action
   */
  export type InstitutionCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    student: number
    teacher: number
    parent: number
    institutions: number
    sentMessages: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | UserCountOutputTypeCountStudentArgs
    teacher?: boolean | UserCountOutputTypeCountTeacherArgs
    parent?: boolean | UserCountOutputTypeCountParentArgs
    institutions?: boolean | UserCountOutputTypeCountInstitutionsArgs
    sentMessages?: boolean | UserCountOutputTypeCountSentMessagesArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountStudentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTeacherArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeacherWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountParentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserToParentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountInstitutionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsersOnInstitutionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSentMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }


  /**
   * Count Type StudentCountOutputType
   */

  export type StudentCountOutputType = {
    StudentDocument: number
    parents: number
    enrollments: number
    attendances: number
    grades: number
    invoices: number
  }

  export type StudentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    StudentDocument?: boolean | StudentCountOutputTypeCountStudentDocumentArgs
    parents?: boolean | StudentCountOutputTypeCountParentsArgs
    enrollments?: boolean | StudentCountOutputTypeCountEnrollmentsArgs
    attendances?: boolean | StudentCountOutputTypeCountAttendancesArgs
    grades?: boolean | StudentCountOutputTypeCountGradesArgs
    invoices?: boolean | StudentCountOutputTypeCountInvoicesArgs
  }

  // Custom InputTypes
  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentCountOutputType
     */
    select?: StudentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountStudentDocumentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentDocumentWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountParentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ParentWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountEnrollmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EnrollmentWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountAttendancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountGradesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GradeWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
  }


  /**
   * Count Type ParentCountOutputType
   */

  export type ParentCountOutputType = {
    user: number
  }

  export type ParentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | ParentCountOutputTypeCountUserArgs
  }

  // Custom InputTypes
  /**
   * ParentCountOutputType without action
   */
  export type ParentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParentCountOutputType
     */
    select?: ParentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ParentCountOutputType without action
   */
  export type ParentCountOutputTypeCountUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserToParentWhereInput
  }


  /**
   * Count Type TeacherCountOutputType
   */

  export type TeacherCountOutputType = {
    institution: number
    classes: number
  }

  export type TeacherCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    institution?: boolean | TeacherCountOutputTypeCountInstitutionArgs
    classes?: boolean | TeacherCountOutputTypeCountClassesArgs
  }

  // Custom InputTypes
  /**
   * TeacherCountOutputType without action
   */
  export type TeacherCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherCountOutputType
     */
    select?: TeacherCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TeacherCountOutputType without action
   */
  export type TeacherCountOutputTypeCountInstitutionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeacherOnInstitutionWhereInput
  }

  /**
   * TeacherCountOutputType without action
   */
  export type TeacherCountOutputTypeCountClassesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeacherOnClassWhereInput
  }


  /**
   * Count Type ClassCountOutputType
   */

  export type ClassCountOutputType = {
    students: number
    teachers: number
    enrollments: number
    attendances: number
    timetables: number
  }

  export type ClassCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    students?: boolean | ClassCountOutputTypeCountStudentsArgs
    teachers?: boolean | ClassCountOutputTypeCountTeachersArgs
    enrollments?: boolean | ClassCountOutputTypeCountEnrollmentsArgs
    attendances?: boolean | ClassCountOutputTypeCountAttendancesArgs
    timetables?: boolean | ClassCountOutputTypeCountTimetablesArgs
  }

  // Custom InputTypes
  /**
   * ClassCountOutputType without action
   */
  export type ClassCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassCountOutputType
     */
    select?: ClassCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ClassCountOutputType without action
   */
  export type ClassCountOutputTypeCountStudentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentWhereInput
  }

  /**
   * ClassCountOutputType without action
   */
  export type ClassCountOutputTypeCountTeachersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeacherOnClassWhereInput
  }

  /**
   * ClassCountOutputType without action
   */
  export type ClassCountOutputTypeCountEnrollmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EnrollmentWhereInput
  }

  /**
   * ClassCountOutputType without action
   */
  export type ClassCountOutputTypeCountAttendancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceWhereInput
  }

  /**
   * ClassCountOutputType without action
   */
  export type ClassCountOutputTypeCountTimetablesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TimetableWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Institution
   */

  export type AggregateInstitution = {
    _count: InstitutionCountAggregateOutputType | null
    _min: InstitutionMinAggregateOutputType | null
    _max: InstitutionMaxAggregateOutputType | null
  }

  export type InstitutionMinAggregateOutputType = {
    id: string | null
    name: string | null
    institutionType: $Enums.InstitutionType | null
    address: string | null
    city: string | null
    state: string | null
    country: string | null
    phone: string | null
    email: string | null
    website: string | null
    plan: $Enums.InstitutionPlan | null
    subscriptionStatus: $Enums.SubscriptionStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InstitutionMaxAggregateOutputType = {
    id: string | null
    name: string | null
    institutionType: $Enums.InstitutionType | null
    address: string | null
    city: string | null
    state: string | null
    country: string | null
    phone: string | null
    email: string | null
    website: string | null
    plan: $Enums.InstitutionPlan | null
    subscriptionStatus: $Enums.SubscriptionStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InstitutionCountAggregateOutputType = {
    id: number
    name: number
    institutionType: number
    address: number
    city: number
    state: number
    country: number
    phone: number
    email: number
    website: number
    plan: number
    subscriptionStatus: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InstitutionMinAggregateInputType = {
    id?: true
    name?: true
    institutionType?: true
    address?: true
    city?: true
    state?: true
    country?: true
    phone?: true
    email?: true
    website?: true
    plan?: true
    subscriptionStatus?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InstitutionMaxAggregateInputType = {
    id?: true
    name?: true
    institutionType?: true
    address?: true
    city?: true
    state?: true
    country?: true
    phone?: true
    email?: true
    website?: true
    plan?: true
    subscriptionStatus?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InstitutionCountAggregateInputType = {
    id?: true
    name?: true
    institutionType?: true
    address?: true
    city?: true
    state?: true
    country?: true
    phone?: true
    email?: true
    website?: true
    plan?: true
    subscriptionStatus?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InstitutionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Institution to aggregate.
     */
    where?: InstitutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Institutions to fetch.
     */
    orderBy?: InstitutionOrderByWithRelationInput | InstitutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InstitutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Institutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Institutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Institutions
    **/
    _count?: true | InstitutionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InstitutionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InstitutionMaxAggregateInputType
  }

  export type GetInstitutionAggregateType<T extends InstitutionAggregateArgs> = {
        [P in keyof T & keyof AggregateInstitution]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInstitution[P]>
      : GetScalarType<T[P], AggregateInstitution[P]>
  }




  export type InstitutionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InstitutionWhereInput
    orderBy?: InstitutionOrderByWithAggregationInput | InstitutionOrderByWithAggregationInput[]
    by: InstitutionScalarFieldEnum[] | InstitutionScalarFieldEnum
    having?: InstitutionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InstitutionCountAggregateInputType | true
    _min?: InstitutionMinAggregateInputType
    _max?: InstitutionMaxAggregateInputType
  }

  export type InstitutionGroupByOutputType = {
    id: string
    name: string
    institutionType: $Enums.InstitutionType
    address: string
    city: string
    state: string
    country: string
    phone: string
    email: string
    website: string | null
    plan: $Enums.InstitutionPlan
    subscriptionStatus: $Enums.SubscriptionStatus
    createdAt: Date
    updatedAt: Date
    _count: InstitutionCountAggregateOutputType | null
    _min: InstitutionMinAggregateOutputType | null
    _max: InstitutionMaxAggregateOutputType | null
  }

  type GetInstitutionGroupByPayload<T extends InstitutionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InstitutionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InstitutionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InstitutionGroupByOutputType[P]>
            : GetScalarType<T[P], InstitutionGroupByOutputType[P]>
        }
      >
    >


  export type InstitutionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    institutionType?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    country?: boolean
    phone?: boolean
    email?: boolean
    website?: boolean
    plan?: boolean
    subscriptionStatus?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users?: boolean | Institution$usersArgs<ExtArgs>
    classes?: boolean | Institution$classesArgs<ExtArgs>
    students?: boolean | Institution$studentsArgs<ExtArgs>
    teachers?: boolean | Institution$teachersArgs<ExtArgs>
    invoices?: boolean | Institution$invoicesArgs<ExtArgs>
    messages?: boolean | Institution$messagesArgs<ExtArgs>
    _count?: boolean | InstitutionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["institution"]>



  export type InstitutionSelectScalar = {
    id?: boolean
    name?: boolean
    institutionType?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    country?: boolean
    phone?: boolean
    email?: boolean
    website?: boolean
    plan?: boolean
    subscriptionStatus?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type InstitutionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "institutionType" | "address" | "city" | "state" | "country" | "phone" | "email" | "website" | "plan" | "subscriptionStatus" | "createdAt" | "updatedAt", ExtArgs["result"]["institution"]>
  export type InstitutionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | Institution$usersArgs<ExtArgs>
    classes?: boolean | Institution$classesArgs<ExtArgs>
    students?: boolean | Institution$studentsArgs<ExtArgs>
    teachers?: boolean | Institution$teachersArgs<ExtArgs>
    invoices?: boolean | Institution$invoicesArgs<ExtArgs>
    messages?: boolean | Institution$messagesArgs<ExtArgs>
    _count?: boolean | InstitutionCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $InstitutionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Institution"
    objects: {
      users: Prisma.$UsersOnInstitutionPayload<ExtArgs>[]
      classes: Prisma.$ClassPayload<ExtArgs>[]
      students: Prisma.$StudentPayload<ExtArgs>[]
      teachers: Prisma.$TeacherOnInstitutionPayload<ExtArgs>[]
      invoices: Prisma.$InvoicePayload<ExtArgs>[]
      messages: Prisma.$MessagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      institutionType: $Enums.InstitutionType
      address: string
      city: string
      state: string
      country: string
      phone: string
      email: string
      website: string | null
      plan: $Enums.InstitutionPlan
      subscriptionStatus: $Enums.SubscriptionStatus
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["institution"]>
    composites: {}
  }

  type InstitutionGetPayload<S extends boolean | null | undefined | InstitutionDefaultArgs> = $Result.GetResult<Prisma.$InstitutionPayload, S>

  type InstitutionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InstitutionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InstitutionCountAggregateInputType | true
    }

  export interface InstitutionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Institution'], meta: { name: 'Institution' } }
    /**
     * Find zero or one Institution that matches the filter.
     * @param {InstitutionFindUniqueArgs} args - Arguments to find a Institution
     * @example
     * // Get one Institution
     * const institution = await prisma.institution.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InstitutionFindUniqueArgs>(args: SelectSubset<T, InstitutionFindUniqueArgs<ExtArgs>>): Prisma__InstitutionClient<$Result.GetResult<Prisma.$InstitutionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Institution that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InstitutionFindUniqueOrThrowArgs} args - Arguments to find a Institution
     * @example
     * // Get one Institution
     * const institution = await prisma.institution.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InstitutionFindUniqueOrThrowArgs>(args: SelectSubset<T, InstitutionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InstitutionClient<$Result.GetResult<Prisma.$InstitutionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Institution that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstitutionFindFirstArgs} args - Arguments to find a Institution
     * @example
     * // Get one Institution
     * const institution = await prisma.institution.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InstitutionFindFirstArgs>(args?: SelectSubset<T, InstitutionFindFirstArgs<ExtArgs>>): Prisma__InstitutionClient<$Result.GetResult<Prisma.$InstitutionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Institution that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstitutionFindFirstOrThrowArgs} args - Arguments to find a Institution
     * @example
     * // Get one Institution
     * const institution = await prisma.institution.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InstitutionFindFirstOrThrowArgs>(args?: SelectSubset<T, InstitutionFindFirstOrThrowArgs<ExtArgs>>): Prisma__InstitutionClient<$Result.GetResult<Prisma.$InstitutionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Institutions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstitutionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Institutions
     * const institutions = await prisma.institution.findMany()
     * 
     * // Get first 10 Institutions
     * const institutions = await prisma.institution.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const institutionWithIdOnly = await prisma.institution.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InstitutionFindManyArgs>(args?: SelectSubset<T, InstitutionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstitutionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Institution.
     * @param {InstitutionCreateArgs} args - Arguments to create a Institution.
     * @example
     * // Create one Institution
     * const Institution = await prisma.institution.create({
     *   data: {
     *     // ... data to create a Institution
     *   }
     * })
     * 
     */
    create<T extends InstitutionCreateArgs>(args: SelectSubset<T, InstitutionCreateArgs<ExtArgs>>): Prisma__InstitutionClient<$Result.GetResult<Prisma.$InstitutionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Institutions.
     * @param {InstitutionCreateManyArgs} args - Arguments to create many Institutions.
     * @example
     * // Create many Institutions
     * const institution = await prisma.institution.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InstitutionCreateManyArgs>(args?: SelectSubset<T, InstitutionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Institution.
     * @param {InstitutionDeleteArgs} args - Arguments to delete one Institution.
     * @example
     * // Delete one Institution
     * const Institution = await prisma.institution.delete({
     *   where: {
     *     // ... filter to delete one Institution
     *   }
     * })
     * 
     */
    delete<T extends InstitutionDeleteArgs>(args: SelectSubset<T, InstitutionDeleteArgs<ExtArgs>>): Prisma__InstitutionClient<$Result.GetResult<Prisma.$InstitutionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Institution.
     * @param {InstitutionUpdateArgs} args - Arguments to update one Institution.
     * @example
     * // Update one Institution
     * const institution = await prisma.institution.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InstitutionUpdateArgs>(args: SelectSubset<T, InstitutionUpdateArgs<ExtArgs>>): Prisma__InstitutionClient<$Result.GetResult<Prisma.$InstitutionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Institutions.
     * @param {InstitutionDeleteManyArgs} args - Arguments to filter Institutions to delete.
     * @example
     * // Delete a few Institutions
     * const { count } = await prisma.institution.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InstitutionDeleteManyArgs>(args?: SelectSubset<T, InstitutionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Institutions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstitutionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Institutions
     * const institution = await prisma.institution.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InstitutionUpdateManyArgs>(args: SelectSubset<T, InstitutionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Institution.
     * @param {InstitutionUpsertArgs} args - Arguments to update or create a Institution.
     * @example
     * // Update or create a Institution
     * const institution = await prisma.institution.upsert({
     *   create: {
     *     // ... data to create a Institution
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Institution we want to update
     *   }
     * })
     */
    upsert<T extends InstitutionUpsertArgs>(args: SelectSubset<T, InstitutionUpsertArgs<ExtArgs>>): Prisma__InstitutionClient<$Result.GetResult<Prisma.$InstitutionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Institutions that matches the filter.
     * @param {InstitutionFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const institution = await prisma.institution.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: InstitutionFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Institution.
     * @param {InstitutionAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const institution = await prisma.institution.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: InstitutionAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Institutions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstitutionCountArgs} args - Arguments to filter Institutions to count.
     * @example
     * // Count the number of Institutions
     * const count = await prisma.institution.count({
     *   where: {
     *     // ... the filter for the Institutions we want to count
     *   }
     * })
    **/
    count<T extends InstitutionCountArgs>(
      args?: Subset<T, InstitutionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InstitutionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Institution.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstitutionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InstitutionAggregateArgs>(args: Subset<T, InstitutionAggregateArgs>): Prisma.PrismaPromise<GetInstitutionAggregateType<T>>

    /**
     * Group by Institution.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstitutionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InstitutionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InstitutionGroupByArgs['orderBy'] }
        : { orderBy?: InstitutionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InstitutionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInstitutionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Institution model
   */
  readonly fields: InstitutionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Institution.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InstitutionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends Institution$usersArgs<ExtArgs> = {}>(args?: Subset<T, Institution$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsersOnInstitutionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    classes<T extends Institution$classesArgs<ExtArgs> = {}>(args?: Subset<T, Institution$classesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    students<T extends Institution$studentsArgs<ExtArgs> = {}>(args?: Subset<T, Institution$studentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    teachers<T extends Institution$teachersArgs<ExtArgs> = {}>(args?: Subset<T, Institution$teachersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeacherOnInstitutionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    invoices<T extends Institution$invoicesArgs<ExtArgs> = {}>(args?: Subset<T, Institution$invoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    messages<T extends Institution$messagesArgs<ExtArgs> = {}>(args?: Subset<T, Institution$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Institution model
   */
  interface InstitutionFieldRefs {
    readonly id: FieldRef<"Institution", 'String'>
    readonly name: FieldRef<"Institution", 'String'>
    readonly institutionType: FieldRef<"Institution", 'InstitutionType'>
    readonly address: FieldRef<"Institution", 'String'>
    readonly city: FieldRef<"Institution", 'String'>
    readonly state: FieldRef<"Institution", 'String'>
    readonly country: FieldRef<"Institution", 'String'>
    readonly phone: FieldRef<"Institution", 'String'>
    readonly email: FieldRef<"Institution", 'String'>
    readonly website: FieldRef<"Institution", 'String'>
    readonly plan: FieldRef<"Institution", 'InstitutionPlan'>
    readonly subscriptionStatus: FieldRef<"Institution", 'SubscriptionStatus'>
    readonly createdAt: FieldRef<"Institution", 'DateTime'>
    readonly updatedAt: FieldRef<"Institution", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Institution findUnique
   */
  export type InstitutionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Institution
     */
    select?: InstitutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Institution
     */
    omit?: InstitutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstitutionInclude<ExtArgs> | null
    /**
     * Filter, which Institution to fetch.
     */
    where: InstitutionWhereUniqueInput
  }

  /**
   * Institution findUniqueOrThrow
   */
  export type InstitutionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Institution
     */
    select?: InstitutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Institution
     */
    omit?: InstitutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstitutionInclude<ExtArgs> | null
    /**
     * Filter, which Institution to fetch.
     */
    where: InstitutionWhereUniqueInput
  }

  /**
   * Institution findFirst
   */
  export type InstitutionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Institution
     */
    select?: InstitutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Institution
     */
    omit?: InstitutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstitutionInclude<ExtArgs> | null
    /**
     * Filter, which Institution to fetch.
     */
    where?: InstitutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Institutions to fetch.
     */
    orderBy?: InstitutionOrderByWithRelationInput | InstitutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Institutions.
     */
    cursor?: InstitutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Institutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Institutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Institutions.
     */
    distinct?: InstitutionScalarFieldEnum | InstitutionScalarFieldEnum[]
  }

  /**
   * Institution findFirstOrThrow
   */
  export type InstitutionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Institution
     */
    select?: InstitutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Institution
     */
    omit?: InstitutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstitutionInclude<ExtArgs> | null
    /**
     * Filter, which Institution to fetch.
     */
    where?: InstitutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Institutions to fetch.
     */
    orderBy?: InstitutionOrderByWithRelationInput | InstitutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Institutions.
     */
    cursor?: InstitutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Institutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Institutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Institutions.
     */
    distinct?: InstitutionScalarFieldEnum | InstitutionScalarFieldEnum[]
  }

  /**
   * Institution findMany
   */
  export type InstitutionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Institution
     */
    select?: InstitutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Institution
     */
    omit?: InstitutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstitutionInclude<ExtArgs> | null
    /**
     * Filter, which Institutions to fetch.
     */
    where?: InstitutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Institutions to fetch.
     */
    orderBy?: InstitutionOrderByWithRelationInput | InstitutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Institutions.
     */
    cursor?: InstitutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Institutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Institutions.
     */
    skip?: number
    distinct?: InstitutionScalarFieldEnum | InstitutionScalarFieldEnum[]
  }

  /**
   * Institution create
   */
  export type InstitutionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Institution
     */
    select?: InstitutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Institution
     */
    omit?: InstitutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstitutionInclude<ExtArgs> | null
    /**
     * The data needed to create a Institution.
     */
    data: XOR<InstitutionCreateInput, InstitutionUncheckedCreateInput>
  }

  /**
   * Institution createMany
   */
  export type InstitutionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Institutions.
     */
    data: InstitutionCreateManyInput | InstitutionCreateManyInput[]
  }

  /**
   * Institution update
   */
  export type InstitutionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Institution
     */
    select?: InstitutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Institution
     */
    omit?: InstitutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstitutionInclude<ExtArgs> | null
    /**
     * The data needed to update a Institution.
     */
    data: XOR<InstitutionUpdateInput, InstitutionUncheckedUpdateInput>
    /**
     * Choose, which Institution to update.
     */
    where: InstitutionWhereUniqueInput
  }

  /**
   * Institution updateMany
   */
  export type InstitutionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Institutions.
     */
    data: XOR<InstitutionUpdateManyMutationInput, InstitutionUncheckedUpdateManyInput>
    /**
     * Filter which Institutions to update
     */
    where?: InstitutionWhereInput
    /**
     * Limit how many Institutions to update.
     */
    limit?: number
  }

  /**
   * Institution upsert
   */
  export type InstitutionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Institution
     */
    select?: InstitutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Institution
     */
    omit?: InstitutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstitutionInclude<ExtArgs> | null
    /**
     * The filter to search for the Institution to update in case it exists.
     */
    where: InstitutionWhereUniqueInput
    /**
     * In case the Institution found by the `where` argument doesn't exist, create a new Institution with this data.
     */
    create: XOR<InstitutionCreateInput, InstitutionUncheckedCreateInput>
    /**
     * In case the Institution was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InstitutionUpdateInput, InstitutionUncheckedUpdateInput>
  }

  /**
   * Institution delete
   */
  export type InstitutionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Institution
     */
    select?: InstitutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Institution
     */
    omit?: InstitutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstitutionInclude<ExtArgs> | null
    /**
     * Filter which Institution to delete.
     */
    where: InstitutionWhereUniqueInput
  }

  /**
   * Institution deleteMany
   */
  export type InstitutionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Institutions to delete
     */
    where?: InstitutionWhereInput
    /**
     * Limit how many Institutions to delete.
     */
    limit?: number
  }

  /**
   * Institution findRaw
   */
  export type InstitutionFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Institution aggregateRaw
   */
  export type InstitutionAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Institution.users
   */
  export type Institution$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersOnInstitution
     */
    select?: UsersOnInstitutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsersOnInstitution
     */
    omit?: UsersOnInstitutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersOnInstitutionInclude<ExtArgs> | null
    where?: UsersOnInstitutionWhereInput
    orderBy?: UsersOnInstitutionOrderByWithRelationInput | UsersOnInstitutionOrderByWithRelationInput[]
    cursor?: UsersOnInstitutionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UsersOnInstitutionScalarFieldEnum | UsersOnInstitutionScalarFieldEnum[]
  }

  /**
   * Institution.classes
   */
  export type Institution$classesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    where?: ClassWhereInput
    orderBy?: ClassOrderByWithRelationInput | ClassOrderByWithRelationInput[]
    cursor?: ClassWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClassScalarFieldEnum | ClassScalarFieldEnum[]
  }

  /**
   * Institution.students
   */
  export type Institution$studentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    where?: StudentWhereInput
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    cursor?: StudentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * Institution.teachers
   */
  export type Institution$teachersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherOnInstitution
     */
    select?: TeacherOnInstitutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeacherOnInstitution
     */
    omit?: TeacherOnInstitutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherOnInstitutionInclude<ExtArgs> | null
    where?: TeacherOnInstitutionWhereInput
    orderBy?: TeacherOnInstitutionOrderByWithRelationInput | TeacherOnInstitutionOrderByWithRelationInput[]
    cursor?: TeacherOnInstitutionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeacherOnInstitutionScalarFieldEnum | TeacherOnInstitutionScalarFieldEnum[]
  }

  /**
   * Institution.invoices
   */
  export type Institution$invoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    cursor?: InvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Institution.messages
   */
  export type Institution$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Institution without action
   */
  export type InstitutionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Institution
     */
    select?: InstitutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Institution
     */
    omit?: InstitutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstitutionInclude<ExtArgs> | null
  }


  /**
   * Model UsersOnInstitution
   */

  export type AggregateUsersOnInstitution = {
    _count: UsersOnInstitutionCountAggregateOutputType | null
    _min: UsersOnInstitutionMinAggregateOutputType | null
    _max: UsersOnInstitutionMaxAggregateOutputType | null
  }

  export type UsersOnInstitutionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    institutionId: string | null
  }

  export type UsersOnInstitutionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    institutionId: string | null
  }

  export type UsersOnInstitutionCountAggregateOutputType = {
    id: number
    userId: number
    institutionId: number
    _all: number
  }


  export type UsersOnInstitutionMinAggregateInputType = {
    id?: true
    userId?: true
    institutionId?: true
  }

  export type UsersOnInstitutionMaxAggregateInputType = {
    id?: true
    userId?: true
    institutionId?: true
  }

  export type UsersOnInstitutionCountAggregateInputType = {
    id?: true
    userId?: true
    institutionId?: true
    _all?: true
  }

  export type UsersOnInstitutionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UsersOnInstitution to aggregate.
     */
    where?: UsersOnInstitutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsersOnInstitutions to fetch.
     */
    orderBy?: UsersOnInstitutionOrderByWithRelationInput | UsersOnInstitutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UsersOnInstitutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsersOnInstitutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsersOnInstitutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UsersOnInstitutions
    **/
    _count?: true | UsersOnInstitutionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsersOnInstitutionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsersOnInstitutionMaxAggregateInputType
  }

  export type GetUsersOnInstitutionAggregateType<T extends UsersOnInstitutionAggregateArgs> = {
        [P in keyof T & keyof AggregateUsersOnInstitution]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsersOnInstitution[P]>
      : GetScalarType<T[P], AggregateUsersOnInstitution[P]>
  }




  export type UsersOnInstitutionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsersOnInstitutionWhereInput
    orderBy?: UsersOnInstitutionOrderByWithAggregationInput | UsersOnInstitutionOrderByWithAggregationInput[]
    by: UsersOnInstitutionScalarFieldEnum[] | UsersOnInstitutionScalarFieldEnum
    having?: UsersOnInstitutionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsersOnInstitutionCountAggregateInputType | true
    _min?: UsersOnInstitutionMinAggregateInputType
    _max?: UsersOnInstitutionMaxAggregateInputType
  }

  export type UsersOnInstitutionGroupByOutputType = {
    id: string
    userId: string
    institutionId: string
    _count: UsersOnInstitutionCountAggregateOutputType | null
    _min: UsersOnInstitutionMinAggregateOutputType | null
    _max: UsersOnInstitutionMaxAggregateOutputType | null
  }

  type GetUsersOnInstitutionGroupByPayload<T extends UsersOnInstitutionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsersOnInstitutionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsersOnInstitutionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsersOnInstitutionGroupByOutputType[P]>
            : GetScalarType<T[P], UsersOnInstitutionGroupByOutputType[P]>
        }
      >
    >


  export type UsersOnInstitutionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    institutionId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    institution?: boolean | InstitutionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["usersOnInstitution"]>



  export type UsersOnInstitutionSelectScalar = {
    id?: boolean
    userId?: boolean
    institutionId?: boolean
  }

  export type UsersOnInstitutionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "institutionId", ExtArgs["result"]["usersOnInstitution"]>
  export type UsersOnInstitutionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    institution?: boolean | InstitutionDefaultArgs<ExtArgs>
  }

  export type $UsersOnInstitutionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UsersOnInstitution"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      institution: Prisma.$InstitutionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      institutionId: string
    }, ExtArgs["result"]["usersOnInstitution"]>
    composites: {}
  }

  type UsersOnInstitutionGetPayload<S extends boolean | null | undefined | UsersOnInstitutionDefaultArgs> = $Result.GetResult<Prisma.$UsersOnInstitutionPayload, S>

  type UsersOnInstitutionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UsersOnInstitutionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UsersOnInstitutionCountAggregateInputType | true
    }

  export interface UsersOnInstitutionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UsersOnInstitution'], meta: { name: 'UsersOnInstitution' } }
    /**
     * Find zero or one UsersOnInstitution that matches the filter.
     * @param {UsersOnInstitutionFindUniqueArgs} args - Arguments to find a UsersOnInstitution
     * @example
     * // Get one UsersOnInstitution
     * const usersOnInstitution = await prisma.usersOnInstitution.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UsersOnInstitutionFindUniqueArgs>(args: SelectSubset<T, UsersOnInstitutionFindUniqueArgs<ExtArgs>>): Prisma__UsersOnInstitutionClient<$Result.GetResult<Prisma.$UsersOnInstitutionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UsersOnInstitution that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UsersOnInstitutionFindUniqueOrThrowArgs} args - Arguments to find a UsersOnInstitution
     * @example
     * // Get one UsersOnInstitution
     * const usersOnInstitution = await prisma.usersOnInstitution.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UsersOnInstitutionFindUniqueOrThrowArgs>(args: SelectSubset<T, UsersOnInstitutionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UsersOnInstitutionClient<$Result.GetResult<Prisma.$UsersOnInstitutionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UsersOnInstitution that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersOnInstitutionFindFirstArgs} args - Arguments to find a UsersOnInstitution
     * @example
     * // Get one UsersOnInstitution
     * const usersOnInstitution = await prisma.usersOnInstitution.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UsersOnInstitutionFindFirstArgs>(args?: SelectSubset<T, UsersOnInstitutionFindFirstArgs<ExtArgs>>): Prisma__UsersOnInstitutionClient<$Result.GetResult<Prisma.$UsersOnInstitutionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UsersOnInstitution that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersOnInstitutionFindFirstOrThrowArgs} args - Arguments to find a UsersOnInstitution
     * @example
     * // Get one UsersOnInstitution
     * const usersOnInstitution = await prisma.usersOnInstitution.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UsersOnInstitutionFindFirstOrThrowArgs>(args?: SelectSubset<T, UsersOnInstitutionFindFirstOrThrowArgs<ExtArgs>>): Prisma__UsersOnInstitutionClient<$Result.GetResult<Prisma.$UsersOnInstitutionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UsersOnInstitutions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersOnInstitutionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UsersOnInstitutions
     * const usersOnInstitutions = await prisma.usersOnInstitution.findMany()
     * 
     * // Get first 10 UsersOnInstitutions
     * const usersOnInstitutions = await prisma.usersOnInstitution.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usersOnInstitutionWithIdOnly = await prisma.usersOnInstitution.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UsersOnInstitutionFindManyArgs>(args?: SelectSubset<T, UsersOnInstitutionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsersOnInstitutionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UsersOnInstitution.
     * @param {UsersOnInstitutionCreateArgs} args - Arguments to create a UsersOnInstitution.
     * @example
     * // Create one UsersOnInstitution
     * const UsersOnInstitution = await prisma.usersOnInstitution.create({
     *   data: {
     *     // ... data to create a UsersOnInstitution
     *   }
     * })
     * 
     */
    create<T extends UsersOnInstitutionCreateArgs>(args: SelectSubset<T, UsersOnInstitutionCreateArgs<ExtArgs>>): Prisma__UsersOnInstitutionClient<$Result.GetResult<Prisma.$UsersOnInstitutionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UsersOnInstitutions.
     * @param {UsersOnInstitutionCreateManyArgs} args - Arguments to create many UsersOnInstitutions.
     * @example
     * // Create many UsersOnInstitutions
     * const usersOnInstitution = await prisma.usersOnInstitution.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UsersOnInstitutionCreateManyArgs>(args?: SelectSubset<T, UsersOnInstitutionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UsersOnInstitution.
     * @param {UsersOnInstitutionDeleteArgs} args - Arguments to delete one UsersOnInstitution.
     * @example
     * // Delete one UsersOnInstitution
     * const UsersOnInstitution = await prisma.usersOnInstitution.delete({
     *   where: {
     *     // ... filter to delete one UsersOnInstitution
     *   }
     * })
     * 
     */
    delete<T extends UsersOnInstitutionDeleteArgs>(args: SelectSubset<T, UsersOnInstitutionDeleteArgs<ExtArgs>>): Prisma__UsersOnInstitutionClient<$Result.GetResult<Prisma.$UsersOnInstitutionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UsersOnInstitution.
     * @param {UsersOnInstitutionUpdateArgs} args - Arguments to update one UsersOnInstitution.
     * @example
     * // Update one UsersOnInstitution
     * const usersOnInstitution = await prisma.usersOnInstitution.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UsersOnInstitutionUpdateArgs>(args: SelectSubset<T, UsersOnInstitutionUpdateArgs<ExtArgs>>): Prisma__UsersOnInstitutionClient<$Result.GetResult<Prisma.$UsersOnInstitutionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UsersOnInstitutions.
     * @param {UsersOnInstitutionDeleteManyArgs} args - Arguments to filter UsersOnInstitutions to delete.
     * @example
     * // Delete a few UsersOnInstitutions
     * const { count } = await prisma.usersOnInstitution.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UsersOnInstitutionDeleteManyArgs>(args?: SelectSubset<T, UsersOnInstitutionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UsersOnInstitutions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersOnInstitutionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UsersOnInstitutions
     * const usersOnInstitution = await prisma.usersOnInstitution.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UsersOnInstitutionUpdateManyArgs>(args: SelectSubset<T, UsersOnInstitutionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UsersOnInstitution.
     * @param {UsersOnInstitutionUpsertArgs} args - Arguments to update or create a UsersOnInstitution.
     * @example
     * // Update or create a UsersOnInstitution
     * const usersOnInstitution = await prisma.usersOnInstitution.upsert({
     *   create: {
     *     // ... data to create a UsersOnInstitution
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UsersOnInstitution we want to update
     *   }
     * })
     */
    upsert<T extends UsersOnInstitutionUpsertArgs>(args: SelectSubset<T, UsersOnInstitutionUpsertArgs<ExtArgs>>): Prisma__UsersOnInstitutionClient<$Result.GetResult<Prisma.$UsersOnInstitutionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UsersOnInstitutions that matches the filter.
     * @param {UsersOnInstitutionFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const usersOnInstitution = await prisma.usersOnInstitution.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: UsersOnInstitutionFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a UsersOnInstitution.
     * @param {UsersOnInstitutionAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const usersOnInstitution = await prisma.usersOnInstitution.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: UsersOnInstitutionAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of UsersOnInstitutions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersOnInstitutionCountArgs} args - Arguments to filter UsersOnInstitutions to count.
     * @example
     * // Count the number of UsersOnInstitutions
     * const count = await prisma.usersOnInstitution.count({
     *   where: {
     *     // ... the filter for the UsersOnInstitutions we want to count
     *   }
     * })
    **/
    count<T extends UsersOnInstitutionCountArgs>(
      args?: Subset<T, UsersOnInstitutionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsersOnInstitutionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UsersOnInstitution.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersOnInstitutionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsersOnInstitutionAggregateArgs>(args: Subset<T, UsersOnInstitutionAggregateArgs>): Prisma.PrismaPromise<GetUsersOnInstitutionAggregateType<T>>

    /**
     * Group by UsersOnInstitution.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersOnInstitutionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UsersOnInstitutionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UsersOnInstitutionGroupByArgs['orderBy'] }
        : { orderBy?: UsersOnInstitutionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UsersOnInstitutionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsersOnInstitutionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UsersOnInstitution model
   */
  readonly fields: UsersOnInstitutionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UsersOnInstitution.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UsersOnInstitutionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    institution<T extends InstitutionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InstitutionDefaultArgs<ExtArgs>>): Prisma__InstitutionClient<$Result.GetResult<Prisma.$InstitutionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UsersOnInstitution model
   */
  interface UsersOnInstitutionFieldRefs {
    readonly id: FieldRef<"UsersOnInstitution", 'String'>
    readonly userId: FieldRef<"UsersOnInstitution", 'String'>
    readonly institutionId: FieldRef<"UsersOnInstitution", 'String'>
  }
    

  // Custom InputTypes
  /**
   * UsersOnInstitution findUnique
   */
  export type UsersOnInstitutionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersOnInstitution
     */
    select?: UsersOnInstitutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsersOnInstitution
     */
    omit?: UsersOnInstitutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersOnInstitutionInclude<ExtArgs> | null
    /**
     * Filter, which UsersOnInstitution to fetch.
     */
    where: UsersOnInstitutionWhereUniqueInput
  }

  /**
   * UsersOnInstitution findUniqueOrThrow
   */
  export type UsersOnInstitutionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersOnInstitution
     */
    select?: UsersOnInstitutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsersOnInstitution
     */
    omit?: UsersOnInstitutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersOnInstitutionInclude<ExtArgs> | null
    /**
     * Filter, which UsersOnInstitution to fetch.
     */
    where: UsersOnInstitutionWhereUniqueInput
  }

  /**
   * UsersOnInstitution findFirst
   */
  export type UsersOnInstitutionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersOnInstitution
     */
    select?: UsersOnInstitutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsersOnInstitution
     */
    omit?: UsersOnInstitutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersOnInstitutionInclude<ExtArgs> | null
    /**
     * Filter, which UsersOnInstitution to fetch.
     */
    where?: UsersOnInstitutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsersOnInstitutions to fetch.
     */
    orderBy?: UsersOnInstitutionOrderByWithRelationInput | UsersOnInstitutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UsersOnInstitutions.
     */
    cursor?: UsersOnInstitutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsersOnInstitutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsersOnInstitutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UsersOnInstitutions.
     */
    distinct?: UsersOnInstitutionScalarFieldEnum | UsersOnInstitutionScalarFieldEnum[]
  }

  /**
   * UsersOnInstitution findFirstOrThrow
   */
  export type UsersOnInstitutionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersOnInstitution
     */
    select?: UsersOnInstitutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsersOnInstitution
     */
    omit?: UsersOnInstitutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersOnInstitutionInclude<ExtArgs> | null
    /**
     * Filter, which UsersOnInstitution to fetch.
     */
    where?: UsersOnInstitutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsersOnInstitutions to fetch.
     */
    orderBy?: UsersOnInstitutionOrderByWithRelationInput | UsersOnInstitutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UsersOnInstitutions.
     */
    cursor?: UsersOnInstitutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsersOnInstitutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsersOnInstitutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UsersOnInstitutions.
     */
    distinct?: UsersOnInstitutionScalarFieldEnum | UsersOnInstitutionScalarFieldEnum[]
  }

  /**
   * UsersOnInstitution findMany
   */
  export type UsersOnInstitutionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersOnInstitution
     */
    select?: UsersOnInstitutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsersOnInstitution
     */
    omit?: UsersOnInstitutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersOnInstitutionInclude<ExtArgs> | null
    /**
     * Filter, which UsersOnInstitutions to fetch.
     */
    where?: UsersOnInstitutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsersOnInstitutions to fetch.
     */
    orderBy?: UsersOnInstitutionOrderByWithRelationInput | UsersOnInstitutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UsersOnInstitutions.
     */
    cursor?: UsersOnInstitutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsersOnInstitutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsersOnInstitutions.
     */
    skip?: number
    distinct?: UsersOnInstitutionScalarFieldEnum | UsersOnInstitutionScalarFieldEnum[]
  }

  /**
   * UsersOnInstitution create
   */
  export type UsersOnInstitutionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersOnInstitution
     */
    select?: UsersOnInstitutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsersOnInstitution
     */
    omit?: UsersOnInstitutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersOnInstitutionInclude<ExtArgs> | null
    /**
     * The data needed to create a UsersOnInstitution.
     */
    data: XOR<UsersOnInstitutionCreateInput, UsersOnInstitutionUncheckedCreateInput>
  }

  /**
   * UsersOnInstitution createMany
   */
  export type UsersOnInstitutionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UsersOnInstitutions.
     */
    data: UsersOnInstitutionCreateManyInput | UsersOnInstitutionCreateManyInput[]
  }

  /**
   * UsersOnInstitution update
   */
  export type UsersOnInstitutionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersOnInstitution
     */
    select?: UsersOnInstitutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsersOnInstitution
     */
    omit?: UsersOnInstitutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersOnInstitutionInclude<ExtArgs> | null
    /**
     * The data needed to update a UsersOnInstitution.
     */
    data: XOR<UsersOnInstitutionUpdateInput, UsersOnInstitutionUncheckedUpdateInput>
    /**
     * Choose, which UsersOnInstitution to update.
     */
    where: UsersOnInstitutionWhereUniqueInput
  }

  /**
   * UsersOnInstitution updateMany
   */
  export type UsersOnInstitutionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UsersOnInstitutions.
     */
    data: XOR<UsersOnInstitutionUpdateManyMutationInput, UsersOnInstitutionUncheckedUpdateManyInput>
    /**
     * Filter which UsersOnInstitutions to update
     */
    where?: UsersOnInstitutionWhereInput
    /**
     * Limit how many UsersOnInstitutions to update.
     */
    limit?: number
  }

  /**
   * UsersOnInstitution upsert
   */
  export type UsersOnInstitutionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersOnInstitution
     */
    select?: UsersOnInstitutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsersOnInstitution
     */
    omit?: UsersOnInstitutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersOnInstitutionInclude<ExtArgs> | null
    /**
     * The filter to search for the UsersOnInstitution to update in case it exists.
     */
    where: UsersOnInstitutionWhereUniqueInput
    /**
     * In case the UsersOnInstitution found by the `where` argument doesn't exist, create a new UsersOnInstitution with this data.
     */
    create: XOR<UsersOnInstitutionCreateInput, UsersOnInstitutionUncheckedCreateInput>
    /**
     * In case the UsersOnInstitution was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UsersOnInstitutionUpdateInput, UsersOnInstitutionUncheckedUpdateInput>
  }

  /**
   * UsersOnInstitution delete
   */
  export type UsersOnInstitutionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersOnInstitution
     */
    select?: UsersOnInstitutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsersOnInstitution
     */
    omit?: UsersOnInstitutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersOnInstitutionInclude<ExtArgs> | null
    /**
     * Filter which UsersOnInstitution to delete.
     */
    where: UsersOnInstitutionWhereUniqueInput
  }

  /**
   * UsersOnInstitution deleteMany
   */
  export type UsersOnInstitutionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UsersOnInstitutions to delete
     */
    where?: UsersOnInstitutionWhereInput
    /**
     * Limit how many UsersOnInstitutions to delete.
     */
    limit?: number
  }

  /**
   * UsersOnInstitution findRaw
   */
  export type UsersOnInstitutionFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * UsersOnInstitution aggregateRaw
   */
  export type UsersOnInstitutionAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * UsersOnInstitution without action
   */
  export type UsersOnInstitutionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersOnInstitution
     */
    select?: UsersOnInstitutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsersOnInstitution
     */
    omit?: UsersOnInstitutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersOnInstitutionInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    firstName: string | null
    middleName: string | null
    lastName: string | null
    dateOfBirth: Date | null
    role: $Enums.Role | null
    email: string | null
    password: string | null
    avatar: string | null
    phone: string | null
    isActive: boolean | null
    lastlogin: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    firstName: string | null
    middleName: string | null
    lastName: string | null
    dateOfBirth: Date | null
    role: $Enums.Role | null
    email: string | null
    password: string | null
    avatar: string | null
    phone: string | null
    isActive: boolean | null
    lastlogin: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    firstName: number
    middleName: number
    lastName: number
    dateOfBirth: number
    role: number
    email: number
    password: number
    avatar: number
    phone: number
    isActive: number
    lastlogin: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    firstName?: true
    middleName?: true
    lastName?: true
    dateOfBirth?: true
    role?: true
    email?: true
    password?: true
    avatar?: true
    phone?: true
    isActive?: true
    lastlogin?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    firstName?: true
    middleName?: true
    lastName?: true
    dateOfBirth?: true
    role?: true
    email?: true
    password?: true
    avatar?: true
    phone?: true
    isActive?: true
    lastlogin?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    firstName?: true
    middleName?: true
    lastName?: true
    dateOfBirth?: true
    role?: true
    email?: true
    password?: true
    avatar?: true
    phone?: true
    isActive?: true
    lastlogin?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    firstName: string
    middleName: string | null
    lastName: string
    dateOfBirth: Date
    role: $Enums.Role
    email: string
    password: string
    avatar: string | null
    phone: string | null
    isActive: boolean
    lastlogin: Date | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstName?: boolean
    middleName?: boolean
    lastName?: boolean
    dateOfBirth?: boolean
    role?: boolean
    email?: boolean
    password?: boolean
    avatar?: boolean
    phone?: boolean
    isActive?: boolean
    lastlogin?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    student?: boolean | User$studentArgs<ExtArgs>
    teacher?: boolean | User$teacherArgs<ExtArgs>
    parent?: boolean | User$parentArgs<ExtArgs>
    institutions?: boolean | User$institutionsArgs<ExtArgs>
    sentMessages?: boolean | User$sentMessagesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>



  export type UserSelectScalar = {
    id?: boolean
    firstName?: boolean
    middleName?: boolean
    lastName?: boolean
    dateOfBirth?: boolean
    role?: boolean
    email?: boolean
    password?: boolean
    avatar?: boolean
    phone?: boolean
    isActive?: boolean
    lastlogin?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "firstName" | "middleName" | "lastName" | "dateOfBirth" | "role" | "email" | "password" | "avatar" | "phone" | "isActive" | "lastlogin" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | User$studentArgs<ExtArgs>
    teacher?: boolean | User$teacherArgs<ExtArgs>
    parent?: boolean | User$parentArgs<ExtArgs>
    institutions?: boolean | User$institutionsArgs<ExtArgs>
    sentMessages?: boolean | User$sentMessagesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      student: Prisma.$StudentPayload<ExtArgs>[]
      teacher: Prisma.$TeacherPayload<ExtArgs>[]
      parent: Prisma.$UserToParentPayload<ExtArgs>[]
      institutions: Prisma.$UsersOnInstitutionPayload<ExtArgs>[]
      sentMessages: Prisma.$MessagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      firstName: string
      middleName: string | null
      lastName: string
      dateOfBirth: Date
      role: $Enums.Role
      email: string
      password: string
      avatar: string | null
      phone: string | null
      isActive: boolean
      lastlogin: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * @param {UserFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const user = await prisma.user.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: UserFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a User.
     * @param {UserAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const user = await prisma.user.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: UserAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends User$studentArgs<ExtArgs> = {}>(args?: Subset<T, User$studentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    teacher<T extends User$teacherArgs<ExtArgs> = {}>(args?: Subset<T, User$teacherArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    parent<T extends User$parentArgs<ExtArgs> = {}>(args?: Subset<T, User$parentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserToParentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    institutions<T extends User$institutionsArgs<ExtArgs> = {}>(args?: Subset<T, User$institutionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsersOnInstitutionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sentMessages<T extends User$sentMessagesArgs<ExtArgs> = {}>(args?: Subset<T, User$sentMessagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly firstName: FieldRef<"User", 'String'>
    readonly middleName: FieldRef<"User", 'String'>
    readonly lastName: FieldRef<"User", 'String'>
    readonly dateOfBirth: FieldRef<"User", 'DateTime'>
    readonly role: FieldRef<"User", 'Role'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly avatar: FieldRef<"User", 'String'>
    readonly phone: FieldRef<"User", 'String'>
    readonly isActive: FieldRef<"User", 'Boolean'>
    readonly lastlogin: FieldRef<"User", 'DateTime'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User findRaw
   */
  export type UserFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * User aggregateRaw
   */
  export type UserAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * User.student
   */
  export type User$studentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    where?: StudentWhereInput
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    cursor?: StudentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * User.teacher
   */
  export type User$teacherArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teacher
     */
    omit?: TeacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
    where?: TeacherWhereInput
    orderBy?: TeacherOrderByWithRelationInput | TeacherOrderByWithRelationInput[]
    cursor?: TeacherWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeacherScalarFieldEnum | TeacherScalarFieldEnum[]
  }

  /**
   * User.parent
   */
  export type User$parentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserToParent
     */
    select?: UserToParentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserToParent
     */
    omit?: UserToParentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserToParentInclude<ExtArgs> | null
    where?: UserToParentWhereInput
    orderBy?: UserToParentOrderByWithRelationInput | UserToParentOrderByWithRelationInput[]
    cursor?: UserToParentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserToParentScalarFieldEnum | UserToParentScalarFieldEnum[]
  }

  /**
   * User.institutions
   */
  export type User$institutionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersOnInstitution
     */
    select?: UsersOnInstitutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsersOnInstitution
     */
    omit?: UsersOnInstitutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersOnInstitutionInclude<ExtArgs> | null
    where?: UsersOnInstitutionWhereInput
    orderBy?: UsersOnInstitutionOrderByWithRelationInput | UsersOnInstitutionOrderByWithRelationInput[]
    cursor?: UsersOnInstitutionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UsersOnInstitutionScalarFieldEnum | UsersOnInstitutionScalarFieldEnum[]
  }

  /**
   * User.sentMessages
   */
  export type User$sentMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Student
   */

  export type AggregateStudent = {
    _count: StudentCountAggregateOutputType | null
    _min: StudentMinAggregateOutputType | null
    _max: StudentMaxAggregateOutputType | null
  }

  export type StudentMinAggregateOutputType = {
    id: string | null
    userId: string | null
    institutionId: string | null
    firstName: string | null
    middleName: string | null
    lastName: string | null
    admissionNumber: string | null
    dateOfBirth: Date | null
    gender: string | null
    bloodGroup: string | null
    address: string | null
    gradeApplying: string | null
    academicYear: string | null
    classId: string | null
    phone: string | null
    email: string | null
    fingerprintEnrolled: boolean | null
    photo: string | null
    medicalConditions: string | null
    allergies: string | null
    medications: string | null
    previousSchool: string | null
    previousGrade: string | null
    transferReason: string | null
    enrollmentStatus: string | null
    enrollmentDate: Date | null
    nationality: string | null
    religion: string | null
    specialNeeds: string | null
    transportRequired: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StudentMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    institutionId: string | null
    firstName: string | null
    middleName: string | null
    lastName: string | null
    admissionNumber: string | null
    dateOfBirth: Date | null
    gender: string | null
    bloodGroup: string | null
    address: string | null
    gradeApplying: string | null
    academicYear: string | null
    classId: string | null
    phone: string | null
    email: string | null
    fingerprintEnrolled: boolean | null
    photo: string | null
    medicalConditions: string | null
    allergies: string | null
    medications: string | null
    previousSchool: string | null
    previousGrade: string | null
    transferReason: string | null
    enrollmentStatus: string | null
    enrollmentDate: Date | null
    nationality: string | null
    religion: string | null
    specialNeeds: string | null
    transportRequired: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StudentCountAggregateOutputType = {
    id: number
    userId: number
    institutionId: number
    firstName: number
    middleName: number
    lastName: number
    admissionNumber: number
    dateOfBirth: number
    gender: number
    bloodGroup: number
    address: number
    gradeApplying: number
    academicYear: number
    classId: number
    phone: number
    email: number
    guardians: number
    fingerprintEnrolled: number
    fingerprintData: number
    faceData: number
    documents: number
    photo: number
    emergencyContacts: number
    medicalConditions: number
    allergies: number
    medications: number
    previousSchool: number
    previousGrade: number
    transferReason: number
    enrollmentStatus: number
    enrollmentDate: number
    nationality: number
    religion: number
    languagesSpoken: number
    specialNeeds: number
    transportRequired: number
    createdAt: number
    updatedAt: number
    parentIds: number
    _all: number
  }


  export type StudentMinAggregateInputType = {
    id?: true
    userId?: true
    institutionId?: true
    firstName?: true
    middleName?: true
    lastName?: true
    admissionNumber?: true
    dateOfBirth?: true
    gender?: true
    bloodGroup?: true
    address?: true
    gradeApplying?: true
    academicYear?: true
    classId?: true
    phone?: true
    email?: true
    fingerprintEnrolled?: true
    photo?: true
    medicalConditions?: true
    allergies?: true
    medications?: true
    previousSchool?: true
    previousGrade?: true
    transferReason?: true
    enrollmentStatus?: true
    enrollmentDate?: true
    nationality?: true
    religion?: true
    specialNeeds?: true
    transportRequired?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StudentMaxAggregateInputType = {
    id?: true
    userId?: true
    institutionId?: true
    firstName?: true
    middleName?: true
    lastName?: true
    admissionNumber?: true
    dateOfBirth?: true
    gender?: true
    bloodGroup?: true
    address?: true
    gradeApplying?: true
    academicYear?: true
    classId?: true
    phone?: true
    email?: true
    fingerprintEnrolled?: true
    photo?: true
    medicalConditions?: true
    allergies?: true
    medications?: true
    previousSchool?: true
    previousGrade?: true
    transferReason?: true
    enrollmentStatus?: true
    enrollmentDate?: true
    nationality?: true
    religion?: true
    specialNeeds?: true
    transportRequired?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StudentCountAggregateInputType = {
    id?: true
    userId?: true
    institutionId?: true
    firstName?: true
    middleName?: true
    lastName?: true
    admissionNumber?: true
    dateOfBirth?: true
    gender?: true
    bloodGroup?: true
    address?: true
    gradeApplying?: true
    academicYear?: true
    classId?: true
    phone?: true
    email?: true
    guardians?: true
    fingerprintEnrolled?: true
    fingerprintData?: true
    faceData?: true
    documents?: true
    photo?: true
    emergencyContacts?: true
    medicalConditions?: true
    allergies?: true
    medications?: true
    previousSchool?: true
    previousGrade?: true
    transferReason?: true
    enrollmentStatus?: true
    enrollmentDate?: true
    nationality?: true
    religion?: true
    languagesSpoken?: true
    specialNeeds?: true
    transportRequired?: true
    createdAt?: true
    updatedAt?: true
    parentIds?: true
    _all?: true
  }

  export type StudentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Student to aggregate.
     */
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Students
    **/
    _count?: true | StudentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentMaxAggregateInputType
  }

  export type GetStudentAggregateType<T extends StudentAggregateArgs> = {
        [P in keyof T & keyof AggregateStudent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudent[P]>
      : GetScalarType<T[P], AggregateStudent[P]>
  }




  export type StudentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentWhereInput
    orderBy?: StudentOrderByWithAggregationInput | StudentOrderByWithAggregationInput[]
    by: StudentScalarFieldEnum[] | StudentScalarFieldEnum
    having?: StudentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentCountAggregateInputType | true
    _min?: StudentMinAggregateInputType
    _max?: StudentMaxAggregateInputType
  }

  export type StudentGroupByOutputType = {
    id: string
    userId: string | null
    institutionId: string
    firstName: string
    middleName: string | null
    lastName: string
    admissionNumber: string | null
    dateOfBirth: Date | null
    gender: string | null
    bloodGroup: string | null
    address: string | null
    gradeApplying: string | null
    academicYear: string | null
    classId: string | null
    phone: string | null
    email: string | null
    guardians: JsonValue | null
    fingerprintEnrolled: boolean
    fingerprintData: JsonValue | null
    faceData: JsonValue | null
    documents: JsonValue | null
    photo: string | null
    emergencyContacts: JsonValue | null
    medicalConditions: string | null
    allergies: string | null
    medications: string | null
    previousSchool: string | null
    previousGrade: string | null
    transferReason: string | null
    enrollmentStatus: string
    enrollmentDate: Date | null
    nationality: string | null
    religion: string | null
    languagesSpoken: string[]
    specialNeeds: string | null
    transportRequired: boolean
    createdAt: Date
    updatedAt: Date
    parentIds: string[]
    _count: StudentCountAggregateOutputType | null
    _min: StudentMinAggregateOutputType | null
    _max: StudentMaxAggregateOutputType | null
  }

  type GetStudentGroupByPayload<T extends StudentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentGroupByOutputType[P]>
            : GetScalarType<T[P], StudentGroupByOutputType[P]>
        }
      >
    >


  export type StudentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    institutionId?: boolean
    firstName?: boolean
    middleName?: boolean
    lastName?: boolean
    admissionNumber?: boolean
    dateOfBirth?: boolean
    gender?: boolean
    bloodGroup?: boolean
    address?: boolean
    gradeApplying?: boolean
    academicYear?: boolean
    classId?: boolean
    phone?: boolean
    email?: boolean
    guardians?: boolean
    fingerprintEnrolled?: boolean
    fingerprintData?: boolean
    faceData?: boolean
    documents?: boolean
    photo?: boolean
    emergencyContacts?: boolean
    medicalConditions?: boolean
    allergies?: boolean
    medications?: boolean
    previousSchool?: boolean
    previousGrade?: boolean
    transferReason?: boolean
    enrollmentStatus?: boolean
    enrollmentDate?: boolean
    nationality?: boolean
    religion?: boolean
    languagesSpoken?: boolean
    specialNeeds?: boolean
    transportRequired?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parentIds?: boolean
    StudentDocument?: boolean | Student$StudentDocumentArgs<ExtArgs>
    user?: boolean | Student$userArgs<ExtArgs>
    institution?: boolean | InstitutionDefaultArgs<ExtArgs>
    class?: boolean | Student$classArgs<ExtArgs>
    parents?: boolean | Student$parentsArgs<ExtArgs>
    enrollments?: boolean | Student$enrollmentsArgs<ExtArgs>
    attendances?: boolean | Student$attendancesArgs<ExtArgs>
    grades?: boolean | Student$gradesArgs<ExtArgs>
    invoices?: boolean | Student$invoicesArgs<ExtArgs>
    _count?: boolean | StudentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["student"]>



  export type StudentSelectScalar = {
    id?: boolean
    userId?: boolean
    institutionId?: boolean
    firstName?: boolean
    middleName?: boolean
    lastName?: boolean
    admissionNumber?: boolean
    dateOfBirth?: boolean
    gender?: boolean
    bloodGroup?: boolean
    address?: boolean
    gradeApplying?: boolean
    academicYear?: boolean
    classId?: boolean
    phone?: boolean
    email?: boolean
    guardians?: boolean
    fingerprintEnrolled?: boolean
    fingerprintData?: boolean
    faceData?: boolean
    documents?: boolean
    photo?: boolean
    emergencyContacts?: boolean
    medicalConditions?: boolean
    allergies?: boolean
    medications?: boolean
    previousSchool?: boolean
    previousGrade?: boolean
    transferReason?: boolean
    enrollmentStatus?: boolean
    enrollmentDate?: boolean
    nationality?: boolean
    religion?: boolean
    languagesSpoken?: boolean
    specialNeeds?: boolean
    transportRequired?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parentIds?: boolean
  }

  export type StudentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "institutionId" | "firstName" | "middleName" | "lastName" | "admissionNumber" | "dateOfBirth" | "gender" | "bloodGroup" | "address" | "gradeApplying" | "academicYear" | "classId" | "phone" | "email" | "guardians" | "fingerprintEnrolled" | "fingerprintData" | "faceData" | "documents" | "photo" | "emergencyContacts" | "medicalConditions" | "allergies" | "medications" | "previousSchool" | "previousGrade" | "transferReason" | "enrollmentStatus" | "enrollmentDate" | "nationality" | "religion" | "languagesSpoken" | "specialNeeds" | "transportRequired" | "createdAt" | "updatedAt" | "parentIds", ExtArgs["result"]["student"]>
  export type StudentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    StudentDocument?: boolean | Student$StudentDocumentArgs<ExtArgs>
    user?: boolean | Student$userArgs<ExtArgs>
    institution?: boolean | InstitutionDefaultArgs<ExtArgs>
    class?: boolean | Student$classArgs<ExtArgs>
    parents?: boolean | Student$parentsArgs<ExtArgs>
    enrollments?: boolean | Student$enrollmentsArgs<ExtArgs>
    attendances?: boolean | Student$attendancesArgs<ExtArgs>
    grades?: boolean | Student$gradesArgs<ExtArgs>
    invoices?: boolean | Student$invoicesArgs<ExtArgs>
    _count?: boolean | StudentCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $StudentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Student"
    objects: {
      StudentDocument: Prisma.$StudentDocumentPayload<ExtArgs>[]
      user: Prisma.$UserPayload<ExtArgs> | null
      institution: Prisma.$InstitutionPayload<ExtArgs>
      class: Prisma.$ClassPayload<ExtArgs> | null
      parents: Prisma.$ParentPayload<ExtArgs>[]
      enrollments: Prisma.$EnrollmentPayload<ExtArgs>[]
      attendances: Prisma.$AttendancePayload<ExtArgs>[]
      grades: Prisma.$GradePayload<ExtArgs>[]
      invoices: Prisma.$InvoicePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string | null
      institutionId: string
      firstName: string
      middleName: string | null
      lastName: string
      admissionNumber: string | null
      dateOfBirth: Date | null
      gender: string | null
      bloodGroup: string | null
      address: string | null
      gradeApplying: string | null
      academicYear: string | null
      classId: string | null
      phone: string | null
      email: string | null
      guardians: Prisma.JsonValue | null
      fingerprintEnrolled: boolean
      fingerprintData: Prisma.JsonValue | null
      faceData: Prisma.JsonValue | null
      documents: Prisma.JsonValue | null
      photo: string | null
      emergencyContacts: Prisma.JsonValue | null
      medicalConditions: string | null
      allergies: string | null
      medications: string | null
      previousSchool: string | null
      previousGrade: string | null
      transferReason: string | null
      enrollmentStatus: string
      enrollmentDate: Date | null
      nationality: string | null
      religion: string | null
      languagesSpoken: string[]
      specialNeeds: string | null
      transportRequired: boolean
      createdAt: Date
      updatedAt: Date
      parentIds: string[]
    }, ExtArgs["result"]["student"]>
    composites: {}
  }

  type StudentGetPayload<S extends boolean | null | undefined | StudentDefaultArgs> = $Result.GetResult<Prisma.$StudentPayload, S>

  type StudentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StudentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StudentCountAggregateInputType | true
    }

  export interface StudentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Student'], meta: { name: 'Student' } }
    /**
     * Find zero or one Student that matches the filter.
     * @param {StudentFindUniqueArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StudentFindUniqueArgs>(args: SelectSubset<T, StudentFindUniqueArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Student that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StudentFindUniqueOrThrowArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StudentFindUniqueOrThrowArgs>(args: SelectSubset<T, StudentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Student that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentFindFirstArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StudentFindFirstArgs>(args?: SelectSubset<T, StudentFindFirstArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Student that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentFindFirstOrThrowArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StudentFindFirstOrThrowArgs>(args?: SelectSubset<T, StudentFindFirstOrThrowArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Students that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Students
     * const students = await prisma.student.findMany()
     * 
     * // Get first 10 Students
     * const students = await prisma.student.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const studentWithIdOnly = await prisma.student.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StudentFindManyArgs>(args?: SelectSubset<T, StudentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Student.
     * @param {StudentCreateArgs} args - Arguments to create a Student.
     * @example
     * // Create one Student
     * const Student = await prisma.student.create({
     *   data: {
     *     // ... data to create a Student
     *   }
     * })
     * 
     */
    create<T extends StudentCreateArgs>(args: SelectSubset<T, StudentCreateArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Students.
     * @param {StudentCreateManyArgs} args - Arguments to create many Students.
     * @example
     * // Create many Students
     * const student = await prisma.student.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StudentCreateManyArgs>(args?: SelectSubset<T, StudentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Student.
     * @param {StudentDeleteArgs} args - Arguments to delete one Student.
     * @example
     * // Delete one Student
     * const Student = await prisma.student.delete({
     *   where: {
     *     // ... filter to delete one Student
     *   }
     * })
     * 
     */
    delete<T extends StudentDeleteArgs>(args: SelectSubset<T, StudentDeleteArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Student.
     * @param {StudentUpdateArgs} args - Arguments to update one Student.
     * @example
     * // Update one Student
     * const student = await prisma.student.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StudentUpdateArgs>(args: SelectSubset<T, StudentUpdateArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Students.
     * @param {StudentDeleteManyArgs} args - Arguments to filter Students to delete.
     * @example
     * // Delete a few Students
     * const { count } = await prisma.student.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StudentDeleteManyArgs>(args?: SelectSubset<T, StudentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Students.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Students
     * const student = await prisma.student.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StudentUpdateManyArgs>(args: SelectSubset<T, StudentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Student.
     * @param {StudentUpsertArgs} args - Arguments to update or create a Student.
     * @example
     * // Update or create a Student
     * const student = await prisma.student.upsert({
     *   create: {
     *     // ... data to create a Student
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Student we want to update
     *   }
     * })
     */
    upsert<T extends StudentUpsertArgs>(args: SelectSubset<T, StudentUpsertArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Students that matches the filter.
     * @param {StudentFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const student = await prisma.student.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: StudentFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Student.
     * @param {StudentAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const student = await prisma.student.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: StudentAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Students.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentCountArgs} args - Arguments to filter Students to count.
     * @example
     * // Count the number of Students
     * const count = await prisma.student.count({
     *   where: {
     *     // ... the filter for the Students we want to count
     *   }
     * })
    **/
    count<T extends StudentCountArgs>(
      args?: Subset<T, StudentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Student.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentAggregateArgs>(args: Subset<T, StudentAggregateArgs>): Prisma.PrismaPromise<GetStudentAggregateType<T>>

    /**
     * Group by Student.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudentGroupByArgs['orderBy'] }
        : { orderBy?: StudentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Student model
   */
  readonly fields: StudentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Student.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StudentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    StudentDocument<T extends Student$StudentDocumentArgs<ExtArgs> = {}>(args?: Subset<T, Student$StudentDocumentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentDocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    user<T extends Student$userArgs<ExtArgs> = {}>(args?: Subset<T, Student$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    institution<T extends InstitutionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InstitutionDefaultArgs<ExtArgs>>): Prisma__InstitutionClient<$Result.GetResult<Prisma.$InstitutionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    class<T extends Student$classArgs<ExtArgs> = {}>(args?: Subset<T, Student$classArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    parents<T extends Student$parentsArgs<ExtArgs> = {}>(args?: Subset<T, Student$parentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    enrollments<T extends Student$enrollmentsArgs<ExtArgs> = {}>(args?: Subset<T, Student$enrollmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    attendances<T extends Student$attendancesArgs<ExtArgs> = {}>(args?: Subset<T, Student$attendancesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    grades<T extends Student$gradesArgs<ExtArgs> = {}>(args?: Subset<T, Student$gradesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GradePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    invoices<T extends Student$invoicesArgs<ExtArgs> = {}>(args?: Subset<T, Student$invoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Student model
   */
  interface StudentFieldRefs {
    readonly id: FieldRef<"Student", 'String'>
    readonly userId: FieldRef<"Student", 'String'>
    readonly institutionId: FieldRef<"Student", 'String'>
    readonly firstName: FieldRef<"Student", 'String'>
    readonly middleName: FieldRef<"Student", 'String'>
    readonly lastName: FieldRef<"Student", 'String'>
    readonly admissionNumber: FieldRef<"Student", 'String'>
    readonly dateOfBirth: FieldRef<"Student", 'DateTime'>
    readonly gender: FieldRef<"Student", 'String'>
    readonly bloodGroup: FieldRef<"Student", 'String'>
    readonly address: FieldRef<"Student", 'String'>
    readonly gradeApplying: FieldRef<"Student", 'String'>
    readonly academicYear: FieldRef<"Student", 'String'>
    readonly classId: FieldRef<"Student", 'String'>
    readonly phone: FieldRef<"Student", 'String'>
    readonly email: FieldRef<"Student", 'String'>
    readonly guardians: FieldRef<"Student", 'Json'>
    readonly fingerprintEnrolled: FieldRef<"Student", 'Boolean'>
    readonly fingerprintData: FieldRef<"Student", 'Json'>
    readonly faceData: FieldRef<"Student", 'Json'>
    readonly documents: FieldRef<"Student", 'Json'>
    readonly photo: FieldRef<"Student", 'String'>
    readonly emergencyContacts: FieldRef<"Student", 'Json'>
    readonly medicalConditions: FieldRef<"Student", 'String'>
    readonly allergies: FieldRef<"Student", 'String'>
    readonly medications: FieldRef<"Student", 'String'>
    readonly previousSchool: FieldRef<"Student", 'String'>
    readonly previousGrade: FieldRef<"Student", 'String'>
    readonly transferReason: FieldRef<"Student", 'String'>
    readonly enrollmentStatus: FieldRef<"Student", 'String'>
    readonly enrollmentDate: FieldRef<"Student", 'DateTime'>
    readonly nationality: FieldRef<"Student", 'String'>
    readonly religion: FieldRef<"Student", 'String'>
    readonly languagesSpoken: FieldRef<"Student", 'String[]'>
    readonly specialNeeds: FieldRef<"Student", 'String'>
    readonly transportRequired: FieldRef<"Student", 'Boolean'>
    readonly createdAt: FieldRef<"Student", 'DateTime'>
    readonly updatedAt: FieldRef<"Student", 'DateTime'>
    readonly parentIds: FieldRef<"Student", 'String[]'>
  }
    

  // Custom InputTypes
  /**
   * Student findUnique
   */
  export type StudentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Student to fetch.
     */
    where: StudentWhereUniqueInput
  }

  /**
   * Student findUniqueOrThrow
   */
  export type StudentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Student to fetch.
     */
    where: StudentWhereUniqueInput
  }

  /**
   * Student findFirst
   */
  export type StudentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Student to fetch.
     */
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Students.
     */
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Students.
     */
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * Student findFirstOrThrow
   */
  export type StudentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Student to fetch.
     */
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Students.
     */
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Students.
     */
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * Student findMany
   */
  export type StudentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Students to fetch.
     */
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Students.
     */
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * Student create
   */
  export type StudentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * The data needed to create a Student.
     */
    data: XOR<StudentCreateInput, StudentUncheckedCreateInput>
  }

  /**
   * Student createMany
   */
  export type StudentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Students.
     */
    data: StudentCreateManyInput | StudentCreateManyInput[]
  }

  /**
   * Student update
   */
  export type StudentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * The data needed to update a Student.
     */
    data: XOR<StudentUpdateInput, StudentUncheckedUpdateInput>
    /**
     * Choose, which Student to update.
     */
    where: StudentWhereUniqueInput
  }

  /**
   * Student updateMany
   */
  export type StudentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Students.
     */
    data: XOR<StudentUpdateManyMutationInput, StudentUncheckedUpdateManyInput>
    /**
     * Filter which Students to update
     */
    where?: StudentWhereInput
    /**
     * Limit how many Students to update.
     */
    limit?: number
  }

  /**
   * Student upsert
   */
  export type StudentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * The filter to search for the Student to update in case it exists.
     */
    where: StudentWhereUniqueInput
    /**
     * In case the Student found by the `where` argument doesn't exist, create a new Student with this data.
     */
    create: XOR<StudentCreateInput, StudentUncheckedCreateInput>
    /**
     * In case the Student was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudentUpdateInput, StudentUncheckedUpdateInput>
  }

  /**
   * Student delete
   */
  export type StudentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter which Student to delete.
     */
    where: StudentWhereUniqueInput
  }

  /**
   * Student deleteMany
   */
  export type StudentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Students to delete
     */
    where?: StudentWhereInput
    /**
     * Limit how many Students to delete.
     */
    limit?: number
  }

  /**
   * Student findRaw
   */
  export type StudentFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Student aggregateRaw
   */
  export type StudentAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Student.StudentDocument
   */
  export type Student$StudentDocumentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentDocument
     */
    select?: StudentDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentDocument
     */
    omit?: StudentDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentDocumentInclude<ExtArgs> | null
    where?: StudentDocumentWhereInput
    orderBy?: StudentDocumentOrderByWithRelationInput | StudentDocumentOrderByWithRelationInput[]
    cursor?: StudentDocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentDocumentScalarFieldEnum | StudentDocumentScalarFieldEnum[]
  }

  /**
   * Student.user
   */
  export type Student$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Student.class
   */
  export type Student$classArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    where?: ClassWhereInput
  }

  /**
   * Student.parents
   */
  export type Student$parentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parent
     */
    select?: ParentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parent
     */
    omit?: ParentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentInclude<ExtArgs> | null
    where?: ParentWhereInput
    orderBy?: ParentOrderByWithRelationInput | ParentOrderByWithRelationInput[]
    cursor?: ParentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ParentScalarFieldEnum | ParentScalarFieldEnum[]
  }

  /**
   * Student.enrollments
   */
  export type Student$enrollmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Enrollment
     */
    omit?: EnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
    where?: EnrollmentWhereInput
    orderBy?: EnrollmentOrderByWithRelationInput | EnrollmentOrderByWithRelationInput[]
    cursor?: EnrollmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EnrollmentScalarFieldEnum | EnrollmentScalarFieldEnum[]
  }

  /**
   * Student.attendances
   */
  export type Student$attendancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    where?: AttendanceWhereInput
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    cursor?: AttendanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[]
  }

  /**
   * Student.grades
   */
  export type Student$gradesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grade
     */
    select?: GradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Grade
     */
    omit?: GradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeInclude<ExtArgs> | null
    where?: GradeWhereInput
    orderBy?: GradeOrderByWithRelationInput | GradeOrderByWithRelationInput[]
    cursor?: GradeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GradeScalarFieldEnum | GradeScalarFieldEnum[]
  }

  /**
   * Student.invoices
   */
  export type Student$invoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    cursor?: InvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Student without action
   */
  export type StudentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
  }


  /**
   * Model UserToParent
   */

  export type AggregateUserToParent = {
    _count: UserToParentCountAggregateOutputType | null
    _min: UserToParentMinAggregateOutputType | null
    _max: UserToParentMaxAggregateOutputType | null
  }

  export type UserToParentMinAggregateOutputType = {
    id: string | null
    userId: string | null
    parentId: string | null
  }

  export type UserToParentMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    parentId: string | null
  }

  export type UserToParentCountAggregateOutputType = {
    id: number
    userId: number
    parentId: number
    _all: number
  }


  export type UserToParentMinAggregateInputType = {
    id?: true
    userId?: true
    parentId?: true
  }

  export type UserToParentMaxAggregateInputType = {
    id?: true
    userId?: true
    parentId?: true
  }

  export type UserToParentCountAggregateInputType = {
    id?: true
    userId?: true
    parentId?: true
    _all?: true
  }

  export type UserToParentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserToParent to aggregate.
     */
    where?: UserToParentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserToParents to fetch.
     */
    orderBy?: UserToParentOrderByWithRelationInput | UserToParentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserToParentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserToParents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserToParents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserToParents
    **/
    _count?: true | UserToParentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserToParentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserToParentMaxAggregateInputType
  }

  export type GetUserToParentAggregateType<T extends UserToParentAggregateArgs> = {
        [P in keyof T & keyof AggregateUserToParent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserToParent[P]>
      : GetScalarType<T[P], AggregateUserToParent[P]>
  }




  export type UserToParentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserToParentWhereInput
    orderBy?: UserToParentOrderByWithAggregationInput | UserToParentOrderByWithAggregationInput[]
    by: UserToParentScalarFieldEnum[] | UserToParentScalarFieldEnum
    having?: UserToParentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserToParentCountAggregateInputType | true
    _min?: UserToParentMinAggregateInputType
    _max?: UserToParentMaxAggregateInputType
  }

  export type UserToParentGroupByOutputType = {
    id: string
    userId: string
    parentId: string
    _count: UserToParentCountAggregateOutputType | null
    _min: UserToParentMinAggregateOutputType | null
    _max: UserToParentMaxAggregateOutputType | null
  }

  type GetUserToParentGroupByPayload<T extends UserToParentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserToParentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserToParentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserToParentGroupByOutputType[P]>
            : GetScalarType<T[P], UserToParentGroupByOutputType[P]>
        }
      >
    >


  export type UserToParentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    parentId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    parent?: boolean | ParentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userToParent"]>



  export type UserToParentSelectScalar = {
    id?: boolean
    userId?: boolean
    parentId?: boolean
  }

  export type UserToParentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "parentId", ExtArgs["result"]["userToParent"]>
  export type UserToParentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    parent?: boolean | ParentDefaultArgs<ExtArgs>
  }

  export type $UserToParentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserToParent"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      parent: Prisma.$ParentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      parentId: string
    }, ExtArgs["result"]["userToParent"]>
    composites: {}
  }

  type UserToParentGetPayload<S extends boolean | null | undefined | UserToParentDefaultArgs> = $Result.GetResult<Prisma.$UserToParentPayload, S>

  type UserToParentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserToParentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserToParentCountAggregateInputType | true
    }

  export interface UserToParentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserToParent'], meta: { name: 'UserToParent' } }
    /**
     * Find zero or one UserToParent that matches the filter.
     * @param {UserToParentFindUniqueArgs} args - Arguments to find a UserToParent
     * @example
     * // Get one UserToParent
     * const userToParent = await prisma.userToParent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserToParentFindUniqueArgs>(args: SelectSubset<T, UserToParentFindUniqueArgs<ExtArgs>>): Prisma__UserToParentClient<$Result.GetResult<Prisma.$UserToParentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserToParent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserToParentFindUniqueOrThrowArgs} args - Arguments to find a UserToParent
     * @example
     * // Get one UserToParent
     * const userToParent = await prisma.userToParent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserToParentFindUniqueOrThrowArgs>(args: SelectSubset<T, UserToParentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserToParentClient<$Result.GetResult<Prisma.$UserToParentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserToParent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserToParentFindFirstArgs} args - Arguments to find a UserToParent
     * @example
     * // Get one UserToParent
     * const userToParent = await prisma.userToParent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserToParentFindFirstArgs>(args?: SelectSubset<T, UserToParentFindFirstArgs<ExtArgs>>): Prisma__UserToParentClient<$Result.GetResult<Prisma.$UserToParentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserToParent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserToParentFindFirstOrThrowArgs} args - Arguments to find a UserToParent
     * @example
     * // Get one UserToParent
     * const userToParent = await prisma.userToParent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserToParentFindFirstOrThrowArgs>(args?: SelectSubset<T, UserToParentFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserToParentClient<$Result.GetResult<Prisma.$UserToParentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserToParents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserToParentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserToParents
     * const userToParents = await prisma.userToParent.findMany()
     * 
     * // Get first 10 UserToParents
     * const userToParents = await prisma.userToParent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userToParentWithIdOnly = await prisma.userToParent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserToParentFindManyArgs>(args?: SelectSubset<T, UserToParentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserToParentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserToParent.
     * @param {UserToParentCreateArgs} args - Arguments to create a UserToParent.
     * @example
     * // Create one UserToParent
     * const UserToParent = await prisma.userToParent.create({
     *   data: {
     *     // ... data to create a UserToParent
     *   }
     * })
     * 
     */
    create<T extends UserToParentCreateArgs>(args: SelectSubset<T, UserToParentCreateArgs<ExtArgs>>): Prisma__UserToParentClient<$Result.GetResult<Prisma.$UserToParentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserToParents.
     * @param {UserToParentCreateManyArgs} args - Arguments to create many UserToParents.
     * @example
     * // Create many UserToParents
     * const userToParent = await prisma.userToParent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserToParentCreateManyArgs>(args?: SelectSubset<T, UserToParentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UserToParent.
     * @param {UserToParentDeleteArgs} args - Arguments to delete one UserToParent.
     * @example
     * // Delete one UserToParent
     * const UserToParent = await prisma.userToParent.delete({
     *   where: {
     *     // ... filter to delete one UserToParent
     *   }
     * })
     * 
     */
    delete<T extends UserToParentDeleteArgs>(args: SelectSubset<T, UserToParentDeleteArgs<ExtArgs>>): Prisma__UserToParentClient<$Result.GetResult<Prisma.$UserToParentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserToParent.
     * @param {UserToParentUpdateArgs} args - Arguments to update one UserToParent.
     * @example
     * // Update one UserToParent
     * const userToParent = await prisma.userToParent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserToParentUpdateArgs>(args: SelectSubset<T, UserToParentUpdateArgs<ExtArgs>>): Prisma__UserToParentClient<$Result.GetResult<Prisma.$UserToParentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserToParents.
     * @param {UserToParentDeleteManyArgs} args - Arguments to filter UserToParents to delete.
     * @example
     * // Delete a few UserToParents
     * const { count } = await prisma.userToParent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserToParentDeleteManyArgs>(args?: SelectSubset<T, UserToParentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserToParents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserToParentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserToParents
     * const userToParent = await prisma.userToParent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserToParentUpdateManyArgs>(args: SelectSubset<T, UserToParentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserToParent.
     * @param {UserToParentUpsertArgs} args - Arguments to update or create a UserToParent.
     * @example
     * // Update or create a UserToParent
     * const userToParent = await prisma.userToParent.upsert({
     *   create: {
     *     // ... data to create a UserToParent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserToParent we want to update
     *   }
     * })
     */
    upsert<T extends UserToParentUpsertArgs>(args: SelectSubset<T, UserToParentUpsertArgs<ExtArgs>>): Prisma__UserToParentClient<$Result.GetResult<Prisma.$UserToParentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserToParents that matches the filter.
     * @param {UserToParentFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const userToParent = await prisma.userToParent.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: UserToParentFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a UserToParent.
     * @param {UserToParentAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const userToParent = await prisma.userToParent.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: UserToParentAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of UserToParents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserToParentCountArgs} args - Arguments to filter UserToParents to count.
     * @example
     * // Count the number of UserToParents
     * const count = await prisma.userToParent.count({
     *   where: {
     *     // ... the filter for the UserToParents we want to count
     *   }
     * })
    **/
    count<T extends UserToParentCountArgs>(
      args?: Subset<T, UserToParentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserToParentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserToParent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserToParentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserToParentAggregateArgs>(args: Subset<T, UserToParentAggregateArgs>): Prisma.PrismaPromise<GetUserToParentAggregateType<T>>

    /**
     * Group by UserToParent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserToParentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserToParentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserToParentGroupByArgs['orderBy'] }
        : { orderBy?: UserToParentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserToParentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserToParentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserToParent model
   */
  readonly fields: UserToParentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserToParent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserToParentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    parent<T extends ParentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ParentDefaultArgs<ExtArgs>>): Prisma__ParentClient<$Result.GetResult<Prisma.$ParentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserToParent model
   */
  interface UserToParentFieldRefs {
    readonly id: FieldRef<"UserToParent", 'String'>
    readonly userId: FieldRef<"UserToParent", 'String'>
    readonly parentId: FieldRef<"UserToParent", 'String'>
  }
    

  // Custom InputTypes
  /**
   * UserToParent findUnique
   */
  export type UserToParentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserToParent
     */
    select?: UserToParentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserToParent
     */
    omit?: UserToParentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserToParentInclude<ExtArgs> | null
    /**
     * Filter, which UserToParent to fetch.
     */
    where: UserToParentWhereUniqueInput
  }

  /**
   * UserToParent findUniqueOrThrow
   */
  export type UserToParentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserToParent
     */
    select?: UserToParentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserToParent
     */
    omit?: UserToParentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserToParentInclude<ExtArgs> | null
    /**
     * Filter, which UserToParent to fetch.
     */
    where: UserToParentWhereUniqueInput
  }

  /**
   * UserToParent findFirst
   */
  export type UserToParentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserToParent
     */
    select?: UserToParentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserToParent
     */
    omit?: UserToParentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserToParentInclude<ExtArgs> | null
    /**
     * Filter, which UserToParent to fetch.
     */
    where?: UserToParentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserToParents to fetch.
     */
    orderBy?: UserToParentOrderByWithRelationInput | UserToParentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserToParents.
     */
    cursor?: UserToParentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserToParents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserToParents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserToParents.
     */
    distinct?: UserToParentScalarFieldEnum | UserToParentScalarFieldEnum[]
  }

  /**
   * UserToParent findFirstOrThrow
   */
  export type UserToParentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserToParent
     */
    select?: UserToParentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserToParent
     */
    omit?: UserToParentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserToParentInclude<ExtArgs> | null
    /**
     * Filter, which UserToParent to fetch.
     */
    where?: UserToParentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserToParents to fetch.
     */
    orderBy?: UserToParentOrderByWithRelationInput | UserToParentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserToParents.
     */
    cursor?: UserToParentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserToParents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserToParents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserToParents.
     */
    distinct?: UserToParentScalarFieldEnum | UserToParentScalarFieldEnum[]
  }

  /**
   * UserToParent findMany
   */
  export type UserToParentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserToParent
     */
    select?: UserToParentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserToParent
     */
    omit?: UserToParentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserToParentInclude<ExtArgs> | null
    /**
     * Filter, which UserToParents to fetch.
     */
    where?: UserToParentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserToParents to fetch.
     */
    orderBy?: UserToParentOrderByWithRelationInput | UserToParentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserToParents.
     */
    cursor?: UserToParentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserToParents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserToParents.
     */
    skip?: number
    distinct?: UserToParentScalarFieldEnum | UserToParentScalarFieldEnum[]
  }

  /**
   * UserToParent create
   */
  export type UserToParentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserToParent
     */
    select?: UserToParentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserToParent
     */
    omit?: UserToParentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserToParentInclude<ExtArgs> | null
    /**
     * The data needed to create a UserToParent.
     */
    data: XOR<UserToParentCreateInput, UserToParentUncheckedCreateInput>
  }

  /**
   * UserToParent createMany
   */
  export type UserToParentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserToParents.
     */
    data: UserToParentCreateManyInput | UserToParentCreateManyInput[]
  }

  /**
   * UserToParent update
   */
  export type UserToParentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserToParent
     */
    select?: UserToParentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserToParent
     */
    omit?: UserToParentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserToParentInclude<ExtArgs> | null
    /**
     * The data needed to update a UserToParent.
     */
    data: XOR<UserToParentUpdateInput, UserToParentUncheckedUpdateInput>
    /**
     * Choose, which UserToParent to update.
     */
    where: UserToParentWhereUniqueInput
  }

  /**
   * UserToParent updateMany
   */
  export type UserToParentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserToParents.
     */
    data: XOR<UserToParentUpdateManyMutationInput, UserToParentUncheckedUpdateManyInput>
    /**
     * Filter which UserToParents to update
     */
    where?: UserToParentWhereInput
    /**
     * Limit how many UserToParents to update.
     */
    limit?: number
  }

  /**
   * UserToParent upsert
   */
  export type UserToParentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserToParent
     */
    select?: UserToParentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserToParent
     */
    omit?: UserToParentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserToParentInclude<ExtArgs> | null
    /**
     * The filter to search for the UserToParent to update in case it exists.
     */
    where: UserToParentWhereUniqueInput
    /**
     * In case the UserToParent found by the `where` argument doesn't exist, create a new UserToParent with this data.
     */
    create: XOR<UserToParentCreateInput, UserToParentUncheckedCreateInput>
    /**
     * In case the UserToParent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserToParentUpdateInput, UserToParentUncheckedUpdateInput>
  }

  /**
   * UserToParent delete
   */
  export type UserToParentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserToParent
     */
    select?: UserToParentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserToParent
     */
    omit?: UserToParentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserToParentInclude<ExtArgs> | null
    /**
     * Filter which UserToParent to delete.
     */
    where: UserToParentWhereUniqueInput
  }

  /**
   * UserToParent deleteMany
   */
  export type UserToParentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserToParents to delete
     */
    where?: UserToParentWhereInput
    /**
     * Limit how many UserToParents to delete.
     */
    limit?: number
  }

  /**
   * UserToParent findRaw
   */
  export type UserToParentFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * UserToParent aggregateRaw
   */
  export type UserToParentAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * UserToParent without action
   */
  export type UserToParentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserToParent
     */
    select?: UserToParentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserToParent
     */
    omit?: UserToParentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserToParentInclude<ExtArgs> | null
  }


  /**
   * Model Parent
   */

  export type AggregateParent = {
    _count: ParentCountAggregateOutputType | null
    _min: ParentMinAggregateOutputType | null
    _max: ParentMaxAggregateOutputType | null
  }

  export type ParentMinAggregateOutputType = {
    id: string | null
    studentId: string | null
    institutionId: string | null
    firstName: string | null
    middleName: string | null
    lastName: string | null
    email: string | null
    phone: string | null
    occupation: string | null
    relationship: string | null
    address: string | null
    isPrimaryContact: boolean | null
    isEmergencyContact: boolean | null
    preferredContactTime: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ParentMaxAggregateOutputType = {
    id: string | null
    studentId: string | null
    institutionId: string | null
    firstName: string | null
    middleName: string | null
    lastName: string | null
    email: string | null
    phone: string | null
    occupation: string | null
    relationship: string | null
    address: string | null
    isPrimaryContact: boolean | null
    isEmergencyContact: boolean | null
    preferredContactTime: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ParentCountAggregateOutputType = {
    id: number
    studentId: number
    institutionId: number
    firstName: number
    middleName: number
    lastName: number
    email: number
    phone: number
    occupation: number
    relationship: number
    address: number
    isPrimaryContact: number
    isEmergencyContact: number
    preferredContactTime: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ParentMinAggregateInputType = {
    id?: true
    studentId?: true
    institutionId?: true
    firstName?: true
    middleName?: true
    lastName?: true
    email?: true
    phone?: true
    occupation?: true
    relationship?: true
    address?: true
    isPrimaryContact?: true
    isEmergencyContact?: true
    preferredContactTime?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ParentMaxAggregateInputType = {
    id?: true
    studentId?: true
    institutionId?: true
    firstName?: true
    middleName?: true
    lastName?: true
    email?: true
    phone?: true
    occupation?: true
    relationship?: true
    address?: true
    isPrimaryContact?: true
    isEmergencyContact?: true
    preferredContactTime?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ParentCountAggregateInputType = {
    id?: true
    studentId?: true
    institutionId?: true
    firstName?: true
    middleName?: true
    lastName?: true
    email?: true
    phone?: true
    occupation?: true
    relationship?: true
    address?: true
    isPrimaryContact?: true
    isEmergencyContact?: true
    preferredContactTime?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ParentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Parent to aggregate.
     */
    where?: ParentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Parents to fetch.
     */
    orderBy?: ParentOrderByWithRelationInput | ParentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ParentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Parents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Parents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Parents
    **/
    _count?: true | ParentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ParentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ParentMaxAggregateInputType
  }

  export type GetParentAggregateType<T extends ParentAggregateArgs> = {
        [P in keyof T & keyof AggregateParent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateParent[P]>
      : GetScalarType<T[P], AggregateParent[P]>
  }




  export type ParentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ParentWhereInput
    orderBy?: ParentOrderByWithAggregationInput | ParentOrderByWithAggregationInput[]
    by: ParentScalarFieldEnum[] | ParentScalarFieldEnum
    having?: ParentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ParentCountAggregateInputType | true
    _min?: ParentMinAggregateInputType
    _max?: ParentMaxAggregateInputType
  }

  export type ParentGroupByOutputType = {
    id: string
    studentId: string | null
    institutionId: string
    firstName: string
    middleName: string | null
    lastName: string
    email: string
    phone: string
    occupation: string | null
    relationship: string | null
    address: string | null
    isPrimaryContact: boolean
    isEmergencyContact: boolean
    preferredContactTime: string | null
    createdAt: Date
    updatedAt: Date
    _count: ParentCountAggregateOutputType | null
    _min: ParentMinAggregateOutputType | null
    _max: ParentMaxAggregateOutputType | null
  }

  type GetParentGroupByPayload<T extends ParentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ParentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ParentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ParentGroupByOutputType[P]>
            : GetScalarType<T[P], ParentGroupByOutputType[P]>
        }
      >
    >


  export type ParentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    institutionId?: boolean
    firstName?: boolean
    middleName?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    occupation?: boolean
    relationship?: boolean
    address?: boolean
    isPrimaryContact?: boolean
    isEmergencyContact?: boolean
    preferredContactTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    student?: boolean | Parent$studentArgs<ExtArgs>
    user?: boolean | Parent$userArgs<ExtArgs>
    _count?: boolean | ParentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["parent"]>



  export type ParentSelectScalar = {
    id?: boolean
    studentId?: boolean
    institutionId?: boolean
    firstName?: boolean
    middleName?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    occupation?: boolean
    relationship?: boolean
    address?: boolean
    isPrimaryContact?: boolean
    isEmergencyContact?: boolean
    preferredContactTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ParentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "studentId" | "institutionId" | "firstName" | "middleName" | "lastName" | "email" | "phone" | "occupation" | "relationship" | "address" | "isPrimaryContact" | "isEmergencyContact" | "preferredContactTime" | "createdAt" | "updatedAt", ExtArgs["result"]["parent"]>
  export type ParentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | Parent$studentArgs<ExtArgs>
    user?: boolean | Parent$userArgs<ExtArgs>
    _count?: boolean | ParentCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ParentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Parent"
    objects: {
      student: Prisma.$StudentPayload<ExtArgs> | null
      user: Prisma.$UserToParentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      studentId: string | null
      institutionId: string
      firstName: string
      middleName: string | null
      lastName: string
      email: string
      phone: string
      occupation: string | null
      relationship: string | null
      address: string | null
      isPrimaryContact: boolean
      isEmergencyContact: boolean
      preferredContactTime: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["parent"]>
    composites: {}
  }

  type ParentGetPayload<S extends boolean | null | undefined | ParentDefaultArgs> = $Result.GetResult<Prisma.$ParentPayload, S>

  type ParentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ParentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ParentCountAggregateInputType | true
    }

  export interface ParentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Parent'], meta: { name: 'Parent' } }
    /**
     * Find zero or one Parent that matches the filter.
     * @param {ParentFindUniqueArgs} args - Arguments to find a Parent
     * @example
     * // Get one Parent
     * const parent = await prisma.parent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ParentFindUniqueArgs>(args: SelectSubset<T, ParentFindUniqueArgs<ExtArgs>>): Prisma__ParentClient<$Result.GetResult<Prisma.$ParentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Parent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ParentFindUniqueOrThrowArgs} args - Arguments to find a Parent
     * @example
     * // Get one Parent
     * const parent = await prisma.parent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ParentFindUniqueOrThrowArgs>(args: SelectSubset<T, ParentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ParentClient<$Result.GetResult<Prisma.$ParentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Parent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentFindFirstArgs} args - Arguments to find a Parent
     * @example
     * // Get one Parent
     * const parent = await prisma.parent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ParentFindFirstArgs>(args?: SelectSubset<T, ParentFindFirstArgs<ExtArgs>>): Prisma__ParentClient<$Result.GetResult<Prisma.$ParentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Parent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentFindFirstOrThrowArgs} args - Arguments to find a Parent
     * @example
     * // Get one Parent
     * const parent = await prisma.parent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ParentFindFirstOrThrowArgs>(args?: SelectSubset<T, ParentFindFirstOrThrowArgs<ExtArgs>>): Prisma__ParentClient<$Result.GetResult<Prisma.$ParentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Parents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Parents
     * const parents = await prisma.parent.findMany()
     * 
     * // Get first 10 Parents
     * const parents = await prisma.parent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const parentWithIdOnly = await prisma.parent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ParentFindManyArgs>(args?: SelectSubset<T, ParentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Parent.
     * @param {ParentCreateArgs} args - Arguments to create a Parent.
     * @example
     * // Create one Parent
     * const Parent = await prisma.parent.create({
     *   data: {
     *     // ... data to create a Parent
     *   }
     * })
     * 
     */
    create<T extends ParentCreateArgs>(args: SelectSubset<T, ParentCreateArgs<ExtArgs>>): Prisma__ParentClient<$Result.GetResult<Prisma.$ParentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Parents.
     * @param {ParentCreateManyArgs} args - Arguments to create many Parents.
     * @example
     * // Create many Parents
     * const parent = await prisma.parent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ParentCreateManyArgs>(args?: SelectSubset<T, ParentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Parent.
     * @param {ParentDeleteArgs} args - Arguments to delete one Parent.
     * @example
     * // Delete one Parent
     * const Parent = await prisma.parent.delete({
     *   where: {
     *     // ... filter to delete one Parent
     *   }
     * })
     * 
     */
    delete<T extends ParentDeleteArgs>(args: SelectSubset<T, ParentDeleteArgs<ExtArgs>>): Prisma__ParentClient<$Result.GetResult<Prisma.$ParentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Parent.
     * @param {ParentUpdateArgs} args - Arguments to update one Parent.
     * @example
     * // Update one Parent
     * const parent = await prisma.parent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ParentUpdateArgs>(args: SelectSubset<T, ParentUpdateArgs<ExtArgs>>): Prisma__ParentClient<$Result.GetResult<Prisma.$ParentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Parents.
     * @param {ParentDeleteManyArgs} args - Arguments to filter Parents to delete.
     * @example
     * // Delete a few Parents
     * const { count } = await prisma.parent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ParentDeleteManyArgs>(args?: SelectSubset<T, ParentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Parents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Parents
     * const parent = await prisma.parent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ParentUpdateManyArgs>(args: SelectSubset<T, ParentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Parent.
     * @param {ParentUpsertArgs} args - Arguments to update or create a Parent.
     * @example
     * // Update or create a Parent
     * const parent = await prisma.parent.upsert({
     *   create: {
     *     // ... data to create a Parent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Parent we want to update
     *   }
     * })
     */
    upsert<T extends ParentUpsertArgs>(args: SelectSubset<T, ParentUpsertArgs<ExtArgs>>): Prisma__ParentClient<$Result.GetResult<Prisma.$ParentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Parents that matches the filter.
     * @param {ParentFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const parent = await prisma.parent.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: ParentFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Parent.
     * @param {ParentAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const parent = await prisma.parent.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: ParentAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Parents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentCountArgs} args - Arguments to filter Parents to count.
     * @example
     * // Count the number of Parents
     * const count = await prisma.parent.count({
     *   where: {
     *     // ... the filter for the Parents we want to count
     *   }
     * })
    **/
    count<T extends ParentCountArgs>(
      args?: Subset<T, ParentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ParentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Parent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ParentAggregateArgs>(args: Subset<T, ParentAggregateArgs>): Prisma.PrismaPromise<GetParentAggregateType<T>>

    /**
     * Group by Parent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ParentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ParentGroupByArgs['orderBy'] }
        : { orderBy?: ParentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ParentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetParentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Parent model
   */
  readonly fields: ParentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Parent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ParentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends Parent$studentArgs<ExtArgs> = {}>(args?: Subset<T, Parent$studentArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    user<T extends Parent$userArgs<ExtArgs> = {}>(args?: Subset<T, Parent$userArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserToParentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Parent model
   */
  interface ParentFieldRefs {
    readonly id: FieldRef<"Parent", 'String'>
    readonly studentId: FieldRef<"Parent", 'String'>
    readonly institutionId: FieldRef<"Parent", 'String'>
    readonly firstName: FieldRef<"Parent", 'String'>
    readonly middleName: FieldRef<"Parent", 'String'>
    readonly lastName: FieldRef<"Parent", 'String'>
    readonly email: FieldRef<"Parent", 'String'>
    readonly phone: FieldRef<"Parent", 'String'>
    readonly occupation: FieldRef<"Parent", 'String'>
    readonly relationship: FieldRef<"Parent", 'String'>
    readonly address: FieldRef<"Parent", 'String'>
    readonly isPrimaryContact: FieldRef<"Parent", 'Boolean'>
    readonly isEmergencyContact: FieldRef<"Parent", 'Boolean'>
    readonly preferredContactTime: FieldRef<"Parent", 'String'>
    readonly createdAt: FieldRef<"Parent", 'DateTime'>
    readonly updatedAt: FieldRef<"Parent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Parent findUnique
   */
  export type ParentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parent
     */
    select?: ParentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parent
     */
    omit?: ParentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentInclude<ExtArgs> | null
    /**
     * Filter, which Parent to fetch.
     */
    where: ParentWhereUniqueInput
  }

  /**
   * Parent findUniqueOrThrow
   */
  export type ParentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parent
     */
    select?: ParentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parent
     */
    omit?: ParentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentInclude<ExtArgs> | null
    /**
     * Filter, which Parent to fetch.
     */
    where: ParentWhereUniqueInput
  }

  /**
   * Parent findFirst
   */
  export type ParentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parent
     */
    select?: ParentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parent
     */
    omit?: ParentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentInclude<ExtArgs> | null
    /**
     * Filter, which Parent to fetch.
     */
    where?: ParentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Parents to fetch.
     */
    orderBy?: ParentOrderByWithRelationInput | ParentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Parents.
     */
    cursor?: ParentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Parents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Parents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Parents.
     */
    distinct?: ParentScalarFieldEnum | ParentScalarFieldEnum[]
  }

  /**
   * Parent findFirstOrThrow
   */
  export type ParentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parent
     */
    select?: ParentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parent
     */
    omit?: ParentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentInclude<ExtArgs> | null
    /**
     * Filter, which Parent to fetch.
     */
    where?: ParentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Parents to fetch.
     */
    orderBy?: ParentOrderByWithRelationInput | ParentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Parents.
     */
    cursor?: ParentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Parents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Parents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Parents.
     */
    distinct?: ParentScalarFieldEnum | ParentScalarFieldEnum[]
  }

  /**
   * Parent findMany
   */
  export type ParentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parent
     */
    select?: ParentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parent
     */
    omit?: ParentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentInclude<ExtArgs> | null
    /**
     * Filter, which Parents to fetch.
     */
    where?: ParentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Parents to fetch.
     */
    orderBy?: ParentOrderByWithRelationInput | ParentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Parents.
     */
    cursor?: ParentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Parents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Parents.
     */
    skip?: number
    distinct?: ParentScalarFieldEnum | ParentScalarFieldEnum[]
  }

  /**
   * Parent create
   */
  export type ParentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parent
     */
    select?: ParentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parent
     */
    omit?: ParentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentInclude<ExtArgs> | null
    /**
     * The data needed to create a Parent.
     */
    data: XOR<ParentCreateInput, ParentUncheckedCreateInput>
  }

  /**
   * Parent createMany
   */
  export type ParentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Parents.
     */
    data: ParentCreateManyInput | ParentCreateManyInput[]
  }

  /**
   * Parent update
   */
  export type ParentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parent
     */
    select?: ParentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parent
     */
    omit?: ParentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentInclude<ExtArgs> | null
    /**
     * The data needed to update a Parent.
     */
    data: XOR<ParentUpdateInput, ParentUncheckedUpdateInput>
    /**
     * Choose, which Parent to update.
     */
    where: ParentWhereUniqueInput
  }

  /**
   * Parent updateMany
   */
  export type ParentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Parents.
     */
    data: XOR<ParentUpdateManyMutationInput, ParentUncheckedUpdateManyInput>
    /**
     * Filter which Parents to update
     */
    where?: ParentWhereInput
    /**
     * Limit how many Parents to update.
     */
    limit?: number
  }

  /**
   * Parent upsert
   */
  export type ParentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parent
     */
    select?: ParentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parent
     */
    omit?: ParentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentInclude<ExtArgs> | null
    /**
     * The filter to search for the Parent to update in case it exists.
     */
    where: ParentWhereUniqueInput
    /**
     * In case the Parent found by the `where` argument doesn't exist, create a new Parent with this data.
     */
    create: XOR<ParentCreateInput, ParentUncheckedCreateInput>
    /**
     * In case the Parent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ParentUpdateInput, ParentUncheckedUpdateInput>
  }

  /**
   * Parent delete
   */
  export type ParentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parent
     */
    select?: ParentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parent
     */
    omit?: ParentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentInclude<ExtArgs> | null
    /**
     * Filter which Parent to delete.
     */
    where: ParentWhereUniqueInput
  }

  /**
   * Parent deleteMany
   */
  export type ParentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Parents to delete
     */
    where?: ParentWhereInput
    /**
     * Limit how many Parents to delete.
     */
    limit?: number
  }

  /**
   * Parent findRaw
   */
  export type ParentFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Parent aggregateRaw
   */
  export type ParentAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Parent.student
   */
  export type Parent$studentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    where?: StudentWhereInput
  }

  /**
   * Parent.user
   */
  export type Parent$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserToParent
     */
    select?: UserToParentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserToParent
     */
    omit?: UserToParentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserToParentInclude<ExtArgs> | null
    where?: UserToParentWhereInput
    orderBy?: UserToParentOrderByWithRelationInput | UserToParentOrderByWithRelationInput[]
    cursor?: UserToParentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserToParentScalarFieldEnum | UserToParentScalarFieldEnum[]
  }

  /**
   * Parent without action
   */
  export type ParentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parent
     */
    select?: ParentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parent
     */
    omit?: ParentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentInclude<ExtArgs> | null
  }


  /**
   * Model StudentDocument
   */

  export type AggregateStudentDocument = {
    _count: StudentDocumentCountAggregateOutputType | null
    _avg: StudentDocumentAvgAggregateOutputType | null
    _sum: StudentDocumentSumAggregateOutputType | null
    _min: StudentDocumentMinAggregateOutputType | null
    _max: StudentDocumentMaxAggregateOutputType | null
  }

  export type StudentDocumentAvgAggregateOutputType = {
    fileSize: number | null
  }

  export type StudentDocumentSumAggregateOutputType = {
    fileSize: number | null
  }

  export type StudentDocumentMinAggregateOutputType = {
    id: string | null
    studentId: string | null
    documentType: string | null
    documentName: string | null
    documentUrl: string | null
    fileSize: number | null
    mimeType: string | null
    uploadedAt: Date | null
    uploadedBy: string | null
    verified: boolean | null
    verifiedBy: string | null
    verifiedAt: Date | null
  }

  export type StudentDocumentMaxAggregateOutputType = {
    id: string | null
    studentId: string | null
    documentType: string | null
    documentName: string | null
    documentUrl: string | null
    fileSize: number | null
    mimeType: string | null
    uploadedAt: Date | null
    uploadedBy: string | null
    verified: boolean | null
    verifiedBy: string | null
    verifiedAt: Date | null
  }

  export type StudentDocumentCountAggregateOutputType = {
    id: number
    studentId: number
    documentType: number
    documentName: number
    documentUrl: number
    fileSize: number
    mimeType: number
    uploadedAt: number
    uploadedBy: number
    verified: number
    verifiedBy: number
    verifiedAt: number
    _all: number
  }


  export type StudentDocumentAvgAggregateInputType = {
    fileSize?: true
  }

  export type StudentDocumentSumAggregateInputType = {
    fileSize?: true
  }

  export type StudentDocumentMinAggregateInputType = {
    id?: true
    studentId?: true
    documentType?: true
    documentName?: true
    documentUrl?: true
    fileSize?: true
    mimeType?: true
    uploadedAt?: true
    uploadedBy?: true
    verified?: true
    verifiedBy?: true
    verifiedAt?: true
  }

  export type StudentDocumentMaxAggregateInputType = {
    id?: true
    studentId?: true
    documentType?: true
    documentName?: true
    documentUrl?: true
    fileSize?: true
    mimeType?: true
    uploadedAt?: true
    uploadedBy?: true
    verified?: true
    verifiedBy?: true
    verifiedAt?: true
  }

  export type StudentDocumentCountAggregateInputType = {
    id?: true
    studentId?: true
    documentType?: true
    documentName?: true
    documentUrl?: true
    fileSize?: true
    mimeType?: true
    uploadedAt?: true
    uploadedBy?: true
    verified?: true
    verifiedBy?: true
    verifiedAt?: true
    _all?: true
  }

  export type StudentDocumentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentDocument to aggregate.
     */
    where?: StudentDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentDocuments to fetch.
     */
    orderBy?: StudentDocumentOrderByWithRelationInput | StudentDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudentDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StudentDocuments
    **/
    _count?: true | StudentDocumentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StudentDocumentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StudentDocumentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentDocumentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentDocumentMaxAggregateInputType
  }

  export type GetStudentDocumentAggregateType<T extends StudentDocumentAggregateArgs> = {
        [P in keyof T & keyof AggregateStudentDocument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudentDocument[P]>
      : GetScalarType<T[P], AggregateStudentDocument[P]>
  }




  export type StudentDocumentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentDocumentWhereInput
    orderBy?: StudentDocumentOrderByWithAggregationInput | StudentDocumentOrderByWithAggregationInput[]
    by: StudentDocumentScalarFieldEnum[] | StudentDocumentScalarFieldEnum
    having?: StudentDocumentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentDocumentCountAggregateInputType | true
    _avg?: StudentDocumentAvgAggregateInputType
    _sum?: StudentDocumentSumAggregateInputType
    _min?: StudentDocumentMinAggregateInputType
    _max?: StudentDocumentMaxAggregateInputType
  }

  export type StudentDocumentGroupByOutputType = {
    id: string
    studentId: string | null
    documentType: string
    documentName: string
    documentUrl: string
    fileSize: number | null
    mimeType: string | null
    uploadedAt: Date
    uploadedBy: string | null
    verified: boolean
    verifiedBy: string | null
    verifiedAt: Date | null
    _count: StudentDocumentCountAggregateOutputType | null
    _avg: StudentDocumentAvgAggregateOutputType | null
    _sum: StudentDocumentSumAggregateOutputType | null
    _min: StudentDocumentMinAggregateOutputType | null
    _max: StudentDocumentMaxAggregateOutputType | null
  }

  type GetStudentDocumentGroupByPayload<T extends StudentDocumentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudentDocumentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentDocumentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentDocumentGroupByOutputType[P]>
            : GetScalarType<T[P], StudentDocumentGroupByOutputType[P]>
        }
      >
    >


  export type StudentDocumentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    documentType?: boolean
    documentName?: boolean
    documentUrl?: boolean
    fileSize?: boolean
    mimeType?: boolean
    uploadedAt?: boolean
    uploadedBy?: boolean
    verified?: boolean
    verifiedBy?: boolean
    verifiedAt?: boolean
    student?: boolean | StudentDocument$studentArgs<ExtArgs>
  }, ExtArgs["result"]["studentDocument"]>



  export type StudentDocumentSelectScalar = {
    id?: boolean
    studentId?: boolean
    documentType?: boolean
    documentName?: boolean
    documentUrl?: boolean
    fileSize?: boolean
    mimeType?: boolean
    uploadedAt?: boolean
    uploadedBy?: boolean
    verified?: boolean
    verifiedBy?: boolean
    verifiedAt?: boolean
  }

  export type StudentDocumentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "studentId" | "documentType" | "documentName" | "documentUrl" | "fileSize" | "mimeType" | "uploadedAt" | "uploadedBy" | "verified" | "verifiedBy" | "verifiedAt", ExtArgs["result"]["studentDocument"]>
  export type StudentDocumentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDocument$studentArgs<ExtArgs>
  }

  export type $StudentDocumentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StudentDocument"
    objects: {
      student: Prisma.$StudentPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      studentId: string | null
      documentType: string
      documentName: string
      documentUrl: string
      fileSize: number | null
      mimeType: string | null
      uploadedAt: Date
      uploadedBy: string | null
      verified: boolean
      verifiedBy: string | null
      verifiedAt: Date | null
    }, ExtArgs["result"]["studentDocument"]>
    composites: {}
  }

  type StudentDocumentGetPayload<S extends boolean | null | undefined | StudentDocumentDefaultArgs> = $Result.GetResult<Prisma.$StudentDocumentPayload, S>

  type StudentDocumentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StudentDocumentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StudentDocumentCountAggregateInputType | true
    }

  export interface StudentDocumentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StudentDocument'], meta: { name: 'StudentDocument' } }
    /**
     * Find zero or one StudentDocument that matches the filter.
     * @param {StudentDocumentFindUniqueArgs} args - Arguments to find a StudentDocument
     * @example
     * // Get one StudentDocument
     * const studentDocument = await prisma.studentDocument.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StudentDocumentFindUniqueArgs>(args: SelectSubset<T, StudentDocumentFindUniqueArgs<ExtArgs>>): Prisma__StudentDocumentClient<$Result.GetResult<Prisma.$StudentDocumentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StudentDocument that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StudentDocumentFindUniqueOrThrowArgs} args - Arguments to find a StudentDocument
     * @example
     * // Get one StudentDocument
     * const studentDocument = await prisma.studentDocument.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StudentDocumentFindUniqueOrThrowArgs>(args: SelectSubset<T, StudentDocumentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StudentDocumentClient<$Result.GetResult<Prisma.$StudentDocumentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StudentDocument that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentDocumentFindFirstArgs} args - Arguments to find a StudentDocument
     * @example
     * // Get one StudentDocument
     * const studentDocument = await prisma.studentDocument.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StudentDocumentFindFirstArgs>(args?: SelectSubset<T, StudentDocumentFindFirstArgs<ExtArgs>>): Prisma__StudentDocumentClient<$Result.GetResult<Prisma.$StudentDocumentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StudentDocument that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentDocumentFindFirstOrThrowArgs} args - Arguments to find a StudentDocument
     * @example
     * // Get one StudentDocument
     * const studentDocument = await prisma.studentDocument.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StudentDocumentFindFirstOrThrowArgs>(args?: SelectSubset<T, StudentDocumentFindFirstOrThrowArgs<ExtArgs>>): Prisma__StudentDocumentClient<$Result.GetResult<Prisma.$StudentDocumentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StudentDocuments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentDocumentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StudentDocuments
     * const studentDocuments = await prisma.studentDocument.findMany()
     * 
     * // Get first 10 StudentDocuments
     * const studentDocuments = await prisma.studentDocument.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const studentDocumentWithIdOnly = await prisma.studentDocument.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StudentDocumentFindManyArgs>(args?: SelectSubset<T, StudentDocumentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentDocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StudentDocument.
     * @param {StudentDocumentCreateArgs} args - Arguments to create a StudentDocument.
     * @example
     * // Create one StudentDocument
     * const StudentDocument = await prisma.studentDocument.create({
     *   data: {
     *     // ... data to create a StudentDocument
     *   }
     * })
     * 
     */
    create<T extends StudentDocumentCreateArgs>(args: SelectSubset<T, StudentDocumentCreateArgs<ExtArgs>>): Prisma__StudentDocumentClient<$Result.GetResult<Prisma.$StudentDocumentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StudentDocuments.
     * @param {StudentDocumentCreateManyArgs} args - Arguments to create many StudentDocuments.
     * @example
     * // Create many StudentDocuments
     * const studentDocument = await prisma.studentDocument.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StudentDocumentCreateManyArgs>(args?: SelectSubset<T, StudentDocumentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a StudentDocument.
     * @param {StudentDocumentDeleteArgs} args - Arguments to delete one StudentDocument.
     * @example
     * // Delete one StudentDocument
     * const StudentDocument = await prisma.studentDocument.delete({
     *   where: {
     *     // ... filter to delete one StudentDocument
     *   }
     * })
     * 
     */
    delete<T extends StudentDocumentDeleteArgs>(args: SelectSubset<T, StudentDocumentDeleteArgs<ExtArgs>>): Prisma__StudentDocumentClient<$Result.GetResult<Prisma.$StudentDocumentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StudentDocument.
     * @param {StudentDocumentUpdateArgs} args - Arguments to update one StudentDocument.
     * @example
     * // Update one StudentDocument
     * const studentDocument = await prisma.studentDocument.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StudentDocumentUpdateArgs>(args: SelectSubset<T, StudentDocumentUpdateArgs<ExtArgs>>): Prisma__StudentDocumentClient<$Result.GetResult<Prisma.$StudentDocumentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StudentDocuments.
     * @param {StudentDocumentDeleteManyArgs} args - Arguments to filter StudentDocuments to delete.
     * @example
     * // Delete a few StudentDocuments
     * const { count } = await prisma.studentDocument.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StudentDocumentDeleteManyArgs>(args?: SelectSubset<T, StudentDocumentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudentDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentDocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StudentDocuments
     * const studentDocument = await prisma.studentDocument.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StudentDocumentUpdateManyArgs>(args: SelectSubset<T, StudentDocumentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StudentDocument.
     * @param {StudentDocumentUpsertArgs} args - Arguments to update or create a StudentDocument.
     * @example
     * // Update or create a StudentDocument
     * const studentDocument = await prisma.studentDocument.upsert({
     *   create: {
     *     // ... data to create a StudentDocument
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StudentDocument we want to update
     *   }
     * })
     */
    upsert<T extends StudentDocumentUpsertArgs>(args: SelectSubset<T, StudentDocumentUpsertArgs<ExtArgs>>): Prisma__StudentDocumentClient<$Result.GetResult<Prisma.$StudentDocumentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StudentDocuments that matches the filter.
     * @param {StudentDocumentFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const studentDocument = await prisma.studentDocument.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: StudentDocumentFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a StudentDocument.
     * @param {StudentDocumentAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const studentDocument = await prisma.studentDocument.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: StudentDocumentAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of StudentDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentDocumentCountArgs} args - Arguments to filter StudentDocuments to count.
     * @example
     * // Count the number of StudentDocuments
     * const count = await prisma.studentDocument.count({
     *   where: {
     *     // ... the filter for the StudentDocuments we want to count
     *   }
     * })
    **/
    count<T extends StudentDocumentCountArgs>(
      args?: Subset<T, StudentDocumentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentDocumentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StudentDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentDocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentDocumentAggregateArgs>(args: Subset<T, StudentDocumentAggregateArgs>): Prisma.PrismaPromise<GetStudentDocumentAggregateType<T>>

    /**
     * Group by StudentDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentDocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudentDocumentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudentDocumentGroupByArgs['orderBy'] }
        : { orderBy?: StudentDocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudentDocumentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentDocumentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StudentDocument model
   */
  readonly fields: StudentDocumentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StudentDocument.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StudentDocumentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends StudentDocument$studentArgs<ExtArgs> = {}>(args?: Subset<T, StudentDocument$studentArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StudentDocument model
   */
  interface StudentDocumentFieldRefs {
    readonly id: FieldRef<"StudentDocument", 'String'>
    readonly studentId: FieldRef<"StudentDocument", 'String'>
    readonly documentType: FieldRef<"StudentDocument", 'String'>
    readonly documentName: FieldRef<"StudentDocument", 'String'>
    readonly documentUrl: FieldRef<"StudentDocument", 'String'>
    readonly fileSize: FieldRef<"StudentDocument", 'Int'>
    readonly mimeType: FieldRef<"StudentDocument", 'String'>
    readonly uploadedAt: FieldRef<"StudentDocument", 'DateTime'>
    readonly uploadedBy: FieldRef<"StudentDocument", 'String'>
    readonly verified: FieldRef<"StudentDocument", 'Boolean'>
    readonly verifiedBy: FieldRef<"StudentDocument", 'String'>
    readonly verifiedAt: FieldRef<"StudentDocument", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StudentDocument findUnique
   */
  export type StudentDocumentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentDocument
     */
    select?: StudentDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentDocument
     */
    omit?: StudentDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentDocumentInclude<ExtArgs> | null
    /**
     * Filter, which StudentDocument to fetch.
     */
    where: StudentDocumentWhereUniqueInput
  }

  /**
   * StudentDocument findUniqueOrThrow
   */
  export type StudentDocumentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentDocument
     */
    select?: StudentDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentDocument
     */
    omit?: StudentDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentDocumentInclude<ExtArgs> | null
    /**
     * Filter, which StudentDocument to fetch.
     */
    where: StudentDocumentWhereUniqueInput
  }

  /**
   * StudentDocument findFirst
   */
  export type StudentDocumentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentDocument
     */
    select?: StudentDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentDocument
     */
    omit?: StudentDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentDocumentInclude<ExtArgs> | null
    /**
     * Filter, which StudentDocument to fetch.
     */
    where?: StudentDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentDocuments to fetch.
     */
    orderBy?: StudentDocumentOrderByWithRelationInput | StudentDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentDocuments.
     */
    cursor?: StudentDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentDocuments.
     */
    distinct?: StudentDocumentScalarFieldEnum | StudentDocumentScalarFieldEnum[]
  }

  /**
   * StudentDocument findFirstOrThrow
   */
  export type StudentDocumentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentDocument
     */
    select?: StudentDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentDocument
     */
    omit?: StudentDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentDocumentInclude<ExtArgs> | null
    /**
     * Filter, which StudentDocument to fetch.
     */
    where?: StudentDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentDocuments to fetch.
     */
    orderBy?: StudentDocumentOrderByWithRelationInput | StudentDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentDocuments.
     */
    cursor?: StudentDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentDocuments.
     */
    distinct?: StudentDocumentScalarFieldEnum | StudentDocumentScalarFieldEnum[]
  }

  /**
   * StudentDocument findMany
   */
  export type StudentDocumentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentDocument
     */
    select?: StudentDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentDocument
     */
    omit?: StudentDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentDocumentInclude<ExtArgs> | null
    /**
     * Filter, which StudentDocuments to fetch.
     */
    where?: StudentDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentDocuments to fetch.
     */
    orderBy?: StudentDocumentOrderByWithRelationInput | StudentDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StudentDocuments.
     */
    cursor?: StudentDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentDocuments.
     */
    skip?: number
    distinct?: StudentDocumentScalarFieldEnum | StudentDocumentScalarFieldEnum[]
  }

  /**
   * StudentDocument create
   */
  export type StudentDocumentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentDocument
     */
    select?: StudentDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentDocument
     */
    omit?: StudentDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentDocumentInclude<ExtArgs> | null
    /**
     * The data needed to create a StudentDocument.
     */
    data: XOR<StudentDocumentCreateInput, StudentDocumentUncheckedCreateInput>
  }

  /**
   * StudentDocument createMany
   */
  export type StudentDocumentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StudentDocuments.
     */
    data: StudentDocumentCreateManyInput | StudentDocumentCreateManyInput[]
  }

  /**
   * StudentDocument update
   */
  export type StudentDocumentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentDocument
     */
    select?: StudentDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentDocument
     */
    omit?: StudentDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentDocumentInclude<ExtArgs> | null
    /**
     * The data needed to update a StudentDocument.
     */
    data: XOR<StudentDocumentUpdateInput, StudentDocumentUncheckedUpdateInput>
    /**
     * Choose, which StudentDocument to update.
     */
    where: StudentDocumentWhereUniqueInput
  }

  /**
   * StudentDocument updateMany
   */
  export type StudentDocumentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StudentDocuments.
     */
    data: XOR<StudentDocumentUpdateManyMutationInput, StudentDocumentUncheckedUpdateManyInput>
    /**
     * Filter which StudentDocuments to update
     */
    where?: StudentDocumentWhereInput
    /**
     * Limit how many StudentDocuments to update.
     */
    limit?: number
  }

  /**
   * StudentDocument upsert
   */
  export type StudentDocumentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentDocument
     */
    select?: StudentDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentDocument
     */
    omit?: StudentDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentDocumentInclude<ExtArgs> | null
    /**
     * The filter to search for the StudentDocument to update in case it exists.
     */
    where: StudentDocumentWhereUniqueInput
    /**
     * In case the StudentDocument found by the `where` argument doesn't exist, create a new StudentDocument with this data.
     */
    create: XOR<StudentDocumentCreateInput, StudentDocumentUncheckedCreateInput>
    /**
     * In case the StudentDocument was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudentDocumentUpdateInput, StudentDocumentUncheckedUpdateInput>
  }

  /**
   * StudentDocument delete
   */
  export type StudentDocumentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentDocument
     */
    select?: StudentDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentDocument
     */
    omit?: StudentDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentDocumentInclude<ExtArgs> | null
    /**
     * Filter which StudentDocument to delete.
     */
    where: StudentDocumentWhereUniqueInput
  }

  /**
   * StudentDocument deleteMany
   */
  export type StudentDocumentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentDocuments to delete
     */
    where?: StudentDocumentWhereInput
    /**
     * Limit how many StudentDocuments to delete.
     */
    limit?: number
  }

  /**
   * StudentDocument findRaw
   */
  export type StudentDocumentFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * StudentDocument aggregateRaw
   */
  export type StudentDocumentAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * StudentDocument.student
   */
  export type StudentDocument$studentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    where?: StudentWhereInput
  }

  /**
   * StudentDocument without action
   */
  export type StudentDocumentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentDocument
     */
    select?: StudentDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentDocument
     */
    omit?: StudentDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentDocumentInclude<ExtArgs> | null
  }


  /**
   * Model TeacherOnInstitution
   */

  export type AggregateTeacherOnInstitution = {
    _count: TeacherOnInstitutionCountAggregateOutputType | null
    _min: TeacherOnInstitutionMinAggregateOutputType | null
    _max: TeacherOnInstitutionMaxAggregateOutputType | null
  }

  export type TeacherOnInstitutionMinAggregateOutputType = {
    id: string | null
    teacherId: string | null
    institutionId: string | null
  }

  export type TeacherOnInstitutionMaxAggregateOutputType = {
    id: string | null
    teacherId: string | null
    institutionId: string | null
  }

  export type TeacherOnInstitutionCountAggregateOutputType = {
    id: number
    teacherId: number
    institutionId: number
    _all: number
  }


  export type TeacherOnInstitutionMinAggregateInputType = {
    id?: true
    teacherId?: true
    institutionId?: true
  }

  export type TeacherOnInstitutionMaxAggregateInputType = {
    id?: true
    teacherId?: true
    institutionId?: true
  }

  export type TeacherOnInstitutionCountAggregateInputType = {
    id?: true
    teacherId?: true
    institutionId?: true
    _all?: true
  }

  export type TeacherOnInstitutionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TeacherOnInstitution to aggregate.
     */
    where?: TeacherOnInstitutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeacherOnInstitutions to fetch.
     */
    orderBy?: TeacherOnInstitutionOrderByWithRelationInput | TeacherOnInstitutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TeacherOnInstitutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeacherOnInstitutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeacherOnInstitutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TeacherOnInstitutions
    **/
    _count?: true | TeacherOnInstitutionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeacherOnInstitutionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeacherOnInstitutionMaxAggregateInputType
  }

  export type GetTeacherOnInstitutionAggregateType<T extends TeacherOnInstitutionAggregateArgs> = {
        [P in keyof T & keyof AggregateTeacherOnInstitution]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeacherOnInstitution[P]>
      : GetScalarType<T[P], AggregateTeacherOnInstitution[P]>
  }




  export type TeacherOnInstitutionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeacherOnInstitutionWhereInput
    orderBy?: TeacherOnInstitutionOrderByWithAggregationInput | TeacherOnInstitutionOrderByWithAggregationInput[]
    by: TeacherOnInstitutionScalarFieldEnum[] | TeacherOnInstitutionScalarFieldEnum
    having?: TeacherOnInstitutionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeacherOnInstitutionCountAggregateInputType | true
    _min?: TeacherOnInstitutionMinAggregateInputType
    _max?: TeacherOnInstitutionMaxAggregateInputType
  }

  export type TeacherOnInstitutionGroupByOutputType = {
    id: string
    teacherId: string
    institutionId: string
    _count: TeacherOnInstitutionCountAggregateOutputType | null
    _min: TeacherOnInstitutionMinAggregateOutputType | null
    _max: TeacherOnInstitutionMaxAggregateOutputType | null
  }

  type GetTeacherOnInstitutionGroupByPayload<T extends TeacherOnInstitutionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TeacherOnInstitutionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeacherOnInstitutionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeacherOnInstitutionGroupByOutputType[P]>
            : GetScalarType<T[P], TeacherOnInstitutionGroupByOutputType[P]>
        }
      >
    >


  export type TeacherOnInstitutionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teacherId?: boolean
    institutionId?: boolean
    teacher?: boolean | TeacherDefaultArgs<ExtArgs>
    institution?: boolean | InstitutionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teacherOnInstitution"]>



  export type TeacherOnInstitutionSelectScalar = {
    id?: boolean
    teacherId?: boolean
    institutionId?: boolean
  }

  export type TeacherOnInstitutionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "teacherId" | "institutionId", ExtArgs["result"]["teacherOnInstitution"]>
  export type TeacherOnInstitutionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    teacher?: boolean | TeacherDefaultArgs<ExtArgs>
    institution?: boolean | InstitutionDefaultArgs<ExtArgs>
  }

  export type $TeacherOnInstitutionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TeacherOnInstitution"
    objects: {
      teacher: Prisma.$TeacherPayload<ExtArgs>
      institution: Prisma.$InstitutionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      teacherId: string
      institutionId: string
    }, ExtArgs["result"]["teacherOnInstitution"]>
    composites: {}
  }

  type TeacherOnInstitutionGetPayload<S extends boolean | null | undefined | TeacherOnInstitutionDefaultArgs> = $Result.GetResult<Prisma.$TeacherOnInstitutionPayload, S>

  type TeacherOnInstitutionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TeacherOnInstitutionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TeacherOnInstitutionCountAggregateInputType | true
    }

  export interface TeacherOnInstitutionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TeacherOnInstitution'], meta: { name: 'TeacherOnInstitution' } }
    /**
     * Find zero or one TeacherOnInstitution that matches the filter.
     * @param {TeacherOnInstitutionFindUniqueArgs} args - Arguments to find a TeacherOnInstitution
     * @example
     * // Get one TeacherOnInstitution
     * const teacherOnInstitution = await prisma.teacherOnInstitution.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TeacherOnInstitutionFindUniqueArgs>(args: SelectSubset<T, TeacherOnInstitutionFindUniqueArgs<ExtArgs>>): Prisma__TeacherOnInstitutionClient<$Result.GetResult<Prisma.$TeacherOnInstitutionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TeacherOnInstitution that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TeacherOnInstitutionFindUniqueOrThrowArgs} args - Arguments to find a TeacherOnInstitution
     * @example
     * // Get one TeacherOnInstitution
     * const teacherOnInstitution = await prisma.teacherOnInstitution.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TeacherOnInstitutionFindUniqueOrThrowArgs>(args: SelectSubset<T, TeacherOnInstitutionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TeacherOnInstitutionClient<$Result.GetResult<Prisma.$TeacherOnInstitutionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TeacherOnInstitution that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherOnInstitutionFindFirstArgs} args - Arguments to find a TeacherOnInstitution
     * @example
     * // Get one TeacherOnInstitution
     * const teacherOnInstitution = await prisma.teacherOnInstitution.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TeacherOnInstitutionFindFirstArgs>(args?: SelectSubset<T, TeacherOnInstitutionFindFirstArgs<ExtArgs>>): Prisma__TeacherOnInstitutionClient<$Result.GetResult<Prisma.$TeacherOnInstitutionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TeacherOnInstitution that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherOnInstitutionFindFirstOrThrowArgs} args - Arguments to find a TeacherOnInstitution
     * @example
     * // Get one TeacherOnInstitution
     * const teacherOnInstitution = await prisma.teacherOnInstitution.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TeacherOnInstitutionFindFirstOrThrowArgs>(args?: SelectSubset<T, TeacherOnInstitutionFindFirstOrThrowArgs<ExtArgs>>): Prisma__TeacherOnInstitutionClient<$Result.GetResult<Prisma.$TeacherOnInstitutionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TeacherOnInstitutions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherOnInstitutionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TeacherOnInstitutions
     * const teacherOnInstitutions = await prisma.teacherOnInstitution.findMany()
     * 
     * // Get first 10 TeacherOnInstitutions
     * const teacherOnInstitutions = await prisma.teacherOnInstitution.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const teacherOnInstitutionWithIdOnly = await prisma.teacherOnInstitution.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TeacherOnInstitutionFindManyArgs>(args?: SelectSubset<T, TeacherOnInstitutionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeacherOnInstitutionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TeacherOnInstitution.
     * @param {TeacherOnInstitutionCreateArgs} args - Arguments to create a TeacherOnInstitution.
     * @example
     * // Create one TeacherOnInstitution
     * const TeacherOnInstitution = await prisma.teacherOnInstitution.create({
     *   data: {
     *     // ... data to create a TeacherOnInstitution
     *   }
     * })
     * 
     */
    create<T extends TeacherOnInstitutionCreateArgs>(args: SelectSubset<T, TeacherOnInstitutionCreateArgs<ExtArgs>>): Prisma__TeacherOnInstitutionClient<$Result.GetResult<Prisma.$TeacherOnInstitutionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TeacherOnInstitutions.
     * @param {TeacherOnInstitutionCreateManyArgs} args - Arguments to create many TeacherOnInstitutions.
     * @example
     * // Create many TeacherOnInstitutions
     * const teacherOnInstitution = await prisma.teacherOnInstitution.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TeacherOnInstitutionCreateManyArgs>(args?: SelectSubset<T, TeacherOnInstitutionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TeacherOnInstitution.
     * @param {TeacherOnInstitutionDeleteArgs} args - Arguments to delete one TeacherOnInstitution.
     * @example
     * // Delete one TeacherOnInstitution
     * const TeacherOnInstitution = await prisma.teacherOnInstitution.delete({
     *   where: {
     *     // ... filter to delete one TeacherOnInstitution
     *   }
     * })
     * 
     */
    delete<T extends TeacherOnInstitutionDeleteArgs>(args: SelectSubset<T, TeacherOnInstitutionDeleteArgs<ExtArgs>>): Prisma__TeacherOnInstitutionClient<$Result.GetResult<Prisma.$TeacherOnInstitutionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TeacherOnInstitution.
     * @param {TeacherOnInstitutionUpdateArgs} args - Arguments to update one TeacherOnInstitution.
     * @example
     * // Update one TeacherOnInstitution
     * const teacherOnInstitution = await prisma.teacherOnInstitution.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TeacherOnInstitutionUpdateArgs>(args: SelectSubset<T, TeacherOnInstitutionUpdateArgs<ExtArgs>>): Prisma__TeacherOnInstitutionClient<$Result.GetResult<Prisma.$TeacherOnInstitutionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TeacherOnInstitutions.
     * @param {TeacherOnInstitutionDeleteManyArgs} args - Arguments to filter TeacherOnInstitutions to delete.
     * @example
     * // Delete a few TeacherOnInstitutions
     * const { count } = await prisma.teacherOnInstitution.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TeacherOnInstitutionDeleteManyArgs>(args?: SelectSubset<T, TeacherOnInstitutionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TeacherOnInstitutions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherOnInstitutionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TeacherOnInstitutions
     * const teacherOnInstitution = await prisma.teacherOnInstitution.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TeacherOnInstitutionUpdateManyArgs>(args: SelectSubset<T, TeacherOnInstitutionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TeacherOnInstitution.
     * @param {TeacherOnInstitutionUpsertArgs} args - Arguments to update or create a TeacherOnInstitution.
     * @example
     * // Update or create a TeacherOnInstitution
     * const teacherOnInstitution = await prisma.teacherOnInstitution.upsert({
     *   create: {
     *     // ... data to create a TeacherOnInstitution
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TeacherOnInstitution we want to update
     *   }
     * })
     */
    upsert<T extends TeacherOnInstitutionUpsertArgs>(args: SelectSubset<T, TeacherOnInstitutionUpsertArgs<ExtArgs>>): Prisma__TeacherOnInstitutionClient<$Result.GetResult<Prisma.$TeacherOnInstitutionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TeacherOnInstitutions that matches the filter.
     * @param {TeacherOnInstitutionFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const teacherOnInstitution = await prisma.teacherOnInstitution.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: TeacherOnInstitutionFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a TeacherOnInstitution.
     * @param {TeacherOnInstitutionAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const teacherOnInstitution = await prisma.teacherOnInstitution.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: TeacherOnInstitutionAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of TeacherOnInstitutions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherOnInstitutionCountArgs} args - Arguments to filter TeacherOnInstitutions to count.
     * @example
     * // Count the number of TeacherOnInstitutions
     * const count = await prisma.teacherOnInstitution.count({
     *   where: {
     *     // ... the filter for the TeacherOnInstitutions we want to count
     *   }
     * })
    **/
    count<T extends TeacherOnInstitutionCountArgs>(
      args?: Subset<T, TeacherOnInstitutionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeacherOnInstitutionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TeacherOnInstitution.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherOnInstitutionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeacherOnInstitutionAggregateArgs>(args: Subset<T, TeacherOnInstitutionAggregateArgs>): Prisma.PrismaPromise<GetTeacherOnInstitutionAggregateType<T>>

    /**
     * Group by TeacherOnInstitution.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherOnInstitutionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TeacherOnInstitutionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeacherOnInstitutionGroupByArgs['orderBy'] }
        : { orderBy?: TeacherOnInstitutionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TeacherOnInstitutionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeacherOnInstitutionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TeacherOnInstitution model
   */
  readonly fields: TeacherOnInstitutionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TeacherOnInstitution.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TeacherOnInstitutionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    teacher<T extends TeacherDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeacherDefaultArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    institution<T extends InstitutionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InstitutionDefaultArgs<ExtArgs>>): Prisma__InstitutionClient<$Result.GetResult<Prisma.$InstitutionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TeacherOnInstitution model
   */
  interface TeacherOnInstitutionFieldRefs {
    readonly id: FieldRef<"TeacherOnInstitution", 'String'>
    readonly teacherId: FieldRef<"TeacherOnInstitution", 'String'>
    readonly institutionId: FieldRef<"TeacherOnInstitution", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TeacherOnInstitution findUnique
   */
  export type TeacherOnInstitutionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherOnInstitution
     */
    select?: TeacherOnInstitutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeacherOnInstitution
     */
    omit?: TeacherOnInstitutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherOnInstitutionInclude<ExtArgs> | null
    /**
     * Filter, which TeacherOnInstitution to fetch.
     */
    where: TeacherOnInstitutionWhereUniqueInput
  }

  /**
   * TeacherOnInstitution findUniqueOrThrow
   */
  export type TeacherOnInstitutionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherOnInstitution
     */
    select?: TeacherOnInstitutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeacherOnInstitution
     */
    omit?: TeacherOnInstitutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherOnInstitutionInclude<ExtArgs> | null
    /**
     * Filter, which TeacherOnInstitution to fetch.
     */
    where: TeacherOnInstitutionWhereUniqueInput
  }

  /**
   * TeacherOnInstitution findFirst
   */
  export type TeacherOnInstitutionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherOnInstitution
     */
    select?: TeacherOnInstitutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeacherOnInstitution
     */
    omit?: TeacherOnInstitutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherOnInstitutionInclude<ExtArgs> | null
    /**
     * Filter, which TeacherOnInstitution to fetch.
     */
    where?: TeacherOnInstitutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeacherOnInstitutions to fetch.
     */
    orderBy?: TeacherOnInstitutionOrderByWithRelationInput | TeacherOnInstitutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeacherOnInstitutions.
     */
    cursor?: TeacherOnInstitutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeacherOnInstitutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeacherOnInstitutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeacherOnInstitutions.
     */
    distinct?: TeacherOnInstitutionScalarFieldEnum | TeacherOnInstitutionScalarFieldEnum[]
  }

  /**
   * TeacherOnInstitution findFirstOrThrow
   */
  export type TeacherOnInstitutionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherOnInstitution
     */
    select?: TeacherOnInstitutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeacherOnInstitution
     */
    omit?: TeacherOnInstitutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherOnInstitutionInclude<ExtArgs> | null
    /**
     * Filter, which TeacherOnInstitution to fetch.
     */
    where?: TeacherOnInstitutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeacherOnInstitutions to fetch.
     */
    orderBy?: TeacherOnInstitutionOrderByWithRelationInput | TeacherOnInstitutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeacherOnInstitutions.
     */
    cursor?: TeacherOnInstitutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeacherOnInstitutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeacherOnInstitutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeacherOnInstitutions.
     */
    distinct?: TeacherOnInstitutionScalarFieldEnum | TeacherOnInstitutionScalarFieldEnum[]
  }

  /**
   * TeacherOnInstitution findMany
   */
  export type TeacherOnInstitutionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherOnInstitution
     */
    select?: TeacherOnInstitutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeacherOnInstitution
     */
    omit?: TeacherOnInstitutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherOnInstitutionInclude<ExtArgs> | null
    /**
     * Filter, which TeacherOnInstitutions to fetch.
     */
    where?: TeacherOnInstitutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeacherOnInstitutions to fetch.
     */
    orderBy?: TeacherOnInstitutionOrderByWithRelationInput | TeacherOnInstitutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TeacherOnInstitutions.
     */
    cursor?: TeacherOnInstitutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeacherOnInstitutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeacherOnInstitutions.
     */
    skip?: number
    distinct?: TeacherOnInstitutionScalarFieldEnum | TeacherOnInstitutionScalarFieldEnum[]
  }

  /**
   * TeacherOnInstitution create
   */
  export type TeacherOnInstitutionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherOnInstitution
     */
    select?: TeacherOnInstitutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeacherOnInstitution
     */
    omit?: TeacherOnInstitutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherOnInstitutionInclude<ExtArgs> | null
    /**
     * The data needed to create a TeacherOnInstitution.
     */
    data: XOR<TeacherOnInstitutionCreateInput, TeacherOnInstitutionUncheckedCreateInput>
  }

  /**
   * TeacherOnInstitution createMany
   */
  export type TeacherOnInstitutionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TeacherOnInstitutions.
     */
    data: TeacherOnInstitutionCreateManyInput | TeacherOnInstitutionCreateManyInput[]
  }

  /**
   * TeacherOnInstitution update
   */
  export type TeacherOnInstitutionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherOnInstitution
     */
    select?: TeacherOnInstitutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeacherOnInstitution
     */
    omit?: TeacherOnInstitutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherOnInstitutionInclude<ExtArgs> | null
    /**
     * The data needed to update a TeacherOnInstitution.
     */
    data: XOR<TeacherOnInstitutionUpdateInput, TeacherOnInstitutionUncheckedUpdateInput>
    /**
     * Choose, which TeacherOnInstitution to update.
     */
    where: TeacherOnInstitutionWhereUniqueInput
  }

  /**
   * TeacherOnInstitution updateMany
   */
  export type TeacherOnInstitutionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TeacherOnInstitutions.
     */
    data: XOR<TeacherOnInstitutionUpdateManyMutationInput, TeacherOnInstitutionUncheckedUpdateManyInput>
    /**
     * Filter which TeacherOnInstitutions to update
     */
    where?: TeacherOnInstitutionWhereInput
    /**
     * Limit how many TeacherOnInstitutions to update.
     */
    limit?: number
  }

  /**
   * TeacherOnInstitution upsert
   */
  export type TeacherOnInstitutionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherOnInstitution
     */
    select?: TeacherOnInstitutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeacherOnInstitution
     */
    omit?: TeacherOnInstitutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherOnInstitutionInclude<ExtArgs> | null
    /**
     * The filter to search for the TeacherOnInstitution to update in case it exists.
     */
    where: TeacherOnInstitutionWhereUniqueInput
    /**
     * In case the TeacherOnInstitution found by the `where` argument doesn't exist, create a new TeacherOnInstitution with this data.
     */
    create: XOR<TeacherOnInstitutionCreateInput, TeacherOnInstitutionUncheckedCreateInput>
    /**
     * In case the TeacherOnInstitution was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TeacherOnInstitutionUpdateInput, TeacherOnInstitutionUncheckedUpdateInput>
  }

  /**
   * TeacherOnInstitution delete
   */
  export type TeacherOnInstitutionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherOnInstitution
     */
    select?: TeacherOnInstitutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeacherOnInstitution
     */
    omit?: TeacherOnInstitutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherOnInstitutionInclude<ExtArgs> | null
    /**
     * Filter which TeacherOnInstitution to delete.
     */
    where: TeacherOnInstitutionWhereUniqueInput
  }

  /**
   * TeacherOnInstitution deleteMany
   */
  export type TeacherOnInstitutionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TeacherOnInstitutions to delete
     */
    where?: TeacherOnInstitutionWhereInput
    /**
     * Limit how many TeacherOnInstitutions to delete.
     */
    limit?: number
  }

  /**
   * TeacherOnInstitution findRaw
   */
  export type TeacherOnInstitutionFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * TeacherOnInstitution aggregateRaw
   */
  export type TeacherOnInstitutionAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * TeacherOnInstitution without action
   */
  export type TeacherOnInstitutionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherOnInstitution
     */
    select?: TeacherOnInstitutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeacherOnInstitution
     */
    omit?: TeacherOnInstitutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherOnInstitutionInclude<ExtArgs> | null
  }


  /**
   * Model Teacher
   */

  export type AggregateTeacher = {
    _count: TeacherCountAggregateOutputType | null
    _avg: TeacherAvgAggregateOutputType | null
    _sum: TeacherSumAggregateOutputType | null
    _min: TeacherMinAggregateOutputType | null
    _max: TeacherMaxAggregateOutputType | null
  }

  export type TeacherAvgAggregateOutputType = {
    experience: number | null
    salary: number | null
  }

  export type TeacherSumAggregateOutputType = {
    experience: number | null
    salary: number | null
  }

  export type TeacherMinAggregateOutputType = {
    id: string | null
    userId: string | null
    firstName: string | null
    middleName: string | null
    lastName: string | null
    email: string | null
    phone: string | null
    avatar: string | null
    employeeNumber: string | null
    qualification: string | null
    experience: number | null
    salary: number | null
    joinDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TeacherMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    firstName: string | null
    middleName: string | null
    lastName: string | null
    email: string | null
    phone: string | null
    avatar: string | null
    employeeNumber: string | null
    qualification: string | null
    experience: number | null
    salary: number | null
    joinDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TeacherCountAggregateOutputType = {
    id: number
    userId: number
    firstName: number
    middleName: number
    lastName: number
    email: number
    phone: number
    avatar: number
    employeeNumber: number
    subjects: number
    qualification: number
    experience: number
    salary: number
    joinDate: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TeacherAvgAggregateInputType = {
    experience?: true
    salary?: true
  }

  export type TeacherSumAggregateInputType = {
    experience?: true
    salary?: true
  }

  export type TeacherMinAggregateInputType = {
    id?: true
    userId?: true
    firstName?: true
    middleName?: true
    lastName?: true
    email?: true
    phone?: true
    avatar?: true
    employeeNumber?: true
    qualification?: true
    experience?: true
    salary?: true
    joinDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TeacherMaxAggregateInputType = {
    id?: true
    userId?: true
    firstName?: true
    middleName?: true
    lastName?: true
    email?: true
    phone?: true
    avatar?: true
    employeeNumber?: true
    qualification?: true
    experience?: true
    salary?: true
    joinDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TeacherCountAggregateInputType = {
    id?: true
    userId?: true
    firstName?: true
    middleName?: true
    lastName?: true
    email?: true
    phone?: true
    avatar?: true
    employeeNumber?: true
    subjects?: true
    qualification?: true
    experience?: true
    salary?: true
    joinDate?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TeacherAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Teacher to aggregate.
     */
    where?: TeacherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teachers to fetch.
     */
    orderBy?: TeacherOrderByWithRelationInput | TeacherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TeacherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teachers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teachers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Teachers
    **/
    _count?: true | TeacherCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TeacherAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TeacherSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeacherMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeacherMaxAggregateInputType
  }

  export type GetTeacherAggregateType<T extends TeacherAggregateArgs> = {
        [P in keyof T & keyof AggregateTeacher]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeacher[P]>
      : GetScalarType<T[P], AggregateTeacher[P]>
  }




  export type TeacherGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeacherWhereInput
    orderBy?: TeacherOrderByWithAggregationInput | TeacherOrderByWithAggregationInput[]
    by: TeacherScalarFieldEnum[] | TeacherScalarFieldEnum
    having?: TeacherScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeacherCountAggregateInputType | true
    _avg?: TeacherAvgAggregateInputType
    _sum?: TeacherSumAggregateInputType
    _min?: TeacherMinAggregateInputType
    _max?: TeacherMaxAggregateInputType
  }

  export type TeacherGroupByOutputType = {
    id: string
    userId: string | null
    firstName: string
    middleName: string | null
    lastName: string
    email: string | null
    phone: string
    avatar: string | null
    employeeNumber: string | null
    subjects: string[]
    qualification: string | null
    experience: number | null
    salary: number | null
    joinDate: Date | null
    createdAt: Date
    updatedAt: Date
    _count: TeacherCountAggregateOutputType | null
    _avg: TeacherAvgAggregateOutputType | null
    _sum: TeacherSumAggregateOutputType | null
    _min: TeacherMinAggregateOutputType | null
    _max: TeacherMaxAggregateOutputType | null
  }

  type GetTeacherGroupByPayload<T extends TeacherGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TeacherGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeacherGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeacherGroupByOutputType[P]>
            : GetScalarType<T[P], TeacherGroupByOutputType[P]>
        }
      >
    >


  export type TeacherSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    firstName?: boolean
    middleName?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    avatar?: boolean
    employeeNumber?: boolean
    subjects?: boolean
    qualification?: boolean
    experience?: boolean
    salary?: boolean
    joinDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | Teacher$userArgs<ExtArgs>
    institution?: boolean | Teacher$institutionArgs<ExtArgs>
    classes?: boolean | Teacher$classesArgs<ExtArgs>
    _count?: boolean | TeacherCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teacher"]>



  export type TeacherSelectScalar = {
    id?: boolean
    userId?: boolean
    firstName?: boolean
    middleName?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    avatar?: boolean
    employeeNumber?: boolean
    subjects?: boolean
    qualification?: boolean
    experience?: boolean
    salary?: boolean
    joinDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TeacherOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "firstName" | "middleName" | "lastName" | "email" | "phone" | "avatar" | "employeeNumber" | "subjects" | "qualification" | "experience" | "salary" | "joinDate" | "createdAt" | "updatedAt", ExtArgs["result"]["teacher"]>
  export type TeacherInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Teacher$userArgs<ExtArgs>
    institution?: boolean | Teacher$institutionArgs<ExtArgs>
    classes?: boolean | Teacher$classesArgs<ExtArgs>
    _count?: boolean | TeacherCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $TeacherPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Teacher"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
      institution: Prisma.$TeacherOnInstitutionPayload<ExtArgs>[]
      classes: Prisma.$TeacherOnClassPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string | null
      firstName: string
      middleName: string | null
      lastName: string
      email: string | null
      phone: string
      avatar: string | null
      employeeNumber: string | null
      subjects: string[]
      qualification: string | null
      experience: number | null
      salary: number | null
      joinDate: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["teacher"]>
    composites: {}
  }

  type TeacherGetPayload<S extends boolean | null | undefined | TeacherDefaultArgs> = $Result.GetResult<Prisma.$TeacherPayload, S>

  type TeacherCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TeacherFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TeacherCountAggregateInputType | true
    }

  export interface TeacherDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Teacher'], meta: { name: 'Teacher' } }
    /**
     * Find zero or one Teacher that matches the filter.
     * @param {TeacherFindUniqueArgs} args - Arguments to find a Teacher
     * @example
     * // Get one Teacher
     * const teacher = await prisma.teacher.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TeacherFindUniqueArgs>(args: SelectSubset<T, TeacherFindUniqueArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Teacher that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TeacherFindUniqueOrThrowArgs} args - Arguments to find a Teacher
     * @example
     * // Get one Teacher
     * const teacher = await prisma.teacher.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TeacherFindUniqueOrThrowArgs>(args: SelectSubset<T, TeacherFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Teacher that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherFindFirstArgs} args - Arguments to find a Teacher
     * @example
     * // Get one Teacher
     * const teacher = await prisma.teacher.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TeacherFindFirstArgs>(args?: SelectSubset<T, TeacherFindFirstArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Teacher that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherFindFirstOrThrowArgs} args - Arguments to find a Teacher
     * @example
     * // Get one Teacher
     * const teacher = await prisma.teacher.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TeacherFindFirstOrThrowArgs>(args?: SelectSubset<T, TeacherFindFirstOrThrowArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Teachers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Teachers
     * const teachers = await prisma.teacher.findMany()
     * 
     * // Get first 10 Teachers
     * const teachers = await prisma.teacher.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const teacherWithIdOnly = await prisma.teacher.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TeacherFindManyArgs>(args?: SelectSubset<T, TeacherFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Teacher.
     * @param {TeacherCreateArgs} args - Arguments to create a Teacher.
     * @example
     * // Create one Teacher
     * const Teacher = await prisma.teacher.create({
     *   data: {
     *     // ... data to create a Teacher
     *   }
     * })
     * 
     */
    create<T extends TeacherCreateArgs>(args: SelectSubset<T, TeacherCreateArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Teachers.
     * @param {TeacherCreateManyArgs} args - Arguments to create many Teachers.
     * @example
     * // Create many Teachers
     * const teacher = await prisma.teacher.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TeacherCreateManyArgs>(args?: SelectSubset<T, TeacherCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Teacher.
     * @param {TeacherDeleteArgs} args - Arguments to delete one Teacher.
     * @example
     * // Delete one Teacher
     * const Teacher = await prisma.teacher.delete({
     *   where: {
     *     // ... filter to delete one Teacher
     *   }
     * })
     * 
     */
    delete<T extends TeacherDeleteArgs>(args: SelectSubset<T, TeacherDeleteArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Teacher.
     * @param {TeacherUpdateArgs} args - Arguments to update one Teacher.
     * @example
     * // Update one Teacher
     * const teacher = await prisma.teacher.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TeacherUpdateArgs>(args: SelectSubset<T, TeacherUpdateArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Teachers.
     * @param {TeacherDeleteManyArgs} args - Arguments to filter Teachers to delete.
     * @example
     * // Delete a few Teachers
     * const { count } = await prisma.teacher.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TeacherDeleteManyArgs>(args?: SelectSubset<T, TeacherDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Teachers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Teachers
     * const teacher = await prisma.teacher.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TeacherUpdateManyArgs>(args: SelectSubset<T, TeacherUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Teacher.
     * @param {TeacherUpsertArgs} args - Arguments to update or create a Teacher.
     * @example
     * // Update or create a Teacher
     * const teacher = await prisma.teacher.upsert({
     *   create: {
     *     // ... data to create a Teacher
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Teacher we want to update
     *   }
     * })
     */
    upsert<T extends TeacherUpsertArgs>(args: SelectSubset<T, TeacherUpsertArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Teachers that matches the filter.
     * @param {TeacherFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const teacher = await prisma.teacher.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: TeacherFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Teacher.
     * @param {TeacherAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const teacher = await prisma.teacher.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: TeacherAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Teachers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherCountArgs} args - Arguments to filter Teachers to count.
     * @example
     * // Count the number of Teachers
     * const count = await prisma.teacher.count({
     *   where: {
     *     // ... the filter for the Teachers we want to count
     *   }
     * })
    **/
    count<T extends TeacherCountArgs>(
      args?: Subset<T, TeacherCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeacherCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Teacher.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeacherAggregateArgs>(args: Subset<T, TeacherAggregateArgs>): Prisma.PrismaPromise<GetTeacherAggregateType<T>>

    /**
     * Group by Teacher.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TeacherGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeacherGroupByArgs['orderBy'] }
        : { orderBy?: TeacherGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TeacherGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeacherGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Teacher model
   */
  readonly fields: TeacherFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Teacher.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TeacherClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends Teacher$userArgs<ExtArgs> = {}>(args?: Subset<T, Teacher$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    institution<T extends Teacher$institutionArgs<ExtArgs> = {}>(args?: Subset<T, Teacher$institutionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeacherOnInstitutionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    classes<T extends Teacher$classesArgs<ExtArgs> = {}>(args?: Subset<T, Teacher$classesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeacherOnClassPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Teacher model
   */
  interface TeacherFieldRefs {
    readonly id: FieldRef<"Teacher", 'String'>
    readonly userId: FieldRef<"Teacher", 'String'>
    readonly firstName: FieldRef<"Teacher", 'String'>
    readonly middleName: FieldRef<"Teacher", 'String'>
    readonly lastName: FieldRef<"Teacher", 'String'>
    readonly email: FieldRef<"Teacher", 'String'>
    readonly phone: FieldRef<"Teacher", 'String'>
    readonly avatar: FieldRef<"Teacher", 'String'>
    readonly employeeNumber: FieldRef<"Teacher", 'String'>
    readonly subjects: FieldRef<"Teacher", 'String[]'>
    readonly qualification: FieldRef<"Teacher", 'String'>
    readonly experience: FieldRef<"Teacher", 'Int'>
    readonly salary: FieldRef<"Teacher", 'Float'>
    readonly joinDate: FieldRef<"Teacher", 'DateTime'>
    readonly createdAt: FieldRef<"Teacher", 'DateTime'>
    readonly updatedAt: FieldRef<"Teacher", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Teacher findUnique
   */
  export type TeacherFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teacher
     */
    omit?: TeacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
    /**
     * Filter, which Teacher to fetch.
     */
    where: TeacherWhereUniqueInput
  }

  /**
   * Teacher findUniqueOrThrow
   */
  export type TeacherFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teacher
     */
    omit?: TeacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
    /**
     * Filter, which Teacher to fetch.
     */
    where: TeacherWhereUniqueInput
  }

  /**
   * Teacher findFirst
   */
  export type TeacherFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teacher
     */
    omit?: TeacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
    /**
     * Filter, which Teacher to fetch.
     */
    where?: TeacherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teachers to fetch.
     */
    orderBy?: TeacherOrderByWithRelationInput | TeacherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Teachers.
     */
    cursor?: TeacherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teachers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teachers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Teachers.
     */
    distinct?: TeacherScalarFieldEnum | TeacherScalarFieldEnum[]
  }

  /**
   * Teacher findFirstOrThrow
   */
  export type TeacherFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teacher
     */
    omit?: TeacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
    /**
     * Filter, which Teacher to fetch.
     */
    where?: TeacherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teachers to fetch.
     */
    orderBy?: TeacherOrderByWithRelationInput | TeacherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Teachers.
     */
    cursor?: TeacherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teachers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teachers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Teachers.
     */
    distinct?: TeacherScalarFieldEnum | TeacherScalarFieldEnum[]
  }

  /**
   * Teacher findMany
   */
  export type TeacherFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teacher
     */
    omit?: TeacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
    /**
     * Filter, which Teachers to fetch.
     */
    where?: TeacherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teachers to fetch.
     */
    orderBy?: TeacherOrderByWithRelationInput | TeacherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Teachers.
     */
    cursor?: TeacherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teachers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teachers.
     */
    skip?: number
    distinct?: TeacherScalarFieldEnum | TeacherScalarFieldEnum[]
  }

  /**
   * Teacher create
   */
  export type TeacherCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teacher
     */
    omit?: TeacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
    /**
     * The data needed to create a Teacher.
     */
    data: XOR<TeacherCreateInput, TeacherUncheckedCreateInput>
  }

  /**
   * Teacher createMany
   */
  export type TeacherCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Teachers.
     */
    data: TeacherCreateManyInput | TeacherCreateManyInput[]
  }

  /**
   * Teacher update
   */
  export type TeacherUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teacher
     */
    omit?: TeacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
    /**
     * The data needed to update a Teacher.
     */
    data: XOR<TeacherUpdateInput, TeacherUncheckedUpdateInput>
    /**
     * Choose, which Teacher to update.
     */
    where: TeacherWhereUniqueInput
  }

  /**
   * Teacher updateMany
   */
  export type TeacherUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Teachers.
     */
    data: XOR<TeacherUpdateManyMutationInput, TeacherUncheckedUpdateManyInput>
    /**
     * Filter which Teachers to update
     */
    where?: TeacherWhereInput
    /**
     * Limit how many Teachers to update.
     */
    limit?: number
  }

  /**
   * Teacher upsert
   */
  export type TeacherUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teacher
     */
    omit?: TeacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
    /**
     * The filter to search for the Teacher to update in case it exists.
     */
    where: TeacherWhereUniqueInput
    /**
     * In case the Teacher found by the `where` argument doesn't exist, create a new Teacher with this data.
     */
    create: XOR<TeacherCreateInput, TeacherUncheckedCreateInput>
    /**
     * In case the Teacher was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TeacherUpdateInput, TeacherUncheckedUpdateInput>
  }

  /**
   * Teacher delete
   */
  export type TeacherDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teacher
     */
    omit?: TeacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
    /**
     * Filter which Teacher to delete.
     */
    where: TeacherWhereUniqueInput
  }

  /**
   * Teacher deleteMany
   */
  export type TeacherDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Teachers to delete
     */
    where?: TeacherWhereInput
    /**
     * Limit how many Teachers to delete.
     */
    limit?: number
  }

  /**
   * Teacher findRaw
   */
  export type TeacherFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Teacher aggregateRaw
   */
  export type TeacherAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Teacher.user
   */
  export type Teacher$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Teacher.institution
   */
  export type Teacher$institutionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherOnInstitution
     */
    select?: TeacherOnInstitutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeacherOnInstitution
     */
    omit?: TeacherOnInstitutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherOnInstitutionInclude<ExtArgs> | null
    where?: TeacherOnInstitutionWhereInput
    orderBy?: TeacherOnInstitutionOrderByWithRelationInput | TeacherOnInstitutionOrderByWithRelationInput[]
    cursor?: TeacherOnInstitutionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeacherOnInstitutionScalarFieldEnum | TeacherOnInstitutionScalarFieldEnum[]
  }

  /**
   * Teacher.classes
   */
  export type Teacher$classesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherOnClass
     */
    select?: TeacherOnClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeacherOnClass
     */
    omit?: TeacherOnClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherOnClassInclude<ExtArgs> | null
    where?: TeacherOnClassWhereInput
    orderBy?: TeacherOnClassOrderByWithRelationInput | TeacherOnClassOrderByWithRelationInput[]
    cursor?: TeacherOnClassWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeacherOnClassScalarFieldEnum | TeacherOnClassScalarFieldEnum[]
  }

  /**
   * Teacher without action
   */
  export type TeacherDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teacher
     */
    omit?: TeacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
  }


  /**
   * Model TeacherOnClass
   */

  export type AggregateTeacherOnClass = {
    _count: TeacherOnClassCountAggregateOutputType | null
    _min: TeacherOnClassMinAggregateOutputType | null
    _max: TeacherOnClassMaxAggregateOutputType | null
  }

  export type TeacherOnClassMinAggregateOutputType = {
    id: string | null
    teacherId: string | null
    classId: string | null
  }

  export type TeacherOnClassMaxAggregateOutputType = {
    id: string | null
    teacherId: string | null
    classId: string | null
  }

  export type TeacherOnClassCountAggregateOutputType = {
    id: number
    teacherId: number
    classId: number
    _all: number
  }


  export type TeacherOnClassMinAggregateInputType = {
    id?: true
    teacherId?: true
    classId?: true
  }

  export type TeacherOnClassMaxAggregateInputType = {
    id?: true
    teacherId?: true
    classId?: true
  }

  export type TeacherOnClassCountAggregateInputType = {
    id?: true
    teacherId?: true
    classId?: true
    _all?: true
  }

  export type TeacherOnClassAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TeacherOnClass to aggregate.
     */
    where?: TeacherOnClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeacherOnClasses to fetch.
     */
    orderBy?: TeacherOnClassOrderByWithRelationInput | TeacherOnClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TeacherOnClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeacherOnClasses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeacherOnClasses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TeacherOnClasses
    **/
    _count?: true | TeacherOnClassCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeacherOnClassMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeacherOnClassMaxAggregateInputType
  }

  export type GetTeacherOnClassAggregateType<T extends TeacherOnClassAggregateArgs> = {
        [P in keyof T & keyof AggregateTeacherOnClass]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeacherOnClass[P]>
      : GetScalarType<T[P], AggregateTeacherOnClass[P]>
  }




  export type TeacherOnClassGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeacherOnClassWhereInput
    orderBy?: TeacherOnClassOrderByWithAggregationInput | TeacherOnClassOrderByWithAggregationInput[]
    by: TeacherOnClassScalarFieldEnum[] | TeacherOnClassScalarFieldEnum
    having?: TeacherOnClassScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeacherOnClassCountAggregateInputType | true
    _min?: TeacherOnClassMinAggregateInputType
    _max?: TeacherOnClassMaxAggregateInputType
  }

  export type TeacherOnClassGroupByOutputType = {
    id: string
    teacherId: string
    classId: string
    _count: TeacherOnClassCountAggregateOutputType | null
    _min: TeacherOnClassMinAggregateOutputType | null
    _max: TeacherOnClassMaxAggregateOutputType | null
  }

  type GetTeacherOnClassGroupByPayload<T extends TeacherOnClassGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TeacherOnClassGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeacherOnClassGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeacherOnClassGroupByOutputType[P]>
            : GetScalarType<T[P], TeacherOnClassGroupByOutputType[P]>
        }
      >
    >


  export type TeacherOnClassSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teacherId?: boolean
    classId?: boolean
    teacher?: boolean | TeacherDefaultArgs<ExtArgs>
    class?: boolean | ClassDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teacherOnClass"]>



  export type TeacherOnClassSelectScalar = {
    id?: boolean
    teacherId?: boolean
    classId?: boolean
  }

  export type TeacherOnClassOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "teacherId" | "classId", ExtArgs["result"]["teacherOnClass"]>
  export type TeacherOnClassInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    teacher?: boolean | TeacherDefaultArgs<ExtArgs>
    class?: boolean | ClassDefaultArgs<ExtArgs>
  }

  export type $TeacherOnClassPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TeacherOnClass"
    objects: {
      teacher: Prisma.$TeacherPayload<ExtArgs>
      class: Prisma.$ClassPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      teacherId: string
      classId: string
    }, ExtArgs["result"]["teacherOnClass"]>
    composites: {}
  }

  type TeacherOnClassGetPayload<S extends boolean | null | undefined | TeacherOnClassDefaultArgs> = $Result.GetResult<Prisma.$TeacherOnClassPayload, S>

  type TeacherOnClassCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TeacherOnClassFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TeacherOnClassCountAggregateInputType | true
    }

  export interface TeacherOnClassDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TeacherOnClass'], meta: { name: 'TeacherOnClass' } }
    /**
     * Find zero or one TeacherOnClass that matches the filter.
     * @param {TeacherOnClassFindUniqueArgs} args - Arguments to find a TeacherOnClass
     * @example
     * // Get one TeacherOnClass
     * const teacherOnClass = await prisma.teacherOnClass.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TeacherOnClassFindUniqueArgs>(args: SelectSubset<T, TeacherOnClassFindUniqueArgs<ExtArgs>>): Prisma__TeacherOnClassClient<$Result.GetResult<Prisma.$TeacherOnClassPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TeacherOnClass that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TeacherOnClassFindUniqueOrThrowArgs} args - Arguments to find a TeacherOnClass
     * @example
     * // Get one TeacherOnClass
     * const teacherOnClass = await prisma.teacherOnClass.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TeacherOnClassFindUniqueOrThrowArgs>(args: SelectSubset<T, TeacherOnClassFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TeacherOnClassClient<$Result.GetResult<Prisma.$TeacherOnClassPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TeacherOnClass that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherOnClassFindFirstArgs} args - Arguments to find a TeacherOnClass
     * @example
     * // Get one TeacherOnClass
     * const teacherOnClass = await prisma.teacherOnClass.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TeacherOnClassFindFirstArgs>(args?: SelectSubset<T, TeacherOnClassFindFirstArgs<ExtArgs>>): Prisma__TeacherOnClassClient<$Result.GetResult<Prisma.$TeacherOnClassPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TeacherOnClass that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherOnClassFindFirstOrThrowArgs} args - Arguments to find a TeacherOnClass
     * @example
     * // Get one TeacherOnClass
     * const teacherOnClass = await prisma.teacherOnClass.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TeacherOnClassFindFirstOrThrowArgs>(args?: SelectSubset<T, TeacherOnClassFindFirstOrThrowArgs<ExtArgs>>): Prisma__TeacherOnClassClient<$Result.GetResult<Prisma.$TeacherOnClassPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TeacherOnClasses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherOnClassFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TeacherOnClasses
     * const teacherOnClasses = await prisma.teacherOnClass.findMany()
     * 
     * // Get first 10 TeacherOnClasses
     * const teacherOnClasses = await prisma.teacherOnClass.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const teacherOnClassWithIdOnly = await prisma.teacherOnClass.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TeacherOnClassFindManyArgs>(args?: SelectSubset<T, TeacherOnClassFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeacherOnClassPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TeacherOnClass.
     * @param {TeacherOnClassCreateArgs} args - Arguments to create a TeacherOnClass.
     * @example
     * // Create one TeacherOnClass
     * const TeacherOnClass = await prisma.teacherOnClass.create({
     *   data: {
     *     // ... data to create a TeacherOnClass
     *   }
     * })
     * 
     */
    create<T extends TeacherOnClassCreateArgs>(args: SelectSubset<T, TeacherOnClassCreateArgs<ExtArgs>>): Prisma__TeacherOnClassClient<$Result.GetResult<Prisma.$TeacherOnClassPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TeacherOnClasses.
     * @param {TeacherOnClassCreateManyArgs} args - Arguments to create many TeacherOnClasses.
     * @example
     * // Create many TeacherOnClasses
     * const teacherOnClass = await prisma.teacherOnClass.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TeacherOnClassCreateManyArgs>(args?: SelectSubset<T, TeacherOnClassCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TeacherOnClass.
     * @param {TeacherOnClassDeleteArgs} args - Arguments to delete one TeacherOnClass.
     * @example
     * // Delete one TeacherOnClass
     * const TeacherOnClass = await prisma.teacherOnClass.delete({
     *   where: {
     *     // ... filter to delete one TeacherOnClass
     *   }
     * })
     * 
     */
    delete<T extends TeacherOnClassDeleteArgs>(args: SelectSubset<T, TeacherOnClassDeleteArgs<ExtArgs>>): Prisma__TeacherOnClassClient<$Result.GetResult<Prisma.$TeacherOnClassPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TeacherOnClass.
     * @param {TeacherOnClassUpdateArgs} args - Arguments to update one TeacherOnClass.
     * @example
     * // Update one TeacherOnClass
     * const teacherOnClass = await prisma.teacherOnClass.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TeacherOnClassUpdateArgs>(args: SelectSubset<T, TeacherOnClassUpdateArgs<ExtArgs>>): Prisma__TeacherOnClassClient<$Result.GetResult<Prisma.$TeacherOnClassPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TeacherOnClasses.
     * @param {TeacherOnClassDeleteManyArgs} args - Arguments to filter TeacherOnClasses to delete.
     * @example
     * // Delete a few TeacherOnClasses
     * const { count } = await prisma.teacherOnClass.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TeacherOnClassDeleteManyArgs>(args?: SelectSubset<T, TeacherOnClassDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TeacherOnClasses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherOnClassUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TeacherOnClasses
     * const teacherOnClass = await prisma.teacherOnClass.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TeacherOnClassUpdateManyArgs>(args: SelectSubset<T, TeacherOnClassUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TeacherOnClass.
     * @param {TeacherOnClassUpsertArgs} args - Arguments to update or create a TeacherOnClass.
     * @example
     * // Update or create a TeacherOnClass
     * const teacherOnClass = await prisma.teacherOnClass.upsert({
     *   create: {
     *     // ... data to create a TeacherOnClass
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TeacherOnClass we want to update
     *   }
     * })
     */
    upsert<T extends TeacherOnClassUpsertArgs>(args: SelectSubset<T, TeacherOnClassUpsertArgs<ExtArgs>>): Prisma__TeacherOnClassClient<$Result.GetResult<Prisma.$TeacherOnClassPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TeacherOnClasses that matches the filter.
     * @param {TeacherOnClassFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const teacherOnClass = await prisma.teacherOnClass.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: TeacherOnClassFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a TeacherOnClass.
     * @param {TeacherOnClassAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const teacherOnClass = await prisma.teacherOnClass.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: TeacherOnClassAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of TeacherOnClasses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherOnClassCountArgs} args - Arguments to filter TeacherOnClasses to count.
     * @example
     * // Count the number of TeacherOnClasses
     * const count = await prisma.teacherOnClass.count({
     *   where: {
     *     // ... the filter for the TeacherOnClasses we want to count
     *   }
     * })
    **/
    count<T extends TeacherOnClassCountArgs>(
      args?: Subset<T, TeacherOnClassCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeacherOnClassCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TeacherOnClass.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherOnClassAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeacherOnClassAggregateArgs>(args: Subset<T, TeacherOnClassAggregateArgs>): Prisma.PrismaPromise<GetTeacherOnClassAggregateType<T>>

    /**
     * Group by TeacherOnClass.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherOnClassGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TeacherOnClassGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeacherOnClassGroupByArgs['orderBy'] }
        : { orderBy?: TeacherOnClassGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TeacherOnClassGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeacherOnClassGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TeacherOnClass model
   */
  readonly fields: TeacherOnClassFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TeacherOnClass.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TeacherOnClassClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    teacher<T extends TeacherDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeacherDefaultArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    class<T extends ClassDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClassDefaultArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TeacherOnClass model
   */
  interface TeacherOnClassFieldRefs {
    readonly id: FieldRef<"TeacherOnClass", 'String'>
    readonly teacherId: FieldRef<"TeacherOnClass", 'String'>
    readonly classId: FieldRef<"TeacherOnClass", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TeacherOnClass findUnique
   */
  export type TeacherOnClassFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherOnClass
     */
    select?: TeacherOnClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeacherOnClass
     */
    omit?: TeacherOnClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherOnClassInclude<ExtArgs> | null
    /**
     * Filter, which TeacherOnClass to fetch.
     */
    where: TeacherOnClassWhereUniqueInput
  }

  /**
   * TeacherOnClass findUniqueOrThrow
   */
  export type TeacherOnClassFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherOnClass
     */
    select?: TeacherOnClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeacherOnClass
     */
    omit?: TeacherOnClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherOnClassInclude<ExtArgs> | null
    /**
     * Filter, which TeacherOnClass to fetch.
     */
    where: TeacherOnClassWhereUniqueInput
  }

  /**
   * TeacherOnClass findFirst
   */
  export type TeacherOnClassFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherOnClass
     */
    select?: TeacherOnClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeacherOnClass
     */
    omit?: TeacherOnClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherOnClassInclude<ExtArgs> | null
    /**
     * Filter, which TeacherOnClass to fetch.
     */
    where?: TeacherOnClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeacherOnClasses to fetch.
     */
    orderBy?: TeacherOnClassOrderByWithRelationInput | TeacherOnClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeacherOnClasses.
     */
    cursor?: TeacherOnClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeacherOnClasses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeacherOnClasses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeacherOnClasses.
     */
    distinct?: TeacherOnClassScalarFieldEnum | TeacherOnClassScalarFieldEnum[]
  }

  /**
   * TeacherOnClass findFirstOrThrow
   */
  export type TeacherOnClassFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherOnClass
     */
    select?: TeacherOnClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeacherOnClass
     */
    omit?: TeacherOnClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherOnClassInclude<ExtArgs> | null
    /**
     * Filter, which TeacherOnClass to fetch.
     */
    where?: TeacherOnClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeacherOnClasses to fetch.
     */
    orderBy?: TeacherOnClassOrderByWithRelationInput | TeacherOnClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeacherOnClasses.
     */
    cursor?: TeacherOnClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeacherOnClasses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeacherOnClasses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeacherOnClasses.
     */
    distinct?: TeacherOnClassScalarFieldEnum | TeacherOnClassScalarFieldEnum[]
  }

  /**
   * TeacherOnClass findMany
   */
  export type TeacherOnClassFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherOnClass
     */
    select?: TeacherOnClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeacherOnClass
     */
    omit?: TeacherOnClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherOnClassInclude<ExtArgs> | null
    /**
     * Filter, which TeacherOnClasses to fetch.
     */
    where?: TeacherOnClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeacherOnClasses to fetch.
     */
    orderBy?: TeacherOnClassOrderByWithRelationInput | TeacherOnClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TeacherOnClasses.
     */
    cursor?: TeacherOnClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeacherOnClasses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeacherOnClasses.
     */
    skip?: number
    distinct?: TeacherOnClassScalarFieldEnum | TeacherOnClassScalarFieldEnum[]
  }

  /**
   * TeacherOnClass create
   */
  export type TeacherOnClassCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherOnClass
     */
    select?: TeacherOnClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeacherOnClass
     */
    omit?: TeacherOnClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherOnClassInclude<ExtArgs> | null
    /**
     * The data needed to create a TeacherOnClass.
     */
    data: XOR<TeacherOnClassCreateInput, TeacherOnClassUncheckedCreateInput>
  }

  /**
   * TeacherOnClass createMany
   */
  export type TeacherOnClassCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TeacherOnClasses.
     */
    data: TeacherOnClassCreateManyInput | TeacherOnClassCreateManyInput[]
  }

  /**
   * TeacherOnClass update
   */
  export type TeacherOnClassUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherOnClass
     */
    select?: TeacherOnClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeacherOnClass
     */
    omit?: TeacherOnClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherOnClassInclude<ExtArgs> | null
    /**
     * The data needed to update a TeacherOnClass.
     */
    data: XOR<TeacherOnClassUpdateInput, TeacherOnClassUncheckedUpdateInput>
    /**
     * Choose, which TeacherOnClass to update.
     */
    where: TeacherOnClassWhereUniqueInput
  }

  /**
   * TeacherOnClass updateMany
   */
  export type TeacherOnClassUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TeacherOnClasses.
     */
    data: XOR<TeacherOnClassUpdateManyMutationInput, TeacherOnClassUncheckedUpdateManyInput>
    /**
     * Filter which TeacherOnClasses to update
     */
    where?: TeacherOnClassWhereInput
    /**
     * Limit how many TeacherOnClasses to update.
     */
    limit?: number
  }

  /**
   * TeacherOnClass upsert
   */
  export type TeacherOnClassUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherOnClass
     */
    select?: TeacherOnClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeacherOnClass
     */
    omit?: TeacherOnClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherOnClassInclude<ExtArgs> | null
    /**
     * The filter to search for the TeacherOnClass to update in case it exists.
     */
    where: TeacherOnClassWhereUniqueInput
    /**
     * In case the TeacherOnClass found by the `where` argument doesn't exist, create a new TeacherOnClass with this data.
     */
    create: XOR<TeacherOnClassCreateInput, TeacherOnClassUncheckedCreateInput>
    /**
     * In case the TeacherOnClass was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TeacherOnClassUpdateInput, TeacherOnClassUncheckedUpdateInput>
  }

  /**
   * TeacherOnClass delete
   */
  export type TeacherOnClassDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherOnClass
     */
    select?: TeacherOnClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeacherOnClass
     */
    omit?: TeacherOnClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherOnClassInclude<ExtArgs> | null
    /**
     * Filter which TeacherOnClass to delete.
     */
    where: TeacherOnClassWhereUniqueInput
  }

  /**
   * TeacherOnClass deleteMany
   */
  export type TeacherOnClassDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TeacherOnClasses to delete
     */
    where?: TeacherOnClassWhereInput
    /**
     * Limit how many TeacherOnClasses to delete.
     */
    limit?: number
  }

  /**
   * TeacherOnClass findRaw
   */
  export type TeacherOnClassFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * TeacherOnClass aggregateRaw
   */
  export type TeacherOnClassAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * TeacherOnClass without action
   */
  export type TeacherOnClassDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherOnClass
     */
    select?: TeacherOnClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeacherOnClass
     */
    omit?: TeacherOnClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherOnClassInclude<ExtArgs> | null
  }


  /**
   * Model Class
   */

  export type AggregateClass = {
    _count: ClassCountAggregateOutputType | null
    _avg: ClassAvgAggregateOutputType | null
    _sum: ClassSumAggregateOutputType | null
    _min: ClassMinAggregateOutputType | null
    _max: ClassMaxAggregateOutputType | null
  }

  export type ClassAvgAggregateOutputType = {
    capacity: number | null
  }

  export type ClassSumAggregateOutputType = {
    capacity: number | null
  }

  export type ClassMinAggregateOutputType = {
    id: string | null
    institutionId: string | null
    name: string | null
    section: string | null
    academicYear: string | null
    capacity: number | null
    roomNumber: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClassMaxAggregateOutputType = {
    id: string | null
    institutionId: string | null
    name: string | null
    section: string | null
    academicYear: string | null
    capacity: number | null
    roomNumber: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClassCountAggregateOutputType = {
    id: number
    institutionId: number
    name: number
    section: number
    academicYear: number
    capacity: number
    roomNumber: number
    createdAt: number
    updatedAt: number
    teacherIds: number
    _all: number
  }


  export type ClassAvgAggregateInputType = {
    capacity?: true
  }

  export type ClassSumAggregateInputType = {
    capacity?: true
  }

  export type ClassMinAggregateInputType = {
    id?: true
    institutionId?: true
    name?: true
    section?: true
    academicYear?: true
    capacity?: true
    roomNumber?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClassMaxAggregateInputType = {
    id?: true
    institutionId?: true
    name?: true
    section?: true
    academicYear?: true
    capacity?: true
    roomNumber?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClassCountAggregateInputType = {
    id?: true
    institutionId?: true
    name?: true
    section?: true
    academicYear?: true
    capacity?: true
    roomNumber?: true
    createdAt?: true
    updatedAt?: true
    teacherIds?: true
    _all?: true
  }

  export type ClassAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Class to aggregate.
     */
    where?: ClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Classes to fetch.
     */
    orderBy?: ClassOrderByWithRelationInput | ClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Classes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Classes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Classes
    **/
    _count?: true | ClassCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClassAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClassSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClassMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClassMaxAggregateInputType
  }

  export type GetClassAggregateType<T extends ClassAggregateArgs> = {
        [P in keyof T & keyof AggregateClass]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClass[P]>
      : GetScalarType<T[P], AggregateClass[P]>
  }




  export type ClassGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassWhereInput
    orderBy?: ClassOrderByWithAggregationInput | ClassOrderByWithAggregationInput[]
    by: ClassScalarFieldEnum[] | ClassScalarFieldEnum
    having?: ClassScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClassCountAggregateInputType | true
    _avg?: ClassAvgAggregateInputType
    _sum?: ClassSumAggregateInputType
    _min?: ClassMinAggregateInputType
    _max?: ClassMaxAggregateInputType
  }

  export type ClassGroupByOutputType = {
    id: string
    institutionId: string
    name: string
    section: string | null
    academicYear: string | null
    capacity: number | null
    roomNumber: string | null
    createdAt: Date
    updatedAt: Date
    teacherIds: string[]
    _count: ClassCountAggregateOutputType | null
    _avg: ClassAvgAggregateOutputType | null
    _sum: ClassSumAggregateOutputType | null
    _min: ClassMinAggregateOutputType | null
    _max: ClassMaxAggregateOutputType | null
  }

  type GetClassGroupByPayload<T extends ClassGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClassGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClassGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClassGroupByOutputType[P]>
            : GetScalarType<T[P], ClassGroupByOutputType[P]>
        }
      >
    >


  export type ClassSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    institutionId?: boolean
    name?: boolean
    section?: boolean
    academicYear?: boolean
    capacity?: boolean
    roomNumber?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    teacherIds?: boolean
    institution?: boolean | InstitutionDefaultArgs<ExtArgs>
    students?: boolean | Class$studentsArgs<ExtArgs>
    teachers?: boolean | Class$teachersArgs<ExtArgs>
    enrollments?: boolean | Class$enrollmentsArgs<ExtArgs>
    attendances?: boolean | Class$attendancesArgs<ExtArgs>
    timetables?: boolean | Class$timetablesArgs<ExtArgs>
    _count?: boolean | ClassCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["class"]>



  export type ClassSelectScalar = {
    id?: boolean
    institutionId?: boolean
    name?: boolean
    section?: boolean
    academicYear?: boolean
    capacity?: boolean
    roomNumber?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    teacherIds?: boolean
  }

  export type ClassOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "institutionId" | "name" | "section" | "academicYear" | "capacity" | "roomNumber" | "createdAt" | "updatedAt" | "teacherIds", ExtArgs["result"]["class"]>
  export type ClassInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    institution?: boolean | InstitutionDefaultArgs<ExtArgs>
    students?: boolean | Class$studentsArgs<ExtArgs>
    teachers?: boolean | Class$teachersArgs<ExtArgs>
    enrollments?: boolean | Class$enrollmentsArgs<ExtArgs>
    attendances?: boolean | Class$attendancesArgs<ExtArgs>
    timetables?: boolean | Class$timetablesArgs<ExtArgs>
    _count?: boolean | ClassCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ClassPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Class"
    objects: {
      institution: Prisma.$InstitutionPayload<ExtArgs>
      students: Prisma.$StudentPayload<ExtArgs>[]
      teachers: Prisma.$TeacherOnClassPayload<ExtArgs>[]
      enrollments: Prisma.$EnrollmentPayload<ExtArgs>[]
      attendances: Prisma.$AttendancePayload<ExtArgs>[]
      timetables: Prisma.$TimetablePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      institutionId: string
      name: string
      section: string | null
      academicYear: string | null
      capacity: number | null
      roomNumber: string | null
      createdAt: Date
      updatedAt: Date
      teacherIds: string[]
    }, ExtArgs["result"]["class"]>
    composites: {}
  }

  type ClassGetPayload<S extends boolean | null | undefined | ClassDefaultArgs> = $Result.GetResult<Prisma.$ClassPayload, S>

  type ClassCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClassFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClassCountAggregateInputType | true
    }

  export interface ClassDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Class'], meta: { name: 'Class' } }
    /**
     * Find zero or one Class that matches the filter.
     * @param {ClassFindUniqueArgs} args - Arguments to find a Class
     * @example
     * // Get one Class
     * const class = await prisma.class.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClassFindUniqueArgs>(args: SelectSubset<T, ClassFindUniqueArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Class that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClassFindUniqueOrThrowArgs} args - Arguments to find a Class
     * @example
     * // Get one Class
     * const class = await prisma.class.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClassFindUniqueOrThrowArgs>(args: SelectSubset<T, ClassFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Class that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassFindFirstArgs} args - Arguments to find a Class
     * @example
     * // Get one Class
     * const class = await prisma.class.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClassFindFirstArgs>(args?: SelectSubset<T, ClassFindFirstArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Class that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassFindFirstOrThrowArgs} args - Arguments to find a Class
     * @example
     * // Get one Class
     * const class = await prisma.class.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClassFindFirstOrThrowArgs>(args?: SelectSubset<T, ClassFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Classes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Classes
     * const classes = await prisma.class.findMany()
     * 
     * // Get first 10 Classes
     * const classes = await prisma.class.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const classWithIdOnly = await prisma.class.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClassFindManyArgs>(args?: SelectSubset<T, ClassFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Class.
     * @param {ClassCreateArgs} args - Arguments to create a Class.
     * @example
     * // Create one Class
     * const Class = await prisma.class.create({
     *   data: {
     *     // ... data to create a Class
     *   }
     * })
     * 
     */
    create<T extends ClassCreateArgs>(args: SelectSubset<T, ClassCreateArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Classes.
     * @param {ClassCreateManyArgs} args - Arguments to create many Classes.
     * @example
     * // Create many Classes
     * const class = await prisma.class.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClassCreateManyArgs>(args?: SelectSubset<T, ClassCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Class.
     * @param {ClassDeleteArgs} args - Arguments to delete one Class.
     * @example
     * // Delete one Class
     * const Class = await prisma.class.delete({
     *   where: {
     *     // ... filter to delete one Class
     *   }
     * })
     * 
     */
    delete<T extends ClassDeleteArgs>(args: SelectSubset<T, ClassDeleteArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Class.
     * @param {ClassUpdateArgs} args - Arguments to update one Class.
     * @example
     * // Update one Class
     * const class = await prisma.class.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClassUpdateArgs>(args: SelectSubset<T, ClassUpdateArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Classes.
     * @param {ClassDeleteManyArgs} args - Arguments to filter Classes to delete.
     * @example
     * // Delete a few Classes
     * const { count } = await prisma.class.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClassDeleteManyArgs>(args?: SelectSubset<T, ClassDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Classes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Classes
     * const class = await prisma.class.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClassUpdateManyArgs>(args: SelectSubset<T, ClassUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Class.
     * @param {ClassUpsertArgs} args - Arguments to update or create a Class.
     * @example
     * // Update or create a Class
     * const class = await prisma.class.upsert({
     *   create: {
     *     // ... data to create a Class
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Class we want to update
     *   }
     * })
     */
    upsert<T extends ClassUpsertArgs>(args: SelectSubset<T, ClassUpsertArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Classes that matches the filter.
     * @param {ClassFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const class = await prisma.class.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: ClassFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Class.
     * @param {ClassAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const class = await prisma.class.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: ClassAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Classes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassCountArgs} args - Arguments to filter Classes to count.
     * @example
     * // Count the number of Classes
     * const count = await prisma.class.count({
     *   where: {
     *     // ... the filter for the Classes we want to count
     *   }
     * })
    **/
    count<T extends ClassCountArgs>(
      args?: Subset<T, ClassCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClassCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Class.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClassAggregateArgs>(args: Subset<T, ClassAggregateArgs>): Prisma.PrismaPromise<GetClassAggregateType<T>>

    /**
     * Group by Class.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClassGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClassGroupByArgs['orderBy'] }
        : { orderBy?: ClassGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClassGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClassGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Class model
   */
  readonly fields: ClassFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Class.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClassClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    institution<T extends InstitutionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InstitutionDefaultArgs<ExtArgs>>): Prisma__InstitutionClient<$Result.GetResult<Prisma.$InstitutionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    students<T extends Class$studentsArgs<ExtArgs> = {}>(args?: Subset<T, Class$studentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    teachers<T extends Class$teachersArgs<ExtArgs> = {}>(args?: Subset<T, Class$teachersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeacherOnClassPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    enrollments<T extends Class$enrollmentsArgs<ExtArgs> = {}>(args?: Subset<T, Class$enrollmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    attendances<T extends Class$attendancesArgs<ExtArgs> = {}>(args?: Subset<T, Class$attendancesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    timetables<T extends Class$timetablesArgs<ExtArgs> = {}>(args?: Subset<T, Class$timetablesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimetablePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Class model
   */
  interface ClassFieldRefs {
    readonly id: FieldRef<"Class", 'String'>
    readonly institutionId: FieldRef<"Class", 'String'>
    readonly name: FieldRef<"Class", 'String'>
    readonly section: FieldRef<"Class", 'String'>
    readonly academicYear: FieldRef<"Class", 'String'>
    readonly capacity: FieldRef<"Class", 'Int'>
    readonly roomNumber: FieldRef<"Class", 'String'>
    readonly createdAt: FieldRef<"Class", 'DateTime'>
    readonly updatedAt: FieldRef<"Class", 'DateTime'>
    readonly teacherIds: FieldRef<"Class", 'String[]'>
  }
    

  // Custom InputTypes
  /**
   * Class findUnique
   */
  export type ClassFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * Filter, which Class to fetch.
     */
    where: ClassWhereUniqueInput
  }

  /**
   * Class findUniqueOrThrow
   */
  export type ClassFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * Filter, which Class to fetch.
     */
    where: ClassWhereUniqueInput
  }

  /**
   * Class findFirst
   */
  export type ClassFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * Filter, which Class to fetch.
     */
    where?: ClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Classes to fetch.
     */
    orderBy?: ClassOrderByWithRelationInput | ClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Classes.
     */
    cursor?: ClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Classes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Classes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Classes.
     */
    distinct?: ClassScalarFieldEnum | ClassScalarFieldEnum[]
  }

  /**
   * Class findFirstOrThrow
   */
  export type ClassFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * Filter, which Class to fetch.
     */
    where?: ClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Classes to fetch.
     */
    orderBy?: ClassOrderByWithRelationInput | ClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Classes.
     */
    cursor?: ClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Classes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Classes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Classes.
     */
    distinct?: ClassScalarFieldEnum | ClassScalarFieldEnum[]
  }

  /**
   * Class findMany
   */
  export type ClassFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * Filter, which Classes to fetch.
     */
    where?: ClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Classes to fetch.
     */
    orderBy?: ClassOrderByWithRelationInput | ClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Classes.
     */
    cursor?: ClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Classes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Classes.
     */
    skip?: number
    distinct?: ClassScalarFieldEnum | ClassScalarFieldEnum[]
  }

  /**
   * Class create
   */
  export type ClassCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * The data needed to create a Class.
     */
    data: XOR<ClassCreateInput, ClassUncheckedCreateInput>
  }

  /**
   * Class createMany
   */
  export type ClassCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Classes.
     */
    data: ClassCreateManyInput | ClassCreateManyInput[]
  }

  /**
   * Class update
   */
  export type ClassUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * The data needed to update a Class.
     */
    data: XOR<ClassUpdateInput, ClassUncheckedUpdateInput>
    /**
     * Choose, which Class to update.
     */
    where: ClassWhereUniqueInput
  }

  /**
   * Class updateMany
   */
  export type ClassUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Classes.
     */
    data: XOR<ClassUpdateManyMutationInput, ClassUncheckedUpdateManyInput>
    /**
     * Filter which Classes to update
     */
    where?: ClassWhereInput
    /**
     * Limit how many Classes to update.
     */
    limit?: number
  }

  /**
   * Class upsert
   */
  export type ClassUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * The filter to search for the Class to update in case it exists.
     */
    where: ClassWhereUniqueInput
    /**
     * In case the Class found by the `where` argument doesn't exist, create a new Class with this data.
     */
    create: XOR<ClassCreateInput, ClassUncheckedCreateInput>
    /**
     * In case the Class was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClassUpdateInput, ClassUncheckedUpdateInput>
  }

  /**
   * Class delete
   */
  export type ClassDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * Filter which Class to delete.
     */
    where: ClassWhereUniqueInput
  }

  /**
   * Class deleteMany
   */
  export type ClassDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Classes to delete
     */
    where?: ClassWhereInput
    /**
     * Limit how many Classes to delete.
     */
    limit?: number
  }

  /**
   * Class findRaw
   */
  export type ClassFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Class aggregateRaw
   */
  export type ClassAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Class.students
   */
  export type Class$studentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    where?: StudentWhereInput
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    cursor?: StudentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * Class.teachers
   */
  export type Class$teachersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherOnClass
     */
    select?: TeacherOnClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeacherOnClass
     */
    omit?: TeacherOnClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherOnClassInclude<ExtArgs> | null
    where?: TeacherOnClassWhereInput
    orderBy?: TeacherOnClassOrderByWithRelationInput | TeacherOnClassOrderByWithRelationInput[]
    cursor?: TeacherOnClassWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeacherOnClassScalarFieldEnum | TeacherOnClassScalarFieldEnum[]
  }

  /**
   * Class.enrollments
   */
  export type Class$enrollmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Enrollment
     */
    omit?: EnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
    where?: EnrollmentWhereInput
    orderBy?: EnrollmentOrderByWithRelationInput | EnrollmentOrderByWithRelationInput[]
    cursor?: EnrollmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EnrollmentScalarFieldEnum | EnrollmentScalarFieldEnum[]
  }

  /**
   * Class.attendances
   */
  export type Class$attendancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    where?: AttendanceWhereInput
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    cursor?: AttendanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[]
  }

  /**
   * Class.timetables
   */
  export type Class$timetablesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Timetable
     */
    select?: TimetableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Timetable
     */
    omit?: TimetableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimetableInclude<ExtArgs> | null
    where?: TimetableWhereInput
    orderBy?: TimetableOrderByWithRelationInput | TimetableOrderByWithRelationInput[]
    cursor?: TimetableWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TimetableScalarFieldEnum | TimetableScalarFieldEnum[]
  }

  /**
   * Class without action
   */
  export type ClassDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
  }


  /**
   * Model Enrollment
   */

  export type AggregateEnrollment = {
    _count: EnrollmentCountAggregateOutputType | null
    _min: EnrollmentMinAggregateOutputType | null
    _max: EnrollmentMaxAggregateOutputType | null
  }

  export type EnrollmentMinAggregateOutputType = {
    id: string | null
    studentId: string | null
    classId: string | null
    academicYear: string | null
    enrollDate: Date | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EnrollmentMaxAggregateOutputType = {
    id: string | null
    studentId: string | null
    classId: string | null
    academicYear: string | null
    enrollDate: Date | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EnrollmentCountAggregateOutputType = {
    id: number
    studentId: number
    classId: number
    academicYear: number
    enrollDate: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EnrollmentMinAggregateInputType = {
    id?: true
    studentId?: true
    classId?: true
    academicYear?: true
    enrollDate?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EnrollmentMaxAggregateInputType = {
    id?: true
    studentId?: true
    classId?: true
    academicYear?: true
    enrollDate?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EnrollmentCountAggregateInputType = {
    id?: true
    studentId?: true
    classId?: true
    academicYear?: true
    enrollDate?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EnrollmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Enrollment to aggregate.
     */
    where?: EnrollmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Enrollments to fetch.
     */
    orderBy?: EnrollmentOrderByWithRelationInput | EnrollmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EnrollmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Enrollments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Enrollments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Enrollments
    **/
    _count?: true | EnrollmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EnrollmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EnrollmentMaxAggregateInputType
  }

  export type GetEnrollmentAggregateType<T extends EnrollmentAggregateArgs> = {
        [P in keyof T & keyof AggregateEnrollment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEnrollment[P]>
      : GetScalarType<T[P], AggregateEnrollment[P]>
  }




  export type EnrollmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EnrollmentWhereInput
    orderBy?: EnrollmentOrderByWithAggregationInput | EnrollmentOrderByWithAggregationInput[]
    by: EnrollmentScalarFieldEnum[] | EnrollmentScalarFieldEnum
    having?: EnrollmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EnrollmentCountAggregateInputType | true
    _min?: EnrollmentMinAggregateInputType
    _max?: EnrollmentMaxAggregateInputType
  }

  export type EnrollmentGroupByOutputType = {
    id: string
    studentId: string
    classId: string
    academicYear: string
    enrollDate: Date
    status: string
    createdAt: Date
    updatedAt: Date
    _count: EnrollmentCountAggregateOutputType | null
    _min: EnrollmentMinAggregateOutputType | null
    _max: EnrollmentMaxAggregateOutputType | null
  }

  type GetEnrollmentGroupByPayload<T extends EnrollmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EnrollmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EnrollmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EnrollmentGroupByOutputType[P]>
            : GetScalarType<T[P], EnrollmentGroupByOutputType[P]>
        }
      >
    >


  export type EnrollmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    classId?: boolean
    academicYear?: boolean
    enrollDate?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    class?: boolean | ClassDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["enrollment"]>



  export type EnrollmentSelectScalar = {
    id?: boolean
    studentId?: boolean
    classId?: boolean
    academicYear?: boolean
    enrollDate?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EnrollmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "studentId" | "classId" | "academicYear" | "enrollDate" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["enrollment"]>
  export type EnrollmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    class?: boolean | ClassDefaultArgs<ExtArgs>
  }

  export type $EnrollmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Enrollment"
    objects: {
      student: Prisma.$StudentPayload<ExtArgs>
      class: Prisma.$ClassPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      studentId: string
      classId: string
      academicYear: string
      enrollDate: Date
      status: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["enrollment"]>
    composites: {}
  }

  type EnrollmentGetPayload<S extends boolean | null | undefined | EnrollmentDefaultArgs> = $Result.GetResult<Prisma.$EnrollmentPayload, S>

  type EnrollmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EnrollmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EnrollmentCountAggregateInputType | true
    }

  export interface EnrollmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Enrollment'], meta: { name: 'Enrollment' } }
    /**
     * Find zero or one Enrollment that matches the filter.
     * @param {EnrollmentFindUniqueArgs} args - Arguments to find a Enrollment
     * @example
     * // Get one Enrollment
     * const enrollment = await prisma.enrollment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EnrollmentFindUniqueArgs>(args: SelectSubset<T, EnrollmentFindUniqueArgs<ExtArgs>>): Prisma__EnrollmentClient<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Enrollment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EnrollmentFindUniqueOrThrowArgs} args - Arguments to find a Enrollment
     * @example
     * // Get one Enrollment
     * const enrollment = await prisma.enrollment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EnrollmentFindUniqueOrThrowArgs>(args: SelectSubset<T, EnrollmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EnrollmentClient<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Enrollment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnrollmentFindFirstArgs} args - Arguments to find a Enrollment
     * @example
     * // Get one Enrollment
     * const enrollment = await prisma.enrollment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EnrollmentFindFirstArgs>(args?: SelectSubset<T, EnrollmentFindFirstArgs<ExtArgs>>): Prisma__EnrollmentClient<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Enrollment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnrollmentFindFirstOrThrowArgs} args - Arguments to find a Enrollment
     * @example
     * // Get one Enrollment
     * const enrollment = await prisma.enrollment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EnrollmentFindFirstOrThrowArgs>(args?: SelectSubset<T, EnrollmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__EnrollmentClient<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Enrollments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnrollmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Enrollments
     * const enrollments = await prisma.enrollment.findMany()
     * 
     * // Get first 10 Enrollments
     * const enrollments = await prisma.enrollment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const enrollmentWithIdOnly = await prisma.enrollment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EnrollmentFindManyArgs>(args?: SelectSubset<T, EnrollmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Enrollment.
     * @param {EnrollmentCreateArgs} args - Arguments to create a Enrollment.
     * @example
     * // Create one Enrollment
     * const Enrollment = await prisma.enrollment.create({
     *   data: {
     *     // ... data to create a Enrollment
     *   }
     * })
     * 
     */
    create<T extends EnrollmentCreateArgs>(args: SelectSubset<T, EnrollmentCreateArgs<ExtArgs>>): Prisma__EnrollmentClient<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Enrollments.
     * @param {EnrollmentCreateManyArgs} args - Arguments to create many Enrollments.
     * @example
     * // Create many Enrollments
     * const enrollment = await prisma.enrollment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EnrollmentCreateManyArgs>(args?: SelectSubset<T, EnrollmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Enrollment.
     * @param {EnrollmentDeleteArgs} args - Arguments to delete one Enrollment.
     * @example
     * // Delete one Enrollment
     * const Enrollment = await prisma.enrollment.delete({
     *   where: {
     *     // ... filter to delete one Enrollment
     *   }
     * })
     * 
     */
    delete<T extends EnrollmentDeleteArgs>(args: SelectSubset<T, EnrollmentDeleteArgs<ExtArgs>>): Prisma__EnrollmentClient<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Enrollment.
     * @param {EnrollmentUpdateArgs} args - Arguments to update one Enrollment.
     * @example
     * // Update one Enrollment
     * const enrollment = await prisma.enrollment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EnrollmentUpdateArgs>(args: SelectSubset<T, EnrollmentUpdateArgs<ExtArgs>>): Prisma__EnrollmentClient<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Enrollments.
     * @param {EnrollmentDeleteManyArgs} args - Arguments to filter Enrollments to delete.
     * @example
     * // Delete a few Enrollments
     * const { count } = await prisma.enrollment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EnrollmentDeleteManyArgs>(args?: SelectSubset<T, EnrollmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Enrollments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnrollmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Enrollments
     * const enrollment = await prisma.enrollment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EnrollmentUpdateManyArgs>(args: SelectSubset<T, EnrollmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Enrollment.
     * @param {EnrollmentUpsertArgs} args - Arguments to update or create a Enrollment.
     * @example
     * // Update or create a Enrollment
     * const enrollment = await prisma.enrollment.upsert({
     *   create: {
     *     // ... data to create a Enrollment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Enrollment we want to update
     *   }
     * })
     */
    upsert<T extends EnrollmentUpsertArgs>(args: SelectSubset<T, EnrollmentUpsertArgs<ExtArgs>>): Prisma__EnrollmentClient<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Enrollments that matches the filter.
     * @param {EnrollmentFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const enrollment = await prisma.enrollment.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: EnrollmentFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Enrollment.
     * @param {EnrollmentAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const enrollment = await prisma.enrollment.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: EnrollmentAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Enrollments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnrollmentCountArgs} args - Arguments to filter Enrollments to count.
     * @example
     * // Count the number of Enrollments
     * const count = await prisma.enrollment.count({
     *   where: {
     *     // ... the filter for the Enrollments we want to count
     *   }
     * })
    **/
    count<T extends EnrollmentCountArgs>(
      args?: Subset<T, EnrollmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EnrollmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Enrollment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnrollmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EnrollmentAggregateArgs>(args: Subset<T, EnrollmentAggregateArgs>): Prisma.PrismaPromise<GetEnrollmentAggregateType<T>>

    /**
     * Group by Enrollment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnrollmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EnrollmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EnrollmentGroupByArgs['orderBy'] }
        : { orderBy?: EnrollmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EnrollmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEnrollmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Enrollment model
   */
  readonly fields: EnrollmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Enrollment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EnrollmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    class<T extends ClassDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClassDefaultArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Enrollment model
   */
  interface EnrollmentFieldRefs {
    readonly id: FieldRef<"Enrollment", 'String'>
    readonly studentId: FieldRef<"Enrollment", 'String'>
    readonly classId: FieldRef<"Enrollment", 'String'>
    readonly academicYear: FieldRef<"Enrollment", 'String'>
    readonly enrollDate: FieldRef<"Enrollment", 'DateTime'>
    readonly status: FieldRef<"Enrollment", 'String'>
    readonly createdAt: FieldRef<"Enrollment", 'DateTime'>
    readonly updatedAt: FieldRef<"Enrollment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Enrollment findUnique
   */
  export type EnrollmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Enrollment
     */
    omit?: EnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
    /**
     * Filter, which Enrollment to fetch.
     */
    where: EnrollmentWhereUniqueInput
  }

  /**
   * Enrollment findUniqueOrThrow
   */
  export type EnrollmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Enrollment
     */
    omit?: EnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
    /**
     * Filter, which Enrollment to fetch.
     */
    where: EnrollmentWhereUniqueInput
  }

  /**
   * Enrollment findFirst
   */
  export type EnrollmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Enrollment
     */
    omit?: EnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
    /**
     * Filter, which Enrollment to fetch.
     */
    where?: EnrollmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Enrollments to fetch.
     */
    orderBy?: EnrollmentOrderByWithRelationInput | EnrollmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Enrollments.
     */
    cursor?: EnrollmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Enrollments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Enrollments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Enrollments.
     */
    distinct?: EnrollmentScalarFieldEnum | EnrollmentScalarFieldEnum[]
  }

  /**
   * Enrollment findFirstOrThrow
   */
  export type EnrollmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Enrollment
     */
    omit?: EnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
    /**
     * Filter, which Enrollment to fetch.
     */
    where?: EnrollmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Enrollments to fetch.
     */
    orderBy?: EnrollmentOrderByWithRelationInput | EnrollmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Enrollments.
     */
    cursor?: EnrollmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Enrollments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Enrollments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Enrollments.
     */
    distinct?: EnrollmentScalarFieldEnum | EnrollmentScalarFieldEnum[]
  }

  /**
   * Enrollment findMany
   */
  export type EnrollmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Enrollment
     */
    omit?: EnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
    /**
     * Filter, which Enrollments to fetch.
     */
    where?: EnrollmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Enrollments to fetch.
     */
    orderBy?: EnrollmentOrderByWithRelationInput | EnrollmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Enrollments.
     */
    cursor?: EnrollmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Enrollments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Enrollments.
     */
    skip?: number
    distinct?: EnrollmentScalarFieldEnum | EnrollmentScalarFieldEnum[]
  }

  /**
   * Enrollment create
   */
  export type EnrollmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Enrollment
     */
    omit?: EnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Enrollment.
     */
    data: XOR<EnrollmentCreateInput, EnrollmentUncheckedCreateInput>
  }

  /**
   * Enrollment createMany
   */
  export type EnrollmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Enrollments.
     */
    data: EnrollmentCreateManyInput | EnrollmentCreateManyInput[]
  }

  /**
   * Enrollment update
   */
  export type EnrollmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Enrollment
     */
    omit?: EnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Enrollment.
     */
    data: XOR<EnrollmentUpdateInput, EnrollmentUncheckedUpdateInput>
    /**
     * Choose, which Enrollment to update.
     */
    where: EnrollmentWhereUniqueInput
  }

  /**
   * Enrollment updateMany
   */
  export type EnrollmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Enrollments.
     */
    data: XOR<EnrollmentUpdateManyMutationInput, EnrollmentUncheckedUpdateManyInput>
    /**
     * Filter which Enrollments to update
     */
    where?: EnrollmentWhereInput
    /**
     * Limit how many Enrollments to update.
     */
    limit?: number
  }

  /**
   * Enrollment upsert
   */
  export type EnrollmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Enrollment
     */
    omit?: EnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Enrollment to update in case it exists.
     */
    where: EnrollmentWhereUniqueInput
    /**
     * In case the Enrollment found by the `where` argument doesn't exist, create a new Enrollment with this data.
     */
    create: XOR<EnrollmentCreateInput, EnrollmentUncheckedCreateInput>
    /**
     * In case the Enrollment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EnrollmentUpdateInput, EnrollmentUncheckedUpdateInput>
  }

  /**
   * Enrollment delete
   */
  export type EnrollmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Enrollment
     */
    omit?: EnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
    /**
     * Filter which Enrollment to delete.
     */
    where: EnrollmentWhereUniqueInput
  }

  /**
   * Enrollment deleteMany
   */
  export type EnrollmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Enrollments to delete
     */
    where?: EnrollmentWhereInput
    /**
     * Limit how many Enrollments to delete.
     */
    limit?: number
  }

  /**
   * Enrollment findRaw
   */
  export type EnrollmentFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Enrollment aggregateRaw
   */
  export type EnrollmentAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Enrollment without action
   */
  export type EnrollmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Enrollment
     */
    omit?: EnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
  }


  /**
   * Model Attendance
   */

  export type AggregateAttendance = {
    _count: AttendanceCountAggregateOutputType | null
    _min: AttendanceMinAggregateOutputType | null
    _max: AttendanceMaxAggregateOutputType | null
  }

  export type AttendanceMinAggregateOutputType = {
    id: string | null
    studentId: string | null
    classId: string | null
    date: Date | null
    status: string | null
    remarks: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AttendanceMaxAggregateOutputType = {
    id: string | null
    studentId: string | null
    classId: string | null
    date: Date | null
    status: string | null
    remarks: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AttendanceCountAggregateOutputType = {
    id: number
    studentId: number
    classId: number
    date: number
    status: number
    remarks: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AttendanceMinAggregateInputType = {
    id?: true
    studentId?: true
    classId?: true
    date?: true
    status?: true
    remarks?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AttendanceMaxAggregateInputType = {
    id?: true
    studentId?: true
    classId?: true
    date?: true
    status?: true
    remarks?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AttendanceCountAggregateInputType = {
    id?: true
    studentId?: true
    classId?: true
    date?: true
    status?: true
    remarks?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AttendanceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Attendance to aggregate.
     */
    where?: AttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attendances to fetch.
     */
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attendances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Attendances
    **/
    _count?: true | AttendanceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AttendanceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AttendanceMaxAggregateInputType
  }

  export type GetAttendanceAggregateType<T extends AttendanceAggregateArgs> = {
        [P in keyof T & keyof AggregateAttendance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAttendance[P]>
      : GetScalarType<T[P], AggregateAttendance[P]>
  }




  export type AttendanceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceWhereInput
    orderBy?: AttendanceOrderByWithAggregationInput | AttendanceOrderByWithAggregationInput[]
    by: AttendanceScalarFieldEnum[] | AttendanceScalarFieldEnum
    having?: AttendanceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AttendanceCountAggregateInputType | true
    _min?: AttendanceMinAggregateInputType
    _max?: AttendanceMaxAggregateInputType
  }

  export type AttendanceGroupByOutputType = {
    id: string
    studentId: string
    classId: string
    date: Date
    status: string
    remarks: string | null
    createdAt: Date
    updatedAt: Date
    _count: AttendanceCountAggregateOutputType | null
    _min: AttendanceMinAggregateOutputType | null
    _max: AttendanceMaxAggregateOutputType | null
  }

  type GetAttendanceGroupByPayload<T extends AttendanceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AttendanceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AttendanceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AttendanceGroupByOutputType[P]>
            : GetScalarType<T[P], AttendanceGroupByOutputType[P]>
        }
      >
    >


  export type AttendanceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    classId?: boolean
    date?: boolean
    status?: boolean
    remarks?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    class?: boolean | ClassDefaultArgs<ExtArgs>
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attendance"]>



  export type AttendanceSelectScalar = {
    id?: boolean
    studentId?: boolean
    classId?: boolean
    date?: boolean
    status?: boolean
    remarks?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AttendanceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "studentId" | "classId" | "date" | "status" | "remarks" | "createdAt" | "updatedAt", ExtArgs["result"]["attendance"]>
  export type AttendanceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    class?: boolean | ClassDefaultArgs<ExtArgs>
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }

  export type $AttendancePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Attendance"
    objects: {
      class: Prisma.$ClassPayload<ExtArgs>
      student: Prisma.$StudentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      studentId: string
      classId: string
      date: Date
      status: string
      remarks: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["attendance"]>
    composites: {}
  }

  type AttendanceGetPayload<S extends boolean | null | undefined | AttendanceDefaultArgs> = $Result.GetResult<Prisma.$AttendancePayload, S>

  type AttendanceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AttendanceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AttendanceCountAggregateInputType | true
    }

  export interface AttendanceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Attendance'], meta: { name: 'Attendance' } }
    /**
     * Find zero or one Attendance that matches the filter.
     * @param {AttendanceFindUniqueArgs} args - Arguments to find a Attendance
     * @example
     * // Get one Attendance
     * const attendance = await prisma.attendance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AttendanceFindUniqueArgs>(args: SelectSubset<T, AttendanceFindUniqueArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Attendance that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AttendanceFindUniqueOrThrowArgs} args - Arguments to find a Attendance
     * @example
     * // Get one Attendance
     * const attendance = await prisma.attendance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AttendanceFindUniqueOrThrowArgs>(args: SelectSubset<T, AttendanceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Attendance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceFindFirstArgs} args - Arguments to find a Attendance
     * @example
     * // Get one Attendance
     * const attendance = await prisma.attendance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AttendanceFindFirstArgs>(args?: SelectSubset<T, AttendanceFindFirstArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Attendance that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceFindFirstOrThrowArgs} args - Arguments to find a Attendance
     * @example
     * // Get one Attendance
     * const attendance = await prisma.attendance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AttendanceFindFirstOrThrowArgs>(args?: SelectSubset<T, AttendanceFindFirstOrThrowArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Attendances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Attendances
     * const attendances = await prisma.attendance.findMany()
     * 
     * // Get first 10 Attendances
     * const attendances = await prisma.attendance.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const attendanceWithIdOnly = await prisma.attendance.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AttendanceFindManyArgs>(args?: SelectSubset<T, AttendanceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Attendance.
     * @param {AttendanceCreateArgs} args - Arguments to create a Attendance.
     * @example
     * // Create one Attendance
     * const Attendance = await prisma.attendance.create({
     *   data: {
     *     // ... data to create a Attendance
     *   }
     * })
     * 
     */
    create<T extends AttendanceCreateArgs>(args: SelectSubset<T, AttendanceCreateArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Attendances.
     * @param {AttendanceCreateManyArgs} args - Arguments to create many Attendances.
     * @example
     * // Create many Attendances
     * const attendance = await prisma.attendance.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AttendanceCreateManyArgs>(args?: SelectSubset<T, AttendanceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Attendance.
     * @param {AttendanceDeleteArgs} args - Arguments to delete one Attendance.
     * @example
     * // Delete one Attendance
     * const Attendance = await prisma.attendance.delete({
     *   where: {
     *     // ... filter to delete one Attendance
     *   }
     * })
     * 
     */
    delete<T extends AttendanceDeleteArgs>(args: SelectSubset<T, AttendanceDeleteArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Attendance.
     * @param {AttendanceUpdateArgs} args - Arguments to update one Attendance.
     * @example
     * // Update one Attendance
     * const attendance = await prisma.attendance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AttendanceUpdateArgs>(args: SelectSubset<T, AttendanceUpdateArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Attendances.
     * @param {AttendanceDeleteManyArgs} args - Arguments to filter Attendances to delete.
     * @example
     * // Delete a few Attendances
     * const { count } = await prisma.attendance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AttendanceDeleteManyArgs>(args?: SelectSubset<T, AttendanceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Attendances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Attendances
     * const attendance = await prisma.attendance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AttendanceUpdateManyArgs>(args: SelectSubset<T, AttendanceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Attendance.
     * @param {AttendanceUpsertArgs} args - Arguments to update or create a Attendance.
     * @example
     * // Update or create a Attendance
     * const attendance = await prisma.attendance.upsert({
     *   create: {
     *     // ... data to create a Attendance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Attendance we want to update
     *   }
     * })
     */
    upsert<T extends AttendanceUpsertArgs>(args: SelectSubset<T, AttendanceUpsertArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Attendances that matches the filter.
     * @param {AttendanceFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const attendance = await prisma.attendance.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: AttendanceFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Attendance.
     * @param {AttendanceAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const attendance = await prisma.attendance.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: AttendanceAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Attendances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceCountArgs} args - Arguments to filter Attendances to count.
     * @example
     * // Count the number of Attendances
     * const count = await prisma.attendance.count({
     *   where: {
     *     // ... the filter for the Attendances we want to count
     *   }
     * })
    **/
    count<T extends AttendanceCountArgs>(
      args?: Subset<T, AttendanceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AttendanceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Attendance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AttendanceAggregateArgs>(args: Subset<T, AttendanceAggregateArgs>): Prisma.PrismaPromise<GetAttendanceAggregateType<T>>

    /**
     * Group by Attendance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AttendanceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AttendanceGroupByArgs['orderBy'] }
        : { orderBy?: AttendanceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AttendanceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAttendanceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Attendance model
   */
  readonly fields: AttendanceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Attendance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AttendanceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    class<T extends ClassDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClassDefaultArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Attendance model
   */
  interface AttendanceFieldRefs {
    readonly id: FieldRef<"Attendance", 'String'>
    readonly studentId: FieldRef<"Attendance", 'String'>
    readonly classId: FieldRef<"Attendance", 'String'>
    readonly date: FieldRef<"Attendance", 'DateTime'>
    readonly status: FieldRef<"Attendance", 'String'>
    readonly remarks: FieldRef<"Attendance", 'String'>
    readonly createdAt: FieldRef<"Attendance", 'DateTime'>
    readonly updatedAt: FieldRef<"Attendance", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Attendance findUnique
   */
  export type AttendanceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter, which Attendance to fetch.
     */
    where: AttendanceWhereUniqueInput
  }

  /**
   * Attendance findUniqueOrThrow
   */
  export type AttendanceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter, which Attendance to fetch.
     */
    where: AttendanceWhereUniqueInput
  }

  /**
   * Attendance findFirst
   */
  export type AttendanceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter, which Attendance to fetch.
     */
    where?: AttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attendances to fetch.
     */
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Attendances.
     */
    cursor?: AttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attendances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Attendances.
     */
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[]
  }

  /**
   * Attendance findFirstOrThrow
   */
  export type AttendanceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter, which Attendance to fetch.
     */
    where?: AttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attendances to fetch.
     */
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Attendances.
     */
    cursor?: AttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attendances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Attendances.
     */
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[]
  }

  /**
   * Attendance findMany
   */
  export type AttendanceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter, which Attendances to fetch.
     */
    where?: AttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attendances to fetch.
     */
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Attendances.
     */
    cursor?: AttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attendances.
     */
    skip?: number
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[]
  }

  /**
   * Attendance create
   */
  export type AttendanceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * The data needed to create a Attendance.
     */
    data: XOR<AttendanceCreateInput, AttendanceUncheckedCreateInput>
  }

  /**
   * Attendance createMany
   */
  export type AttendanceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Attendances.
     */
    data: AttendanceCreateManyInput | AttendanceCreateManyInput[]
  }

  /**
   * Attendance update
   */
  export type AttendanceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * The data needed to update a Attendance.
     */
    data: XOR<AttendanceUpdateInput, AttendanceUncheckedUpdateInput>
    /**
     * Choose, which Attendance to update.
     */
    where: AttendanceWhereUniqueInput
  }

  /**
   * Attendance updateMany
   */
  export type AttendanceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Attendances.
     */
    data: XOR<AttendanceUpdateManyMutationInput, AttendanceUncheckedUpdateManyInput>
    /**
     * Filter which Attendances to update
     */
    where?: AttendanceWhereInput
    /**
     * Limit how many Attendances to update.
     */
    limit?: number
  }

  /**
   * Attendance upsert
   */
  export type AttendanceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * The filter to search for the Attendance to update in case it exists.
     */
    where: AttendanceWhereUniqueInput
    /**
     * In case the Attendance found by the `where` argument doesn't exist, create a new Attendance with this data.
     */
    create: XOR<AttendanceCreateInput, AttendanceUncheckedCreateInput>
    /**
     * In case the Attendance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AttendanceUpdateInput, AttendanceUncheckedUpdateInput>
  }

  /**
   * Attendance delete
   */
  export type AttendanceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter which Attendance to delete.
     */
    where: AttendanceWhereUniqueInput
  }

  /**
   * Attendance deleteMany
   */
  export type AttendanceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Attendances to delete
     */
    where?: AttendanceWhereInput
    /**
     * Limit how many Attendances to delete.
     */
    limit?: number
  }

  /**
   * Attendance findRaw
   */
  export type AttendanceFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Attendance aggregateRaw
   */
  export type AttendanceAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Attendance without action
   */
  export type AttendanceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
  }


  /**
   * Model Grade
   */

  export type AggregateGrade = {
    _count: GradeCountAggregateOutputType | null
    _avg: GradeAvgAggregateOutputType | null
    _sum: GradeSumAggregateOutputType | null
    _min: GradeMinAggregateOutputType | null
    _max: GradeMaxAggregateOutputType | null
  }

  export type GradeAvgAggregateOutputType = {
    score: number | null
    maxScore: number | null
  }

  export type GradeSumAggregateOutputType = {
    score: number | null
    maxScore: number | null
  }

  export type GradeMinAggregateOutputType = {
    id: string | null
    studentId: string | null
    subject: string | null
    examType: string | null
    score: number | null
    maxScore: number | null
    grade: string | null
    term: string | null
    academicYear: string | null
    remarks: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GradeMaxAggregateOutputType = {
    id: string | null
    studentId: string | null
    subject: string | null
    examType: string | null
    score: number | null
    maxScore: number | null
    grade: string | null
    term: string | null
    academicYear: string | null
    remarks: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GradeCountAggregateOutputType = {
    id: number
    studentId: number
    subject: number
    examType: number
    score: number
    maxScore: number
    grade: number
    term: number
    academicYear: number
    remarks: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type GradeAvgAggregateInputType = {
    score?: true
    maxScore?: true
  }

  export type GradeSumAggregateInputType = {
    score?: true
    maxScore?: true
  }

  export type GradeMinAggregateInputType = {
    id?: true
    studentId?: true
    subject?: true
    examType?: true
    score?: true
    maxScore?: true
    grade?: true
    term?: true
    academicYear?: true
    remarks?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GradeMaxAggregateInputType = {
    id?: true
    studentId?: true
    subject?: true
    examType?: true
    score?: true
    maxScore?: true
    grade?: true
    term?: true
    academicYear?: true
    remarks?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GradeCountAggregateInputType = {
    id?: true
    studentId?: true
    subject?: true
    examType?: true
    score?: true
    maxScore?: true
    grade?: true
    term?: true
    academicYear?: true
    remarks?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type GradeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Grade to aggregate.
     */
    where?: GradeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Grades to fetch.
     */
    orderBy?: GradeOrderByWithRelationInput | GradeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GradeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Grades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Grades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Grades
    **/
    _count?: true | GradeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GradeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GradeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GradeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GradeMaxAggregateInputType
  }

  export type GetGradeAggregateType<T extends GradeAggregateArgs> = {
        [P in keyof T & keyof AggregateGrade]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGrade[P]>
      : GetScalarType<T[P], AggregateGrade[P]>
  }




  export type GradeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GradeWhereInput
    orderBy?: GradeOrderByWithAggregationInput | GradeOrderByWithAggregationInput[]
    by: GradeScalarFieldEnum[] | GradeScalarFieldEnum
    having?: GradeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GradeCountAggregateInputType | true
    _avg?: GradeAvgAggregateInputType
    _sum?: GradeSumAggregateInputType
    _min?: GradeMinAggregateInputType
    _max?: GradeMaxAggregateInputType
  }

  export type GradeGroupByOutputType = {
    id: string
    studentId: string
    subject: string
    examType: string | null
    score: number
    maxScore: number
    grade: string | null
    term: string
    academicYear: string
    remarks: string | null
    createdAt: Date
    updatedAt: Date
    _count: GradeCountAggregateOutputType | null
    _avg: GradeAvgAggregateOutputType | null
    _sum: GradeSumAggregateOutputType | null
    _min: GradeMinAggregateOutputType | null
    _max: GradeMaxAggregateOutputType | null
  }

  type GetGradeGroupByPayload<T extends GradeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GradeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GradeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GradeGroupByOutputType[P]>
            : GetScalarType<T[P], GradeGroupByOutputType[P]>
        }
      >
    >


  export type GradeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    subject?: boolean
    examType?: boolean
    score?: boolean
    maxScore?: boolean
    grade?: boolean
    term?: boolean
    academicYear?: boolean
    remarks?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["grade"]>



  export type GradeSelectScalar = {
    id?: boolean
    studentId?: boolean
    subject?: boolean
    examType?: boolean
    score?: boolean
    maxScore?: boolean
    grade?: boolean
    term?: boolean
    academicYear?: boolean
    remarks?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type GradeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "studentId" | "subject" | "examType" | "score" | "maxScore" | "grade" | "term" | "academicYear" | "remarks" | "createdAt" | "updatedAt", ExtArgs["result"]["grade"]>
  export type GradeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }

  export type $GradePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Grade"
    objects: {
      student: Prisma.$StudentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      studentId: string
      subject: string
      examType: string | null
      score: number
      maxScore: number
      grade: string | null
      term: string
      academicYear: string
      remarks: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["grade"]>
    composites: {}
  }

  type GradeGetPayload<S extends boolean | null | undefined | GradeDefaultArgs> = $Result.GetResult<Prisma.$GradePayload, S>

  type GradeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GradeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GradeCountAggregateInputType | true
    }

  export interface GradeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Grade'], meta: { name: 'Grade' } }
    /**
     * Find zero or one Grade that matches the filter.
     * @param {GradeFindUniqueArgs} args - Arguments to find a Grade
     * @example
     * // Get one Grade
     * const grade = await prisma.grade.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GradeFindUniqueArgs>(args: SelectSubset<T, GradeFindUniqueArgs<ExtArgs>>): Prisma__GradeClient<$Result.GetResult<Prisma.$GradePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Grade that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GradeFindUniqueOrThrowArgs} args - Arguments to find a Grade
     * @example
     * // Get one Grade
     * const grade = await prisma.grade.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GradeFindUniqueOrThrowArgs>(args: SelectSubset<T, GradeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GradeClient<$Result.GetResult<Prisma.$GradePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Grade that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradeFindFirstArgs} args - Arguments to find a Grade
     * @example
     * // Get one Grade
     * const grade = await prisma.grade.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GradeFindFirstArgs>(args?: SelectSubset<T, GradeFindFirstArgs<ExtArgs>>): Prisma__GradeClient<$Result.GetResult<Prisma.$GradePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Grade that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradeFindFirstOrThrowArgs} args - Arguments to find a Grade
     * @example
     * // Get one Grade
     * const grade = await prisma.grade.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GradeFindFirstOrThrowArgs>(args?: SelectSubset<T, GradeFindFirstOrThrowArgs<ExtArgs>>): Prisma__GradeClient<$Result.GetResult<Prisma.$GradePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Grades that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Grades
     * const grades = await prisma.grade.findMany()
     * 
     * // Get first 10 Grades
     * const grades = await prisma.grade.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gradeWithIdOnly = await prisma.grade.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GradeFindManyArgs>(args?: SelectSubset<T, GradeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GradePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Grade.
     * @param {GradeCreateArgs} args - Arguments to create a Grade.
     * @example
     * // Create one Grade
     * const Grade = await prisma.grade.create({
     *   data: {
     *     // ... data to create a Grade
     *   }
     * })
     * 
     */
    create<T extends GradeCreateArgs>(args: SelectSubset<T, GradeCreateArgs<ExtArgs>>): Prisma__GradeClient<$Result.GetResult<Prisma.$GradePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Grades.
     * @param {GradeCreateManyArgs} args - Arguments to create many Grades.
     * @example
     * // Create many Grades
     * const grade = await prisma.grade.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GradeCreateManyArgs>(args?: SelectSubset<T, GradeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Grade.
     * @param {GradeDeleteArgs} args - Arguments to delete one Grade.
     * @example
     * // Delete one Grade
     * const Grade = await prisma.grade.delete({
     *   where: {
     *     // ... filter to delete one Grade
     *   }
     * })
     * 
     */
    delete<T extends GradeDeleteArgs>(args: SelectSubset<T, GradeDeleteArgs<ExtArgs>>): Prisma__GradeClient<$Result.GetResult<Prisma.$GradePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Grade.
     * @param {GradeUpdateArgs} args - Arguments to update one Grade.
     * @example
     * // Update one Grade
     * const grade = await prisma.grade.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GradeUpdateArgs>(args: SelectSubset<T, GradeUpdateArgs<ExtArgs>>): Prisma__GradeClient<$Result.GetResult<Prisma.$GradePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Grades.
     * @param {GradeDeleteManyArgs} args - Arguments to filter Grades to delete.
     * @example
     * // Delete a few Grades
     * const { count } = await prisma.grade.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GradeDeleteManyArgs>(args?: SelectSubset<T, GradeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Grades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Grades
     * const grade = await prisma.grade.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GradeUpdateManyArgs>(args: SelectSubset<T, GradeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Grade.
     * @param {GradeUpsertArgs} args - Arguments to update or create a Grade.
     * @example
     * // Update or create a Grade
     * const grade = await prisma.grade.upsert({
     *   create: {
     *     // ... data to create a Grade
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Grade we want to update
     *   }
     * })
     */
    upsert<T extends GradeUpsertArgs>(args: SelectSubset<T, GradeUpsertArgs<ExtArgs>>): Prisma__GradeClient<$Result.GetResult<Prisma.$GradePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Grades that matches the filter.
     * @param {GradeFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const grade = await prisma.grade.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: GradeFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Grade.
     * @param {GradeAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const grade = await prisma.grade.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: GradeAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Grades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradeCountArgs} args - Arguments to filter Grades to count.
     * @example
     * // Count the number of Grades
     * const count = await prisma.grade.count({
     *   where: {
     *     // ... the filter for the Grades we want to count
     *   }
     * })
    **/
    count<T extends GradeCountArgs>(
      args?: Subset<T, GradeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GradeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Grade.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GradeAggregateArgs>(args: Subset<T, GradeAggregateArgs>): Prisma.PrismaPromise<GetGradeAggregateType<T>>

    /**
     * Group by Grade.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GradeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GradeGroupByArgs['orderBy'] }
        : { orderBy?: GradeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GradeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGradeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Grade model
   */
  readonly fields: GradeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Grade.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GradeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Grade model
   */
  interface GradeFieldRefs {
    readonly id: FieldRef<"Grade", 'String'>
    readonly studentId: FieldRef<"Grade", 'String'>
    readonly subject: FieldRef<"Grade", 'String'>
    readonly examType: FieldRef<"Grade", 'String'>
    readonly score: FieldRef<"Grade", 'Float'>
    readonly maxScore: FieldRef<"Grade", 'Float'>
    readonly grade: FieldRef<"Grade", 'String'>
    readonly term: FieldRef<"Grade", 'String'>
    readonly academicYear: FieldRef<"Grade", 'String'>
    readonly remarks: FieldRef<"Grade", 'String'>
    readonly createdAt: FieldRef<"Grade", 'DateTime'>
    readonly updatedAt: FieldRef<"Grade", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Grade findUnique
   */
  export type GradeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grade
     */
    select?: GradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Grade
     */
    omit?: GradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeInclude<ExtArgs> | null
    /**
     * Filter, which Grade to fetch.
     */
    where: GradeWhereUniqueInput
  }

  /**
   * Grade findUniqueOrThrow
   */
  export type GradeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grade
     */
    select?: GradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Grade
     */
    omit?: GradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeInclude<ExtArgs> | null
    /**
     * Filter, which Grade to fetch.
     */
    where: GradeWhereUniqueInput
  }

  /**
   * Grade findFirst
   */
  export type GradeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grade
     */
    select?: GradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Grade
     */
    omit?: GradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeInclude<ExtArgs> | null
    /**
     * Filter, which Grade to fetch.
     */
    where?: GradeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Grades to fetch.
     */
    orderBy?: GradeOrderByWithRelationInput | GradeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Grades.
     */
    cursor?: GradeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Grades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Grades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Grades.
     */
    distinct?: GradeScalarFieldEnum | GradeScalarFieldEnum[]
  }

  /**
   * Grade findFirstOrThrow
   */
  export type GradeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grade
     */
    select?: GradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Grade
     */
    omit?: GradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeInclude<ExtArgs> | null
    /**
     * Filter, which Grade to fetch.
     */
    where?: GradeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Grades to fetch.
     */
    orderBy?: GradeOrderByWithRelationInput | GradeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Grades.
     */
    cursor?: GradeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Grades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Grades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Grades.
     */
    distinct?: GradeScalarFieldEnum | GradeScalarFieldEnum[]
  }

  /**
   * Grade findMany
   */
  export type GradeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grade
     */
    select?: GradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Grade
     */
    omit?: GradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeInclude<ExtArgs> | null
    /**
     * Filter, which Grades to fetch.
     */
    where?: GradeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Grades to fetch.
     */
    orderBy?: GradeOrderByWithRelationInput | GradeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Grades.
     */
    cursor?: GradeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Grades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Grades.
     */
    skip?: number
    distinct?: GradeScalarFieldEnum | GradeScalarFieldEnum[]
  }

  /**
   * Grade create
   */
  export type GradeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grade
     */
    select?: GradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Grade
     */
    omit?: GradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeInclude<ExtArgs> | null
    /**
     * The data needed to create a Grade.
     */
    data: XOR<GradeCreateInput, GradeUncheckedCreateInput>
  }

  /**
   * Grade createMany
   */
  export type GradeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Grades.
     */
    data: GradeCreateManyInput | GradeCreateManyInput[]
  }

  /**
   * Grade update
   */
  export type GradeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grade
     */
    select?: GradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Grade
     */
    omit?: GradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeInclude<ExtArgs> | null
    /**
     * The data needed to update a Grade.
     */
    data: XOR<GradeUpdateInput, GradeUncheckedUpdateInput>
    /**
     * Choose, which Grade to update.
     */
    where: GradeWhereUniqueInput
  }

  /**
   * Grade updateMany
   */
  export type GradeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Grades.
     */
    data: XOR<GradeUpdateManyMutationInput, GradeUncheckedUpdateManyInput>
    /**
     * Filter which Grades to update
     */
    where?: GradeWhereInput
    /**
     * Limit how many Grades to update.
     */
    limit?: number
  }

  /**
   * Grade upsert
   */
  export type GradeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grade
     */
    select?: GradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Grade
     */
    omit?: GradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeInclude<ExtArgs> | null
    /**
     * The filter to search for the Grade to update in case it exists.
     */
    where: GradeWhereUniqueInput
    /**
     * In case the Grade found by the `where` argument doesn't exist, create a new Grade with this data.
     */
    create: XOR<GradeCreateInput, GradeUncheckedCreateInput>
    /**
     * In case the Grade was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GradeUpdateInput, GradeUncheckedUpdateInput>
  }

  /**
   * Grade delete
   */
  export type GradeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grade
     */
    select?: GradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Grade
     */
    omit?: GradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeInclude<ExtArgs> | null
    /**
     * Filter which Grade to delete.
     */
    where: GradeWhereUniqueInput
  }

  /**
   * Grade deleteMany
   */
  export type GradeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Grades to delete
     */
    where?: GradeWhereInput
    /**
     * Limit how many Grades to delete.
     */
    limit?: number
  }

  /**
   * Grade findRaw
   */
  export type GradeFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Grade aggregateRaw
   */
  export type GradeAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Grade without action
   */
  export type GradeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grade
     */
    select?: GradeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Grade
     */
    omit?: GradeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeInclude<ExtArgs> | null
  }


  /**
   * Model Timetable
   */

  export type AggregateTimetable = {
    _count: TimetableCountAggregateOutputType | null
    _avg: TimetableAvgAggregateOutputType | null
    _sum: TimetableSumAggregateOutputType | null
    _min: TimetableMinAggregateOutputType | null
    _max: TimetableMaxAggregateOutputType | null
  }

  export type TimetableAvgAggregateOutputType = {
    dayOfWeek: number | null
  }

  export type TimetableSumAggregateOutputType = {
    dayOfWeek: number | null
  }

  export type TimetableMinAggregateOutputType = {
    id: string | null
    classId: string | null
    dayOfWeek: number | null
    startTime: string | null
    endTime: string | null
    subject: string | null
    teacherId: string | null
    room: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TimetableMaxAggregateOutputType = {
    id: string | null
    classId: string | null
    dayOfWeek: number | null
    startTime: string | null
    endTime: string | null
    subject: string | null
    teacherId: string | null
    room: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TimetableCountAggregateOutputType = {
    id: number
    classId: number
    dayOfWeek: number
    startTime: number
    endTime: number
    subject: number
    teacherId: number
    room: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TimetableAvgAggregateInputType = {
    dayOfWeek?: true
  }

  export type TimetableSumAggregateInputType = {
    dayOfWeek?: true
  }

  export type TimetableMinAggregateInputType = {
    id?: true
    classId?: true
    dayOfWeek?: true
    startTime?: true
    endTime?: true
    subject?: true
    teacherId?: true
    room?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TimetableMaxAggregateInputType = {
    id?: true
    classId?: true
    dayOfWeek?: true
    startTime?: true
    endTime?: true
    subject?: true
    teacherId?: true
    room?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TimetableCountAggregateInputType = {
    id?: true
    classId?: true
    dayOfWeek?: true
    startTime?: true
    endTime?: true
    subject?: true
    teacherId?: true
    room?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TimetableAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Timetable to aggregate.
     */
    where?: TimetableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Timetables to fetch.
     */
    orderBy?: TimetableOrderByWithRelationInput | TimetableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TimetableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Timetables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Timetables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Timetables
    **/
    _count?: true | TimetableCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TimetableAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TimetableSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TimetableMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TimetableMaxAggregateInputType
  }

  export type GetTimetableAggregateType<T extends TimetableAggregateArgs> = {
        [P in keyof T & keyof AggregateTimetable]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTimetable[P]>
      : GetScalarType<T[P], AggregateTimetable[P]>
  }




  export type TimetableGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TimetableWhereInput
    orderBy?: TimetableOrderByWithAggregationInput | TimetableOrderByWithAggregationInput[]
    by: TimetableScalarFieldEnum[] | TimetableScalarFieldEnum
    having?: TimetableScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TimetableCountAggregateInputType | true
    _avg?: TimetableAvgAggregateInputType
    _sum?: TimetableSumAggregateInputType
    _min?: TimetableMinAggregateInputType
    _max?: TimetableMaxAggregateInputType
  }

  export type TimetableGroupByOutputType = {
    id: string
    classId: string
    dayOfWeek: number
    startTime: string
    endTime: string
    subject: string
    teacherId: string | null
    room: string | null
    createdAt: Date
    updatedAt: Date
    _count: TimetableCountAggregateOutputType | null
    _avg: TimetableAvgAggregateOutputType | null
    _sum: TimetableSumAggregateOutputType | null
    _min: TimetableMinAggregateOutputType | null
    _max: TimetableMaxAggregateOutputType | null
  }

  type GetTimetableGroupByPayload<T extends TimetableGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TimetableGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TimetableGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TimetableGroupByOutputType[P]>
            : GetScalarType<T[P], TimetableGroupByOutputType[P]>
        }
      >
    >


  export type TimetableSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    classId?: boolean
    dayOfWeek?: boolean
    startTime?: boolean
    endTime?: boolean
    subject?: boolean
    teacherId?: boolean
    room?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    class?: boolean | ClassDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["timetable"]>



  export type TimetableSelectScalar = {
    id?: boolean
    classId?: boolean
    dayOfWeek?: boolean
    startTime?: boolean
    endTime?: boolean
    subject?: boolean
    teacherId?: boolean
    room?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TimetableOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "classId" | "dayOfWeek" | "startTime" | "endTime" | "subject" | "teacherId" | "room" | "createdAt" | "updatedAt", ExtArgs["result"]["timetable"]>
  export type TimetableInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    class?: boolean | ClassDefaultArgs<ExtArgs>
  }

  export type $TimetablePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Timetable"
    objects: {
      class: Prisma.$ClassPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      classId: string
      dayOfWeek: number
      startTime: string
      endTime: string
      subject: string
      teacherId: string | null
      room: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["timetable"]>
    composites: {}
  }

  type TimetableGetPayload<S extends boolean | null | undefined | TimetableDefaultArgs> = $Result.GetResult<Prisma.$TimetablePayload, S>

  type TimetableCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TimetableFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TimetableCountAggregateInputType | true
    }

  export interface TimetableDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Timetable'], meta: { name: 'Timetable' } }
    /**
     * Find zero or one Timetable that matches the filter.
     * @param {TimetableFindUniqueArgs} args - Arguments to find a Timetable
     * @example
     * // Get one Timetable
     * const timetable = await prisma.timetable.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TimetableFindUniqueArgs>(args: SelectSubset<T, TimetableFindUniqueArgs<ExtArgs>>): Prisma__TimetableClient<$Result.GetResult<Prisma.$TimetablePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Timetable that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TimetableFindUniqueOrThrowArgs} args - Arguments to find a Timetable
     * @example
     * // Get one Timetable
     * const timetable = await prisma.timetable.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TimetableFindUniqueOrThrowArgs>(args: SelectSubset<T, TimetableFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TimetableClient<$Result.GetResult<Prisma.$TimetablePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Timetable that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimetableFindFirstArgs} args - Arguments to find a Timetable
     * @example
     * // Get one Timetable
     * const timetable = await prisma.timetable.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TimetableFindFirstArgs>(args?: SelectSubset<T, TimetableFindFirstArgs<ExtArgs>>): Prisma__TimetableClient<$Result.GetResult<Prisma.$TimetablePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Timetable that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimetableFindFirstOrThrowArgs} args - Arguments to find a Timetable
     * @example
     * // Get one Timetable
     * const timetable = await prisma.timetable.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TimetableFindFirstOrThrowArgs>(args?: SelectSubset<T, TimetableFindFirstOrThrowArgs<ExtArgs>>): Prisma__TimetableClient<$Result.GetResult<Prisma.$TimetablePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Timetables that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimetableFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Timetables
     * const timetables = await prisma.timetable.findMany()
     * 
     * // Get first 10 Timetables
     * const timetables = await prisma.timetable.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const timetableWithIdOnly = await prisma.timetable.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TimetableFindManyArgs>(args?: SelectSubset<T, TimetableFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimetablePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Timetable.
     * @param {TimetableCreateArgs} args - Arguments to create a Timetable.
     * @example
     * // Create one Timetable
     * const Timetable = await prisma.timetable.create({
     *   data: {
     *     // ... data to create a Timetable
     *   }
     * })
     * 
     */
    create<T extends TimetableCreateArgs>(args: SelectSubset<T, TimetableCreateArgs<ExtArgs>>): Prisma__TimetableClient<$Result.GetResult<Prisma.$TimetablePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Timetables.
     * @param {TimetableCreateManyArgs} args - Arguments to create many Timetables.
     * @example
     * // Create many Timetables
     * const timetable = await prisma.timetable.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TimetableCreateManyArgs>(args?: SelectSubset<T, TimetableCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Timetable.
     * @param {TimetableDeleteArgs} args - Arguments to delete one Timetable.
     * @example
     * // Delete one Timetable
     * const Timetable = await prisma.timetable.delete({
     *   where: {
     *     // ... filter to delete one Timetable
     *   }
     * })
     * 
     */
    delete<T extends TimetableDeleteArgs>(args: SelectSubset<T, TimetableDeleteArgs<ExtArgs>>): Prisma__TimetableClient<$Result.GetResult<Prisma.$TimetablePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Timetable.
     * @param {TimetableUpdateArgs} args - Arguments to update one Timetable.
     * @example
     * // Update one Timetable
     * const timetable = await prisma.timetable.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TimetableUpdateArgs>(args: SelectSubset<T, TimetableUpdateArgs<ExtArgs>>): Prisma__TimetableClient<$Result.GetResult<Prisma.$TimetablePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Timetables.
     * @param {TimetableDeleteManyArgs} args - Arguments to filter Timetables to delete.
     * @example
     * // Delete a few Timetables
     * const { count } = await prisma.timetable.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TimetableDeleteManyArgs>(args?: SelectSubset<T, TimetableDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Timetables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimetableUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Timetables
     * const timetable = await prisma.timetable.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TimetableUpdateManyArgs>(args: SelectSubset<T, TimetableUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Timetable.
     * @param {TimetableUpsertArgs} args - Arguments to update or create a Timetable.
     * @example
     * // Update or create a Timetable
     * const timetable = await prisma.timetable.upsert({
     *   create: {
     *     // ... data to create a Timetable
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Timetable we want to update
     *   }
     * })
     */
    upsert<T extends TimetableUpsertArgs>(args: SelectSubset<T, TimetableUpsertArgs<ExtArgs>>): Prisma__TimetableClient<$Result.GetResult<Prisma.$TimetablePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Timetables that matches the filter.
     * @param {TimetableFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const timetable = await prisma.timetable.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: TimetableFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Timetable.
     * @param {TimetableAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const timetable = await prisma.timetable.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: TimetableAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Timetables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimetableCountArgs} args - Arguments to filter Timetables to count.
     * @example
     * // Count the number of Timetables
     * const count = await prisma.timetable.count({
     *   where: {
     *     // ... the filter for the Timetables we want to count
     *   }
     * })
    **/
    count<T extends TimetableCountArgs>(
      args?: Subset<T, TimetableCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TimetableCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Timetable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimetableAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TimetableAggregateArgs>(args: Subset<T, TimetableAggregateArgs>): Prisma.PrismaPromise<GetTimetableAggregateType<T>>

    /**
     * Group by Timetable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimetableGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TimetableGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TimetableGroupByArgs['orderBy'] }
        : { orderBy?: TimetableGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TimetableGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTimetableGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Timetable model
   */
  readonly fields: TimetableFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Timetable.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TimetableClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    class<T extends ClassDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClassDefaultArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Timetable model
   */
  interface TimetableFieldRefs {
    readonly id: FieldRef<"Timetable", 'String'>
    readonly classId: FieldRef<"Timetable", 'String'>
    readonly dayOfWeek: FieldRef<"Timetable", 'Int'>
    readonly startTime: FieldRef<"Timetable", 'String'>
    readonly endTime: FieldRef<"Timetable", 'String'>
    readonly subject: FieldRef<"Timetable", 'String'>
    readonly teacherId: FieldRef<"Timetable", 'String'>
    readonly room: FieldRef<"Timetable", 'String'>
    readonly createdAt: FieldRef<"Timetable", 'DateTime'>
    readonly updatedAt: FieldRef<"Timetable", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Timetable findUnique
   */
  export type TimetableFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Timetable
     */
    select?: TimetableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Timetable
     */
    omit?: TimetableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimetableInclude<ExtArgs> | null
    /**
     * Filter, which Timetable to fetch.
     */
    where: TimetableWhereUniqueInput
  }

  /**
   * Timetable findUniqueOrThrow
   */
  export type TimetableFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Timetable
     */
    select?: TimetableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Timetable
     */
    omit?: TimetableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimetableInclude<ExtArgs> | null
    /**
     * Filter, which Timetable to fetch.
     */
    where: TimetableWhereUniqueInput
  }

  /**
   * Timetable findFirst
   */
  export type TimetableFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Timetable
     */
    select?: TimetableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Timetable
     */
    omit?: TimetableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimetableInclude<ExtArgs> | null
    /**
     * Filter, which Timetable to fetch.
     */
    where?: TimetableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Timetables to fetch.
     */
    orderBy?: TimetableOrderByWithRelationInput | TimetableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Timetables.
     */
    cursor?: TimetableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Timetables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Timetables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Timetables.
     */
    distinct?: TimetableScalarFieldEnum | TimetableScalarFieldEnum[]
  }

  /**
   * Timetable findFirstOrThrow
   */
  export type TimetableFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Timetable
     */
    select?: TimetableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Timetable
     */
    omit?: TimetableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimetableInclude<ExtArgs> | null
    /**
     * Filter, which Timetable to fetch.
     */
    where?: TimetableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Timetables to fetch.
     */
    orderBy?: TimetableOrderByWithRelationInput | TimetableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Timetables.
     */
    cursor?: TimetableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Timetables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Timetables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Timetables.
     */
    distinct?: TimetableScalarFieldEnum | TimetableScalarFieldEnum[]
  }

  /**
   * Timetable findMany
   */
  export type TimetableFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Timetable
     */
    select?: TimetableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Timetable
     */
    omit?: TimetableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimetableInclude<ExtArgs> | null
    /**
     * Filter, which Timetables to fetch.
     */
    where?: TimetableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Timetables to fetch.
     */
    orderBy?: TimetableOrderByWithRelationInput | TimetableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Timetables.
     */
    cursor?: TimetableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Timetables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Timetables.
     */
    skip?: number
    distinct?: TimetableScalarFieldEnum | TimetableScalarFieldEnum[]
  }

  /**
   * Timetable create
   */
  export type TimetableCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Timetable
     */
    select?: TimetableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Timetable
     */
    omit?: TimetableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimetableInclude<ExtArgs> | null
    /**
     * The data needed to create a Timetable.
     */
    data: XOR<TimetableCreateInput, TimetableUncheckedCreateInput>
  }

  /**
   * Timetable createMany
   */
  export type TimetableCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Timetables.
     */
    data: TimetableCreateManyInput | TimetableCreateManyInput[]
  }

  /**
   * Timetable update
   */
  export type TimetableUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Timetable
     */
    select?: TimetableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Timetable
     */
    omit?: TimetableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimetableInclude<ExtArgs> | null
    /**
     * The data needed to update a Timetable.
     */
    data: XOR<TimetableUpdateInput, TimetableUncheckedUpdateInput>
    /**
     * Choose, which Timetable to update.
     */
    where: TimetableWhereUniqueInput
  }

  /**
   * Timetable updateMany
   */
  export type TimetableUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Timetables.
     */
    data: XOR<TimetableUpdateManyMutationInput, TimetableUncheckedUpdateManyInput>
    /**
     * Filter which Timetables to update
     */
    where?: TimetableWhereInput
    /**
     * Limit how many Timetables to update.
     */
    limit?: number
  }

  /**
   * Timetable upsert
   */
  export type TimetableUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Timetable
     */
    select?: TimetableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Timetable
     */
    omit?: TimetableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimetableInclude<ExtArgs> | null
    /**
     * The filter to search for the Timetable to update in case it exists.
     */
    where: TimetableWhereUniqueInput
    /**
     * In case the Timetable found by the `where` argument doesn't exist, create a new Timetable with this data.
     */
    create: XOR<TimetableCreateInput, TimetableUncheckedCreateInput>
    /**
     * In case the Timetable was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TimetableUpdateInput, TimetableUncheckedUpdateInput>
  }

  /**
   * Timetable delete
   */
  export type TimetableDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Timetable
     */
    select?: TimetableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Timetable
     */
    omit?: TimetableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimetableInclude<ExtArgs> | null
    /**
     * Filter which Timetable to delete.
     */
    where: TimetableWhereUniqueInput
  }

  /**
   * Timetable deleteMany
   */
  export type TimetableDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Timetables to delete
     */
    where?: TimetableWhereInput
    /**
     * Limit how many Timetables to delete.
     */
    limit?: number
  }

  /**
   * Timetable findRaw
   */
  export type TimetableFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Timetable aggregateRaw
   */
  export type TimetableAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Timetable without action
   */
  export type TimetableDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Timetable
     */
    select?: TimetableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Timetable
     */
    omit?: TimetableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimetableInclude<ExtArgs> | null
  }


  /**
   * Model Invoice
   */

  export type AggregateInvoice = {
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  export type InvoiceAvgAggregateOutputType = {
    amount: number | null
    amountPaid: number | null
  }

  export type InvoiceSumAggregateOutputType = {
    amount: number | null
    amountPaid: number | null
  }

  export type InvoiceMinAggregateOutputType = {
    id: string | null
    institutionId: string | null
    studentId: string | null
    invoiceNumber: string | null
    description: string | null
    amount: number | null
    amountPaid: number | null
    status: string | null
    dueDate: Date | null
    paidDate: Date | null
    paymentMethod: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InvoiceMaxAggregateOutputType = {
    id: string | null
    institutionId: string | null
    studentId: string | null
    invoiceNumber: string | null
    description: string | null
    amount: number | null
    amountPaid: number | null
    status: string | null
    dueDate: Date | null
    paidDate: Date | null
    paymentMethod: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InvoiceCountAggregateOutputType = {
    id: number
    institutionId: number
    studentId: number
    invoiceNumber: number
    description: number
    amount: number
    amountPaid: number
    status: number
    dueDate: number
    paidDate: number
    paymentMethod: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InvoiceAvgAggregateInputType = {
    amount?: true
    amountPaid?: true
  }

  export type InvoiceSumAggregateInputType = {
    amount?: true
    amountPaid?: true
  }

  export type InvoiceMinAggregateInputType = {
    id?: true
    institutionId?: true
    studentId?: true
    invoiceNumber?: true
    description?: true
    amount?: true
    amountPaid?: true
    status?: true
    dueDate?: true
    paidDate?: true
    paymentMethod?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InvoiceMaxAggregateInputType = {
    id?: true
    institutionId?: true
    studentId?: true
    invoiceNumber?: true
    description?: true
    amount?: true
    amountPaid?: true
    status?: true
    dueDate?: true
    paidDate?: true
    paymentMethod?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InvoiceCountAggregateInputType = {
    id?: true
    institutionId?: true
    studentId?: true
    invoiceNumber?: true
    description?: true
    amount?: true
    amountPaid?: true
    status?: true
    dueDate?: true
    paidDate?: true
    paymentMethod?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InvoiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoice to aggregate.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Invoices
    **/
    _count?: true | InvoiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvoiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvoiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvoiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvoiceMaxAggregateInputType
  }

  export type GetInvoiceAggregateType<T extends InvoiceAggregateArgs> = {
        [P in keyof T & keyof AggregateInvoice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvoice[P]>
      : GetScalarType<T[P], AggregateInvoice[P]>
  }




  export type InvoiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithAggregationInput | InvoiceOrderByWithAggregationInput[]
    by: InvoiceScalarFieldEnum[] | InvoiceScalarFieldEnum
    having?: InvoiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvoiceCountAggregateInputType | true
    _avg?: InvoiceAvgAggregateInputType
    _sum?: InvoiceSumAggregateInputType
    _min?: InvoiceMinAggregateInputType
    _max?: InvoiceMaxAggregateInputType
  }

  export type InvoiceGroupByOutputType = {
    id: string
    institutionId: string
    studentId: string | null
    invoiceNumber: string
    description: string | null
    amount: number
    amountPaid: number
    status: string
    dueDate: Date | null
    paidDate: Date | null
    paymentMethod: string | null
    createdAt: Date
    updatedAt: Date
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  type GetInvoiceGroupByPayload<T extends InvoiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvoiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvoiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
            : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
        }
      >
    >


  export type InvoiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    institutionId?: boolean
    studentId?: boolean
    invoiceNumber?: boolean
    description?: boolean
    amount?: boolean
    amountPaid?: boolean
    status?: boolean
    dueDate?: boolean
    paidDate?: boolean
    paymentMethod?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    institution?: boolean | Invoice$institutionArgs<ExtArgs>
    student?: boolean | Invoice$studentArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>



  export type InvoiceSelectScalar = {
    id?: boolean
    institutionId?: boolean
    studentId?: boolean
    invoiceNumber?: boolean
    description?: boolean
    amount?: boolean
    amountPaid?: boolean
    status?: boolean
    dueDate?: boolean
    paidDate?: boolean
    paymentMethod?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type InvoiceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "institutionId" | "studentId" | "invoiceNumber" | "description" | "amount" | "amountPaid" | "status" | "dueDate" | "paidDate" | "paymentMethod" | "createdAt" | "updatedAt", ExtArgs["result"]["invoice"]>
  export type InvoiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    institution?: boolean | Invoice$institutionArgs<ExtArgs>
    student?: boolean | Invoice$studentArgs<ExtArgs>
  }

  export type $InvoicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Invoice"
    objects: {
      institution: Prisma.$InstitutionPayload<ExtArgs> | null
      student: Prisma.$StudentPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      institutionId: string
      studentId: string | null
      invoiceNumber: string
      description: string | null
      amount: number
      amountPaid: number
      status: string
      dueDate: Date | null
      paidDate: Date | null
      paymentMethod: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["invoice"]>
    composites: {}
  }

  type InvoiceGetPayload<S extends boolean | null | undefined | InvoiceDefaultArgs> = $Result.GetResult<Prisma.$InvoicePayload, S>

  type InvoiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InvoiceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InvoiceCountAggregateInputType | true
    }

  export interface InvoiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Invoice'], meta: { name: 'Invoice' } }
    /**
     * Find zero or one Invoice that matches the filter.
     * @param {InvoiceFindUniqueArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvoiceFindUniqueArgs>(args: SelectSubset<T, InvoiceFindUniqueArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Invoice that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InvoiceFindUniqueOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvoiceFindUniqueOrThrowArgs>(args: SelectSubset<T, InvoiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Invoice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvoiceFindFirstArgs>(args?: SelectSubset<T, InvoiceFindFirstArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Invoice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvoiceFindFirstOrThrowArgs>(args?: SelectSubset<T, InvoiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Invoices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Invoices
     * const invoices = await prisma.invoice.findMany()
     * 
     * // Get first 10 Invoices
     * const invoices = await prisma.invoice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invoiceWithIdOnly = await prisma.invoice.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InvoiceFindManyArgs>(args?: SelectSubset<T, InvoiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Invoice.
     * @param {InvoiceCreateArgs} args - Arguments to create a Invoice.
     * @example
     * // Create one Invoice
     * const Invoice = await prisma.invoice.create({
     *   data: {
     *     // ... data to create a Invoice
     *   }
     * })
     * 
     */
    create<T extends InvoiceCreateArgs>(args: SelectSubset<T, InvoiceCreateArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Invoices.
     * @param {InvoiceCreateManyArgs} args - Arguments to create many Invoices.
     * @example
     * // Create many Invoices
     * const invoice = await prisma.invoice.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InvoiceCreateManyArgs>(args?: SelectSubset<T, InvoiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Invoice.
     * @param {InvoiceDeleteArgs} args - Arguments to delete one Invoice.
     * @example
     * // Delete one Invoice
     * const Invoice = await prisma.invoice.delete({
     *   where: {
     *     // ... filter to delete one Invoice
     *   }
     * })
     * 
     */
    delete<T extends InvoiceDeleteArgs>(args: SelectSubset<T, InvoiceDeleteArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Invoice.
     * @param {InvoiceUpdateArgs} args - Arguments to update one Invoice.
     * @example
     * // Update one Invoice
     * const invoice = await prisma.invoice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InvoiceUpdateArgs>(args: SelectSubset<T, InvoiceUpdateArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Invoices.
     * @param {InvoiceDeleteManyArgs} args - Arguments to filter Invoices to delete.
     * @example
     * // Delete a few Invoices
     * const { count } = await prisma.invoice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InvoiceDeleteManyArgs>(args?: SelectSubset<T, InvoiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Invoices
     * const invoice = await prisma.invoice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InvoiceUpdateManyArgs>(args: SelectSubset<T, InvoiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Invoice.
     * @param {InvoiceUpsertArgs} args - Arguments to update or create a Invoice.
     * @example
     * // Update or create a Invoice
     * const invoice = await prisma.invoice.upsert({
     *   create: {
     *     // ... data to create a Invoice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Invoice we want to update
     *   }
     * })
     */
    upsert<T extends InvoiceUpsertArgs>(args: SelectSubset<T, InvoiceUpsertArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Invoices that matches the filter.
     * @param {InvoiceFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const invoice = await prisma.invoice.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: InvoiceFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Invoice.
     * @param {InvoiceAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const invoice = await prisma.invoice.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: InvoiceAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceCountArgs} args - Arguments to filter Invoices to count.
     * @example
     * // Count the number of Invoices
     * const count = await prisma.invoice.count({
     *   where: {
     *     // ... the filter for the Invoices we want to count
     *   }
     * })
    **/
    count<T extends InvoiceCountArgs>(
      args?: Subset<T, InvoiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvoiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvoiceAggregateArgs>(args: Subset<T, InvoiceAggregateArgs>): Prisma.PrismaPromise<GetInvoiceAggregateType<T>>

    /**
     * Group by Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvoiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvoiceGroupByArgs['orderBy'] }
        : { orderBy?: InvoiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvoiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvoiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Invoice model
   */
  readonly fields: InvoiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Invoice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvoiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    institution<T extends Invoice$institutionArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$institutionArgs<ExtArgs>>): Prisma__InstitutionClient<$Result.GetResult<Prisma.$InstitutionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    student<T extends Invoice$studentArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$studentArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Invoice model
   */
  interface InvoiceFieldRefs {
    readonly id: FieldRef<"Invoice", 'String'>
    readonly institutionId: FieldRef<"Invoice", 'String'>
    readonly studentId: FieldRef<"Invoice", 'String'>
    readonly invoiceNumber: FieldRef<"Invoice", 'String'>
    readonly description: FieldRef<"Invoice", 'String'>
    readonly amount: FieldRef<"Invoice", 'Float'>
    readonly amountPaid: FieldRef<"Invoice", 'Float'>
    readonly status: FieldRef<"Invoice", 'String'>
    readonly dueDate: FieldRef<"Invoice", 'DateTime'>
    readonly paidDate: FieldRef<"Invoice", 'DateTime'>
    readonly paymentMethod: FieldRef<"Invoice", 'String'>
    readonly createdAt: FieldRef<"Invoice", 'DateTime'>
    readonly updatedAt: FieldRef<"Invoice", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Invoice findUnique
   */
  export type InvoiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice findUniqueOrThrow
   */
  export type InvoiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice findFirst
   */
  export type InvoiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice findFirstOrThrow
   */
  export type InvoiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice findMany
   */
  export type InvoiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoices to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice create
   */
  export type InvoiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The data needed to create a Invoice.
     */
    data: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
  }

  /**
   * Invoice createMany
   */
  export type InvoiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Invoices.
     */
    data: InvoiceCreateManyInput | InvoiceCreateManyInput[]
  }

  /**
   * Invoice update
   */
  export type InvoiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The data needed to update a Invoice.
     */
    data: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
    /**
     * Choose, which Invoice to update.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice updateMany
   */
  export type InvoiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Invoices.
     */
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyInput>
    /**
     * Filter which Invoices to update
     */
    where?: InvoiceWhereInput
    /**
     * Limit how many Invoices to update.
     */
    limit?: number
  }

  /**
   * Invoice upsert
   */
  export type InvoiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The filter to search for the Invoice to update in case it exists.
     */
    where: InvoiceWhereUniqueInput
    /**
     * In case the Invoice found by the `where` argument doesn't exist, create a new Invoice with this data.
     */
    create: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
    /**
     * In case the Invoice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
  }

  /**
   * Invoice delete
   */
  export type InvoiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter which Invoice to delete.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice deleteMany
   */
  export type InvoiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoices to delete
     */
    where?: InvoiceWhereInput
    /**
     * Limit how many Invoices to delete.
     */
    limit?: number
  }

  /**
   * Invoice findRaw
   */
  export type InvoiceFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Invoice aggregateRaw
   */
  export type InvoiceAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Invoice.institution
   */
  export type Invoice$institutionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Institution
     */
    select?: InstitutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Institution
     */
    omit?: InstitutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstitutionInclude<ExtArgs> | null
    where?: InstitutionWhereInput
  }

  /**
   * Invoice.student
   */
  export type Invoice$studentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    where?: StudentWhereInput
  }

  /**
   * Invoice without action
   */
  export type InvoiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
  }


  /**
   * Model Message
   */

  export type AggregateMessage = {
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  export type MessageMinAggregateOutputType = {
    id: string | null
    fromUserId: string | null
    toUserId: string | null
    institutionId: string | null
    subject: string | null
    body: string | null
    isRead: boolean | null
    readAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MessageMaxAggregateOutputType = {
    id: string | null
    fromUserId: string | null
    toUserId: string | null
    institutionId: string | null
    subject: string | null
    body: string | null
    isRead: boolean | null
    readAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MessageCountAggregateOutputType = {
    id: number
    fromUserId: number
    toUserId: number
    institutionId: number
    subject: number
    body: number
    isRead: number
    readAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MessageMinAggregateInputType = {
    id?: true
    fromUserId?: true
    toUserId?: true
    institutionId?: true
    subject?: true
    body?: true
    isRead?: true
    readAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MessageMaxAggregateInputType = {
    id?: true
    fromUserId?: true
    toUserId?: true
    institutionId?: true
    subject?: true
    body?: true
    isRead?: true
    readAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MessageCountAggregateInputType = {
    id?: true
    fromUserId?: true
    toUserId?: true
    institutionId?: true
    subject?: true
    body?: true
    isRead?: true
    readAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Message to aggregate.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Messages
    **/
    _count?: true | MessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageMaxAggregateInputType
  }

  export type GetMessageAggregateType<T extends MessageAggregateArgs> = {
        [P in keyof T & keyof AggregateMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessage[P]>
      : GetScalarType<T[P], AggregateMessage[P]>
  }




  export type MessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithAggregationInput | MessageOrderByWithAggregationInput[]
    by: MessageScalarFieldEnum[] | MessageScalarFieldEnum
    having?: MessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageCountAggregateInputType | true
    _min?: MessageMinAggregateInputType
    _max?: MessageMaxAggregateInputType
  }

  export type MessageGroupByOutputType = {
    id: string
    fromUserId: string
    toUserId: string
    institutionId: string
    subject: string | null
    body: string
    isRead: boolean
    readAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  type GetMessageGroupByPayload<T extends MessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageGroupByOutputType[P]>
            : GetScalarType<T[P], MessageGroupByOutputType[P]>
        }
      >
    >


  export type MessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fromUserId?: boolean
    toUserId?: boolean
    institutionId?: boolean
    subject?: boolean
    body?: boolean
    isRead?: boolean
    readAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    fromUser?: boolean | UserDefaultArgs<ExtArgs>
    institution?: boolean | InstitutionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>



  export type MessageSelectScalar = {
    id?: boolean
    fromUserId?: boolean
    toUserId?: boolean
    institutionId?: boolean
    subject?: boolean
    body?: boolean
    isRead?: boolean
    readAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MessageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "fromUserId" | "toUserId" | "institutionId" | "subject" | "body" | "isRead" | "readAt" | "createdAt" | "updatedAt", ExtArgs["result"]["message"]>
  export type MessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fromUser?: boolean | UserDefaultArgs<ExtArgs>
    institution?: boolean | InstitutionDefaultArgs<ExtArgs>
  }

  export type $MessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Message"
    objects: {
      fromUser: Prisma.$UserPayload<ExtArgs>
      institution: Prisma.$InstitutionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      fromUserId: string
      toUserId: string
      institutionId: string
      subject: string | null
      body: string
      isRead: boolean
      readAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["message"]>
    composites: {}
  }

  type MessageGetPayload<S extends boolean | null | undefined | MessageDefaultArgs> = $Result.GetResult<Prisma.$MessagePayload, S>

  type MessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MessageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MessageCountAggregateInputType | true
    }

  export interface MessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Message'], meta: { name: 'Message' } }
    /**
     * Find zero or one Message that matches the filter.
     * @param {MessageFindUniqueArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MessageFindUniqueArgs>(args: SelectSubset<T, MessageFindUniqueArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Message that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MessageFindUniqueOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MessageFindUniqueOrThrowArgs>(args: SelectSubset<T, MessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Message that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MessageFindFirstArgs>(args?: SelectSubset<T, MessageFindFirstArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Message that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MessageFindFirstOrThrowArgs>(args?: SelectSubset<T, MessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Messages
     * const messages = await prisma.message.findMany()
     * 
     * // Get first 10 Messages
     * const messages = await prisma.message.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageWithIdOnly = await prisma.message.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MessageFindManyArgs>(args?: SelectSubset<T, MessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Message.
     * @param {MessageCreateArgs} args - Arguments to create a Message.
     * @example
     * // Create one Message
     * const Message = await prisma.message.create({
     *   data: {
     *     // ... data to create a Message
     *   }
     * })
     * 
     */
    create<T extends MessageCreateArgs>(args: SelectSubset<T, MessageCreateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Messages.
     * @param {MessageCreateManyArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MessageCreateManyArgs>(args?: SelectSubset<T, MessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Message.
     * @param {MessageDeleteArgs} args - Arguments to delete one Message.
     * @example
     * // Delete one Message
     * const Message = await prisma.message.delete({
     *   where: {
     *     // ... filter to delete one Message
     *   }
     * })
     * 
     */
    delete<T extends MessageDeleteArgs>(args: SelectSubset<T, MessageDeleteArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Message.
     * @param {MessageUpdateArgs} args - Arguments to update one Message.
     * @example
     * // Update one Message
     * const message = await prisma.message.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MessageUpdateArgs>(args: SelectSubset<T, MessageUpdateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Messages.
     * @param {MessageDeleteManyArgs} args - Arguments to filter Messages to delete.
     * @example
     * // Delete a few Messages
     * const { count } = await prisma.message.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MessageDeleteManyArgs>(args?: SelectSubset<T, MessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MessageUpdateManyArgs>(args: SelectSubset<T, MessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Message.
     * @param {MessageUpsertArgs} args - Arguments to update or create a Message.
     * @example
     * // Update or create a Message
     * const message = await prisma.message.upsert({
     *   create: {
     *     // ... data to create a Message
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Message we want to update
     *   }
     * })
     */
    upsert<T extends MessageUpsertArgs>(args: SelectSubset<T, MessageUpsertArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Messages that matches the filter.
     * @param {MessageFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const message = await prisma.message.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: MessageFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Message.
     * @param {MessageAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const message = await prisma.message.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: MessageAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageCountArgs} args - Arguments to filter Messages to count.
     * @example
     * // Count the number of Messages
     * const count = await prisma.message.count({
     *   where: {
     *     // ... the filter for the Messages we want to count
     *   }
     * })
    **/
    count<T extends MessageCountArgs>(
      args?: Subset<T, MessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageAggregateArgs>(args: Subset<T, MessageAggregateArgs>): Prisma.PrismaPromise<GetMessageAggregateType<T>>

    /**
     * Group by Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageGroupByArgs['orderBy'] }
        : { orderBy?: MessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Message model
   */
  readonly fields: MessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Message.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    fromUser<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    institution<T extends InstitutionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InstitutionDefaultArgs<ExtArgs>>): Prisma__InstitutionClient<$Result.GetResult<Prisma.$InstitutionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Message model
   */
  interface MessageFieldRefs {
    readonly id: FieldRef<"Message", 'String'>
    readonly fromUserId: FieldRef<"Message", 'String'>
    readonly toUserId: FieldRef<"Message", 'String'>
    readonly institutionId: FieldRef<"Message", 'String'>
    readonly subject: FieldRef<"Message", 'String'>
    readonly body: FieldRef<"Message", 'String'>
    readonly isRead: FieldRef<"Message", 'Boolean'>
    readonly readAt: FieldRef<"Message", 'DateTime'>
    readonly createdAt: FieldRef<"Message", 'DateTime'>
    readonly updatedAt: FieldRef<"Message", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Message findUnique
   */
  export type MessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findUniqueOrThrow
   */
  export type MessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findFirst
   */
  export type MessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findFirstOrThrow
   */
  export type MessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findMany
   */
  export type MessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Messages to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message create
   */
  export type MessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to create a Message.
     */
    data: XOR<MessageCreateInput, MessageUncheckedCreateInput>
  }

  /**
   * Message createMany
   */
  export type MessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
  }

  /**
   * Message update
   */
  export type MessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to update a Message.
     */
    data: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
    /**
     * Choose, which Message to update.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message updateMany
   */
  export type MessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Messages.
     */
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to update.
     */
    limit?: number
  }

  /**
   * Message upsert
   */
  export type MessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The filter to search for the Message to update in case it exists.
     */
    where: MessageWhereUniqueInput
    /**
     * In case the Message found by the `where` argument doesn't exist, create a new Message with this data.
     */
    create: XOR<MessageCreateInput, MessageUncheckedCreateInput>
    /**
     * In case the Message was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
  }

  /**
   * Message delete
   */
  export type MessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter which Message to delete.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message deleteMany
   */
  export type MessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Messages to delete
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to delete.
     */
    limit?: number
  }

  /**
   * Message findRaw
   */
  export type MessageFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Message aggregateRaw
   */
  export type MessageAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Message without action
   */
  export type MessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const InstitutionScalarFieldEnum: {
    id: 'id',
    name: 'name',
    institutionType: 'institutionType',
    address: 'address',
    city: 'city',
    state: 'state',
    country: 'country',
    phone: 'phone',
    email: 'email',
    website: 'website',
    plan: 'plan',
    subscriptionStatus: 'subscriptionStatus',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InstitutionScalarFieldEnum = (typeof InstitutionScalarFieldEnum)[keyof typeof InstitutionScalarFieldEnum]


  export const UsersOnInstitutionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    institutionId: 'institutionId'
  };

  export type UsersOnInstitutionScalarFieldEnum = (typeof UsersOnInstitutionScalarFieldEnum)[keyof typeof UsersOnInstitutionScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    firstName: 'firstName',
    middleName: 'middleName',
    lastName: 'lastName',
    dateOfBirth: 'dateOfBirth',
    role: 'role',
    email: 'email',
    password: 'password',
    avatar: 'avatar',
    phone: 'phone',
    isActive: 'isActive',
    lastlogin: 'lastlogin',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const StudentScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    institutionId: 'institutionId',
    firstName: 'firstName',
    middleName: 'middleName',
    lastName: 'lastName',
    admissionNumber: 'admissionNumber',
    dateOfBirth: 'dateOfBirth',
    gender: 'gender',
    bloodGroup: 'bloodGroup',
    address: 'address',
    gradeApplying: 'gradeApplying',
    academicYear: 'academicYear',
    classId: 'classId',
    phone: 'phone',
    email: 'email',
    guardians: 'guardians',
    fingerprintEnrolled: 'fingerprintEnrolled',
    fingerprintData: 'fingerprintData',
    faceData: 'faceData',
    documents: 'documents',
    photo: 'photo',
    emergencyContacts: 'emergencyContacts',
    medicalConditions: 'medicalConditions',
    allergies: 'allergies',
    medications: 'medications',
    previousSchool: 'previousSchool',
    previousGrade: 'previousGrade',
    transferReason: 'transferReason',
    enrollmentStatus: 'enrollmentStatus',
    enrollmentDate: 'enrollmentDate',
    nationality: 'nationality',
    religion: 'religion',
    languagesSpoken: 'languagesSpoken',
    specialNeeds: 'specialNeeds',
    transportRequired: 'transportRequired',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    parentIds: 'parentIds'
  };

  export type StudentScalarFieldEnum = (typeof StudentScalarFieldEnum)[keyof typeof StudentScalarFieldEnum]


  export const UserToParentScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    parentId: 'parentId'
  };

  export type UserToParentScalarFieldEnum = (typeof UserToParentScalarFieldEnum)[keyof typeof UserToParentScalarFieldEnum]


  export const ParentScalarFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    institutionId: 'institutionId',
    firstName: 'firstName',
    middleName: 'middleName',
    lastName: 'lastName',
    email: 'email',
    phone: 'phone',
    occupation: 'occupation',
    relationship: 'relationship',
    address: 'address',
    isPrimaryContact: 'isPrimaryContact',
    isEmergencyContact: 'isEmergencyContact',
    preferredContactTime: 'preferredContactTime',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ParentScalarFieldEnum = (typeof ParentScalarFieldEnum)[keyof typeof ParentScalarFieldEnum]


  export const StudentDocumentScalarFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    documentType: 'documentType',
    documentName: 'documentName',
    documentUrl: 'documentUrl',
    fileSize: 'fileSize',
    mimeType: 'mimeType',
    uploadedAt: 'uploadedAt',
    uploadedBy: 'uploadedBy',
    verified: 'verified',
    verifiedBy: 'verifiedBy',
    verifiedAt: 'verifiedAt'
  };

  export type StudentDocumentScalarFieldEnum = (typeof StudentDocumentScalarFieldEnum)[keyof typeof StudentDocumentScalarFieldEnum]


  export const TeacherOnInstitutionScalarFieldEnum: {
    id: 'id',
    teacherId: 'teacherId',
    institutionId: 'institutionId'
  };

  export type TeacherOnInstitutionScalarFieldEnum = (typeof TeacherOnInstitutionScalarFieldEnum)[keyof typeof TeacherOnInstitutionScalarFieldEnum]


  export const TeacherScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    firstName: 'firstName',
    middleName: 'middleName',
    lastName: 'lastName',
    email: 'email',
    phone: 'phone',
    avatar: 'avatar',
    employeeNumber: 'employeeNumber',
    subjects: 'subjects',
    qualification: 'qualification',
    experience: 'experience',
    salary: 'salary',
    joinDate: 'joinDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TeacherScalarFieldEnum = (typeof TeacherScalarFieldEnum)[keyof typeof TeacherScalarFieldEnum]


  export const TeacherOnClassScalarFieldEnum: {
    id: 'id',
    teacherId: 'teacherId',
    classId: 'classId'
  };

  export type TeacherOnClassScalarFieldEnum = (typeof TeacherOnClassScalarFieldEnum)[keyof typeof TeacherOnClassScalarFieldEnum]


  export const ClassScalarFieldEnum: {
    id: 'id',
    institutionId: 'institutionId',
    name: 'name',
    section: 'section',
    academicYear: 'academicYear',
    capacity: 'capacity',
    roomNumber: 'roomNumber',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    teacherIds: 'teacherIds'
  };

  export type ClassScalarFieldEnum = (typeof ClassScalarFieldEnum)[keyof typeof ClassScalarFieldEnum]


  export const EnrollmentScalarFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    classId: 'classId',
    academicYear: 'academicYear',
    enrollDate: 'enrollDate',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EnrollmentScalarFieldEnum = (typeof EnrollmentScalarFieldEnum)[keyof typeof EnrollmentScalarFieldEnum]


  export const AttendanceScalarFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    classId: 'classId',
    date: 'date',
    status: 'status',
    remarks: 'remarks',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AttendanceScalarFieldEnum = (typeof AttendanceScalarFieldEnum)[keyof typeof AttendanceScalarFieldEnum]


  export const GradeScalarFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    subject: 'subject',
    examType: 'examType',
    score: 'score',
    maxScore: 'maxScore',
    grade: 'grade',
    term: 'term',
    academicYear: 'academicYear',
    remarks: 'remarks',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type GradeScalarFieldEnum = (typeof GradeScalarFieldEnum)[keyof typeof GradeScalarFieldEnum]


  export const TimetableScalarFieldEnum: {
    id: 'id',
    classId: 'classId',
    dayOfWeek: 'dayOfWeek',
    startTime: 'startTime',
    endTime: 'endTime',
    subject: 'subject',
    teacherId: 'teacherId',
    room: 'room',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TimetableScalarFieldEnum = (typeof TimetableScalarFieldEnum)[keyof typeof TimetableScalarFieldEnum]


  export const InvoiceScalarFieldEnum: {
    id: 'id',
    institutionId: 'institutionId',
    studentId: 'studentId',
    invoiceNumber: 'invoiceNumber',
    description: 'description',
    amount: 'amount',
    amountPaid: 'amountPaid',
    status: 'status',
    dueDate: 'dueDate',
    paidDate: 'paidDate',
    paymentMethod: 'paymentMethod',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InvoiceScalarFieldEnum = (typeof InvoiceScalarFieldEnum)[keyof typeof InvoiceScalarFieldEnum]


  export const MessageScalarFieldEnum: {
    id: 'id',
    fromUserId: 'fromUserId',
    toUserId: 'toUserId',
    institutionId: 'institutionId',
    subject: 'subject',
    body: 'body',
    isRead: 'isRead',
    readAt: 'readAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MessageScalarFieldEnum = (typeof MessageScalarFieldEnum)[keyof typeof MessageScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'InstitutionType'
   */
  export type EnumInstitutionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InstitutionType'>
    


  /**
   * Reference to a field of type 'InstitutionType[]'
   */
  export type ListEnumInstitutionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InstitutionType[]'>
    


  /**
   * Reference to a field of type 'InstitutionPlan'
   */
  export type EnumInstitutionPlanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InstitutionPlan'>
    


  /**
   * Reference to a field of type 'InstitutionPlan[]'
   */
  export type ListEnumInstitutionPlanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InstitutionPlan[]'>
    


  /**
   * Reference to a field of type 'SubscriptionStatus'
   */
  export type EnumSubscriptionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionStatus'>
    


  /**
   * Reference to a field of type 'SubscriptionStatus[]'
   */
  export type ListEnumSubscriptionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionStatus[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Role'
   */
  export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role'>
    


  /**
   * Reference to a field of type 'Role[]'
   */
  export type ListEnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type InstitutionWhereInput = {
    AND?: InstitutionWhereInput | InstitutionWhereInput[]
    OR?: InstitutionWhereInput[]
    NOT?: InstitutionWhereInput | InstitutionWhereInput[]
    id?: StringFilter<"Institution"> | string
    name?: StringFilter<"Institution"> | string
    institutionType?: EnumInstitutionTypeFilter<"Institution"> | $Enums.InstitutionType
    address?: StringFilter<"Institution"> | string
    city?: StringFilter<"Institution"> | string
    state?: StringFilter<"Institution"> | string
    country?: StringFilter<"Institution"> | string
    phone?: StringFilter<"Institution"> | string
    email?: StringFilter<"Institution"> | string
    website?: StringNullableFilter<"Institution"> | string | null
    plan?: EnumInstitutionPlanFilter<"Institution"> | $Enums.InstitutionPlan
    subscriptionStatus?: EnumSubscriptionStatusFilter<"Institution"> | $Enums.SubscriptionStatus
    createdAt?: DateTimeFilter<"Institution"> | Date | string
    updatedAt?: DateTimeFilter<"Institution"> | Date | string
    users?: UsersOnInstitutionListRelationFilter
    classes?: ClassListRelationFilter
    students?: StudentListRelationFilter
    teachers?: TeacherOnInstitutionListRelationFilter
    invoices?: InvoiceListRelationFilter
    messages?: MessageListRelationFilter
  }

  export type InstitutionOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    institutionType?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    country?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    website?: SortOrder
    plan?: SortOrder
    subscriptionStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    users?: UsersOnInstitutionOrderByRelationAggregateInput
    classes?: ClassOrderByRelationAggregateInput
    students?: StudentOrderByRelationAggregateInput
    teachers?: TeacherOnInstitutionOrderByRelationAggregateInput
    invoices?: InvoiceOrderByRelationAggregateInput
    messages?: MessageOrderByRelationAggregateInput
  }

  export type InstitutionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InstitutionWhereInput | InstitutionWhereInput[]
    OR?: InstitutionWhereInput[]
    NOT?: InstitutionWhereInput | InstitutionWhereInput[]
    name?: StringFilter<"Institution"> | string
    institutionType?: EnumInstitutionTypeFilter<"Institution"> | $Enums.InstitutionType
    address?: StringFilter<"Institution"> | string
    city?: StringFilter<"Institution"> | string
    state?: StringFilter<"Institution"> | string
    country?: StringFilter<"Institution"> | string
    phone?: StringFilter<"Institution"> | string
    email?: StringFilter<"Institution"> | string
    website?: StringNullableFilter<"Institution"> | string | null
    plan?: EnumInstitutionPlanFilter<"Institution"> | $Enums.InstitutionPlan
    subscriptionStatus?: EnumSubscriptionStatusFilter<"Institution"> | $Enums.SubscriptionStatus
    createdAt?: DateTimeFilter<"Institution"> | Date | string
    updatedAt?: DateTimeFilter<"Institution"> | Date | string
    users?: UsersOnInstitutionListRelationFilter
    classes?: ClassListRelationFilter
    students?: StudentListRelationFilter
    teachers?: TeacherOnInstitutionListRelationFilter
    invoices?: InvoiceListRelationFilter
    messages?: MessageListRelationFilter
  }, "id">

  export type InstitutionOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    institutionType?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    country?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    website?: SortOrder
    plan?: SortOrder
    subscriptionStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: InstitutionCountOrderByAggregateInput
    _max?: InstitutionMaxOrderByAggregateInput
    _min?: InstitutionMinOrderByAggregateInput
  }

  export type InstitutionScalarWhereWithAggregatesInput = {
    AND?: InstitutionScalarWhereWithAggregatesInput | InstitutionScalarWhereWithAggregatesInput[]
    OR?: InstitutionScalarWhereWithAggregatesInput[]
    NOT?: InstitutionScalarWhereWithAggregatesInput | InstitutionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Institution"> | string
    name?: StringWithAggregatesFilter<"Institution"> | string
    institutionType?: EnumInstitutionTypeWithAggregatesFilter<"Institution"> | $Enums.InstitutionType
    address?: StringWithAggregatesFilter<"Institution"> | string
    city?: StringWithAggregatesFilter<"Institution"> | string
    state?: StringWithAggregatesFilter<"Institution"> | string
    country?: StringWithAggregatesFilter<"Institution"> | string
    phone?: StringWithAggregatesFilter<"Institution"> | string
    email?: StringWithAggregatesFilter<"Institution"> | string
    website?: StringNullableWithAggregatesFilter<"Institution"> | string | null
    plan?: EnumInstitutionPlanWithAggregatesFilter<"Institution"> | $Enums.InstitutionPlan
    subscriptionStatus?: EnumSubscriptionStatusWithAggregatesFilter<"Institution"> | $Enums.SubscriptionStatus
    createdAt?: DateTimeWithAggregatesFilter<"Institution"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Institution"> | Date | string
  }

  export type UsersOnInstitutionWhereInput = {
    AND?: UsersOnInstitutionWhereInput | UsersOnInstitutionWhereInput[]
    OR?: UsersOnInstitutionWhereInput[]
    NOT?: UsersOnInstitutionWhereInput | UsersOnInstitutionWhereInput[]
    id?: StringFilter<"UsersOnInstitution"> | string
    userId?: StringFilter<"UsersOnInstitution"> | string
    institutionId?: StringFilter<"UsersOnInstitution"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    institution?: XOR<InstitutionScalarRelationFilter, InstitutionWhereInput>
  }

  export type UsersOnInstitutionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    institutionId?: SortOrder
    user?: UserOrderByWithRelationInput
    institution?: InstitutionOrderByWithRelationInput
  }

  export type UsersOnInstitutionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UsersOnInstitutionWhereInput | UsersOnInstitutionWhereInput[]
    OR?: UsersOnInstitutionWhereInput[]
    NOT?: UsersOnInstitutionWhereInput | UsersOnInstitutionWhereInput[]
    userId?: StringFilter<"UsersOnInstitution"> | string
    institutionId?: StringFilter<"UsersOnInstitution"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    institution?: XOR<InstitutionScalarRelationFilter, InstitutionWhereInput>
  }, "id">

  export type UsersOnInstitutionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    institutionId?: SortOrder
    _count?: UsersOnInstitutionCountOrderByAggregateInput
    _max?: UsersOnInstitutionMaxOrderByAggregateInput
    _min?: UsersOnInstitutionMinOrderByAggregateInput
  }

  export type UsersOnInstitutionScalarWhereWithAggregatesInput = {
    AND?: UsersOnInstitutionScalarWhereWithAggregatesInput | UsersOnInstitutionScalarWhereWithAggregatesInput[]
    OR?: UsersOnInstitutionScalarWhereWithAggregatesInput[]
    NOT?: UsersOnInstitutionScalarWhereWithAggregatesInput | UsersOnInstitutionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UsersOnInstitution"> | string
    userId?: StringWithAggregatesFilter<"UsersOnInstitution"> | string
    institutionId?: StringWithAggregatesFilter<"UsersOnInstitution"> | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    firstName?: StringFilter<"User"> | string
    middleName?: StringNullableFilter<"User"> | string | null
    lastName?: StringFilter<"User"> | string
    dateOfBirth?: DateTimeFilter<"User"> | Date | string
    role?: EnumRoleFilter<"User"> | $Enums.Role
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    avatar?: StringNullableFilter<"User"> | string | null
    phone?: StringNullableFilter<"User"> | string | null
    isActive?: BoolFilter<"User"> | boolean
    lastlogin?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    student?: StudentListRelationFilter
    teacher?: TeacherListRelationFilter
    parent?: UserToParentListRelationFilter
    institutions?: UsersOnInstitutionListRelationFilter
    sentMessages?: MessageListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    firstName?: SortOrder
    middleName?: SortOrder
    lastName?: SortOrder
    dateOfBirth?: SortOrder
    role?: SortOrder
    email?: SortOrder
    password?: SortOrder
    avatar?: SortOrder
    phone?: SortOrder
    isActive?: SortOrder
    lastlogin?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    student?: StudentOrderByRelationAggregateInput
    teacher?: TeacherOrderByRelationAggregateInput
    parent?: UserToParentOrderByRelationAggregateInput
    institutions?: UsersOnInstitutionOrderByRelationAggregateInput
    sentMessages?: MessageOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    firstName?: StringFilter<"User"> | string
    middleName?: StringNullableFilter<"User"> | string | null
    lastName?: StringFilter<"User"> | string
    dateOfBirth?: DateTimeFilter<"User"> | Date | string
    role?: EnumRoleFilter<"User"> | $Enums.Role
    password?: StringFilter<"User"> | string
    avatar?: StringNullableFilter<"User"> | string | null
    phone?: StringNullableFilter<"User"> | string | null
    isActive?: BoolFilter<"User"> | boolean
    lastlogin?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    student?: StudentListRelationFilter
    teacher?: TeacherListRelationFilter
    parent?: UserToParentListRelationFilter
    institutions?: UsersOnInstitutionListRelationFilter
    sentMessages?: MessageListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    firstName?: SortOrder
    middleName?: SortOrder
    lastName?: SortOrder
    dateOfBirth?: SortOrder
    role?: SortOrder
    email?: SortOrder
    password?: SortOrder
    avatar?: SortOrder
    phone?: SortOrder
    isActive?: SortOrder
    lastlogin?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    firstName?: StringWithAggregatesFilter<"User"> | string
    middleName?: StringNullableWithAggregatesFilter<"User"> | string | null
    lastName?: StringWithAggregatesFilter<"User"> | string
    dateOfBirth?: DateTimeWithAggregatesFilter<"User"> | Date | string
    role?: EnumRoleWithAggregatesFilter<"User"> | $Enums.Role
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    avatar?: StringNullableWithAggregatesFilter<"User"> | string | null
    phone?: StringNullableWithAggregatesFilter<"User"> | string | null
    isActive?: BoolWithAggregatesFilter<"User"> | boolean
    lastlogin?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type StudentWhereInput = {
    AND?: StudentWhereInput | StudentWhereInput[]
    OR?: StudentWhereInput[]
    NOT?: StudentWhereInput | StudentWhereInput[]
    id?: StringFilter<"Student"> | string
    userId?: StringNullableFilter<"Student"> | string | null
    institutionId?: StringFilter<"Student"> | string
    firstName?: StringFilter<"Student"> | string
    middleName?: StringNullableFilter<"Student"> | string | null
    lastName?: StringFilter<"Student"> | string
    admissionNumber?: StringNullableFilter<"Student"> | string | null
    dateOfBirth?: DateTimeNullableFilter<"Student"> | Date | string | null
    gender?: StringNullableFilter<"Student"> | string | null
    bloodGroup?: StringNullableFilter<"Student"> | string | null
    address?: StringNullableFilter<"Student"> | string | null
    gradeApplying?: StringNullableFilter<"Student"> | string | null
    academicYear?: StringNullableFilter<"Student"> | string | null
    classId?: StringNullableFilter<"Student"> | string | null
    phone?: StringNullableFilter<"Student"> | string | null
    email?: StringNullableFilter<"Student"> | string | null
    guardians?: JsonNullableFilter<"Student">
    fingerprintEnrolled?: BoolFilter<"Student"> | boolean
    fingerprintData?: JsonNullableFilter<"Student">
    faceData?: JsonNullableFilter<"Student">
    documents?: JsonNullableFilter<"Student">
    photo?: StringNullableFilter<"Student"> | string | null
    emergencyContacts?: JsonNullableFilter<"Student">
    medicalConditions?: StringNullableFilter<"Student"> | string | null
    allergies?: StringNullableFilter<"Student"> | string | null
    medications?: StringNullableFilter<"Student"> | string | null
    previousSchool?: StringNullableFilter<"Student"> | string | null
    previousGrade?: StringNullableFilter<"Student"> | string | null
    transferReason?: StringNullableFilter<"Student"> | string | null
    enrollmentStatus?: StringFilter<"Student"> | string
    enrollmentDate?: DateTimeNullableFilter<"Student"> | Date | string | null
    nationality?: StringNullableFilter<"Student"> | string | null
    religion?: StringNullableFilter<"Student"> | string | null
    languagesSpoken?: StringNullableListFilter<"Student">
    specialNeeds?: StringNullableFilter<"Student"> | string | null
    transportRequired?: BoolFilter<"Student"> | boolean
    createdAt?: DateTimeFilter<"Student"> | Date | string
    updatedAt?: DateTimeFilter<"Student"> | Date | string
    parentIds?: StringNullableListFilter<"Student">
    StudentDocument?: StudentDocumentListRelationFilter
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    institution?: XOR<InstitutionScalarRelationFilter, InstitutionWhereInput>
    class?: XOR<ClassNullableScalarRelationFilter, ClassWhereInput> | null
    parents?: ParentListRelationFilter
    enrollments?: EnrollmentListRelationFilter
    attendances?: AttendanceListRelationFilter
    grades?: GradeListRelationFilter
    invoices?: InvoiceListRelationFilter
  }

  export type StudentOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    institutionId?: SortOrder
    firstName?: SortOrder
    middleName?: SortOrder
    lastName?: SortOrder
    admissionNumber?: SortOrder
    dateOfBirth?: SortOrder
    gender?: SortOrder
    bloodGroup?: SortOrder
    address?: SortOrder
    gradeApplying?: SortOrder
    academicYear?: SortOrder
    classId?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    guardians?: SortOrder
    fingerprintEnrolled?: SortOrder
    fingerprintData?: SortOrder
    faceData?: SortOrder
    documents?: SortOrder
    photo?: SortOrder
    emergencyContacts?: SortOrder
    medicalConditions?: SortOrder
    allergies?: SortOrder
    medications?: SortOrder
    previousSchool?: SortOrder
    previousGrade?: SortOrder
    transferReason?: SortOrder
    enrollmentStatus?: SortOrder
    enrollmentDate?: SortOrder
    nationality?: SortOrder
    religion?: SortOrder
    languagesSpoken?: SortOrder
    specialNeeds?: SortOrder
    transportRequired?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    parentIds?: SortOrder
    StudentDocument?: StudentDocumentOrderByRelationAggregateInput
    user?: UserOrderByWithRelationInput
    institution?: InstitutionOrderByWithRelationInput
    class?: ClassOrderByWithRelationInput
    parents?: ParentOrderByRelationAggregateInput
    enrollments?: EnrollmentOrderByRelationAggregateInput
    attendances?: AttendanceOrderByRelationAggregateInput
    grades?: GradeOrderByRelationAggregateInput
    invoices?: InvoiceOrderByRelationAggregateInput
  }

  export type StudentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    institutionId_admissionNumber?: StudentInstitutionIdAdmissionNumberCompoundUniqueInput
    AND?: StudentWhereInput | StudentWhereInput[]
    OR?: StudentWhereInput[]
    NOT?: StudentWhereInput | StudentWhereInput[]
    userId?: StringNullableFilter<"Student"> | string | null
    institutionId?: StringFilter<"Student"> | string
    firstName?: StringFilter<"Student"> | string
    middleName?: StringNullableFilter<"Student"> | string | null
    lastName?: StringFilter<"Student"> | string
    admissionNumber?: StringNullableFilter<"Student"> | string | null
    dateOfBirth?: DateTimeNullableFilter<"Student"> | Date | string | null
    gender?: StringNullableFilter<"Student"> | string | null
    bloodGroup?: StringNullableFilter<"Student"> | string | null
    address?: StringNullableFilter<"Student"> | string | null
    gradeApplying?: StringNullableFilter<"Student"> | string | null
    academicYear?: StringNullableFilter<"Student"> | string | null
    classId?: StringNullableFilter<"Student"> | string | null
    phone?: StringNullableFilter<"Student"> | string | null
    email?: StringNullableFilter<"Student"> | string | null
    guardians?: JsonNullableFilter<"Student">
    fingerprintEnrolled?: BoolFilter<"Student"> | boolean
    fingerprintData?: JsonNullableFilter<"Student">
    faceData?: JsonNullableFilter<"Student">
    documents?: JsonNullableFilter<"Student">
    photo?: StringNullableFilter<"Student"> | string | null
    emergencyContacts?: JsonNullableFilter<"Student">
    medicalConditions?: StringNullableFilter<"Student"> | string | null
    allergies?: StringNullableFilter<"Student"> | string | null
    medications?: StringNullableFilter<"Student"> | string | null
    previousSchool?: StringNullableFilter<"Student"> | string | null
    previousGrade?: StringNullableFilter<"Student"> | string | null
    transferReason?: StringNullableFilter<"Student"> | string | null
    enrollmentStatus?: StringFilter<"Student"> | string
    enrollmentDate?: DateTimeNullableFilter<"Student"> | Date | string | null
    nationality?: StringNullableFilter<"Student"> | string | null
    religion?: StringNullableFilter<"Student"> | string | null
    languagesSpoken?: StringNullableListFilter<"Student">
    specialNeeds?: StringNullableFilter<"Student"> | string | null
    transportRequired?: BoolFilter<"Student"> | boolean
    createdAt?: DateTimeFilter<"Student"> | Date | string
    updatedAt?: DateTimeFilter<"Student"> | Date | string
    parentIds?: StringNullableListFilter<"Student">
    StudentDocument?: StudentDocumentListRelationFilter
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    institution?: XOR<InstitutionScalarRelationFilter, InstitutionWhereInput>
    class?: XOR<ClassNullableScalarRelationFilter, ClassWhereInput> | null
    parents?: ParentListRelationFilter
    enrollments?: EnrollmentListRelationFilter
    attendances?: AttendanceListRelationFilter
    grades?: GradeListRelationFilter
    invoices?: InvoiceListRelationFilter
  }, "id" | "institutionId_admissionNumber">

  export type StudentOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    institutionId?: SortOrder
    firstName?: SortOrder
    middleName?: SortOrder
    lastName?: SortOrder
    admissionNumber?: SortOrder
    dateOfBirth?: SortOrder
    gender?: SortOrder
    bloodGroup?: SortOrder
    address?: SortOrder
    gradeApplying?: SortOrder
    academicYear?: SortOrder
    classId?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    guardians?: SortOrder
    fingerprintEnrolled?: SortOrder
    fingerprintData?: SortOrder
    faceData?: SortOrder
    documents?: SortOrder
    photo?: SortOrder
    emergencyContacts?: SortOrder
    medicalConditions?: SortOrder
    allergies?: SortOrder
    medications?: SortOrder
    previousSchool?: SortOrder
    previousGrade?: SortOrder
    transferReason?: SortOrder
    enrollmentStatus?: SortOrder
    enrollmentDate?: SortOrder
    nationality?: SortOrder
    religion?: SortOrder
    languagesSpoken?: SortOrder
    specialNeeds?: SortOrder
    transportRequired?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    parentIds?: SortOrder
    _count?: StudentCountOrderByAggregateInput
    _max?: StudentMaxOrderByAggregateInput
    _min?: StudentMinOrderByAggregateInput
  }

  export type StudentScalarWhereWithAggregatesInput = {
    AND?: StudentScalarWhereWithAggregatesInput | StudentScalarWhereWithAggregatesInput[]
    OR?: StudentScalarWhereWithAggregatesInput[]
    NOT?: StudentScalarWhereWithAggregatesInput | StudentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Student"> | string
    userId?: StringNullableWithAggregatesFilter<"Student"> | string | null
    institutionId?: StringWithAggregatesFilter<"Student"> | string
    firstName?: StringWithAggregatesFilter<"Student"> | string
    middleName?: StringNullableWithAggregatesFilter<"Student"> | string | null
    lastName?: StringWithAggregatesFilter<"Student"> | string
    admissionNumber?: StringNullableWithAggregatesFilter<"Student"> | string | null
    dateOfBirth?: DateTimeNullableWithAggregatesFilter<"Student"> | Date | string | null
    gender?: StringNullableWithAggregatesFilter<"Student"> | string | null
    bloodGroup?: StringNullableWithAggregatesFilter<"Student"> | string | null
    address?: StringNullableWithAggregatesFilter<"Student"> | string | null
    gradeApplying?: StringNullableWithAggregatesFilter<"Student"> | string | null
    academicYear?: StringNullableWithAggregatesFilter<"Student"> | string | null
    classId?: StringNullableWithAggregatesFilter<"Student"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Student"> | string | null
    email?: StringNullableWithAggregatesFilter<"Student"> | string | null
    guardians?: JsonNullableWithAggregatesFilter<"Student">
    fingerprintEnrolled?: BoolWithAggregatesFilter<"Student"> | boolean
    fingerprintData?: JsonNullableWithAggregatesFilter<"Student">
    faceData?: JsonNullableWithAggregatesFilter<"Student">
    documents?: JsonNullableWithAggregatesFilter<"Student">
    photo?: StringNullableWithAggregatesFilter<"Student"> | string | null
    emergencyContacts?: JsonNullableWithAggregatesFilter<"Student">
    medicalConditions?: StringNullableWithAggregatesFilter<"Student"> | string | null
    allergies?: StringNullableWithAggregatesFilter<"Student"> | string | null
    medications?: StringNullableWithAggregatesFilter<"Student"> | string | null
    previousSchool?: StringNullableWithAggregatesFilter<"Student"> | string | null
    previousGrade?: StringNullableWithAggregatesFilter<"Student"> | string | null
    transferReason?: StringNullableWithAggregatesFilter<"Student"> | string | null
    enrollmentStatus?: StringWithAggregatesFilter<"Student"> | string
    enrollmentDate?: DateTimeNullableWithAggregatesFilter<"Student"> | Date | string | null
    nationality?: StringNullableWithAggregatesFilter<"Student"> | string | null
    religion?: StringNullableWithAggregatesFilter<"Student"> | string | null
    languagesSpoken?: StringNullableListFilter<"Student">
    specialNeeds?: StringNullableWithAggregatesFilter<"Student"> | string | null
    transportRequired?: BoolWithAggregatesFilter<"Student"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Student"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Student"> | Date | string
    parentIds?: StringNullableListFilter<"Student">
  }

  export type UserToParentWhereInput = {
    AND?: UserToParentWhereInput | UserToParentWhereInput[]
    OR?: UserToParentWhereInput[]
    NOT?: UserToParentWhereInput | UserToParentWhereInput[]
    id?: StringFilter<"UserToParent"> | string
    userId?: StringFilter<"UserToParent"> | string
    parentId?: StringFilter<"UserToParent"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    parent?: XOR<ParentScalarRelationFilter, ParentWhereInput>
  }

  export type UserToParentOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    parentId?: SortOrder
    user?: UserOrderByWithRelationInput
    parent?: ParentOrderByWithRelationInput
  }

  export type UserToParentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UserToParentWhereInput | UserToParentWhereInput[]
    OR?: UserToParentWhereInput[]
    NOT?: UserToParentWhereInput | UserToParentWhereInput[]
    userId?: StringFilter<"UserToParent"> | string
    parentId?: StringFilter<"UserToParent"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    parent?: XOR<ParentScalarRelationFilter, ParentWhereInput>
  }, "id">

  export type UserToParentOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    parentId?: SortOrder
    _count?: UserToParentCountOrderByAggregateInput
    _max?: UserToParentMaxOrderByAggregateInput
    _min?: UserToParentMinOrderByAggregateInput
  }

  export type UserToParentScalarWhereWithAggregatesInput = {
    AND?: UserToParentScalarWhereWithAggregatesInput | UserToParentScalarWhereWithAggregatesInput[]
    OR?: UserToParentScalarWhereWithAggregatesInput[]
    NOT?: UserToParentScalarWhereWithAggregatesInput | UserToParentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserToParent"> | string
    userId?: StringWithAggregatesFilter<"UserToParent"> | string
    parentId?: StringWithAggregatesFilter<"UserToParent"> | string
  }

  export type ParentWhereInput = {
    AND?: ParentWhereInput | ParentWhereInput[]
    OR?: ParentWhereInput[]
    NOT?: ParentWhereInput | ParentWhereInput[]
    id?: StringFilter<"Parent"> | string
    studentId?: StringNullableFilter<"Parent"> | string | null
    institutionId?: StringFilter<"Parent"> | string
    firstName?: StringFilter<"Parent"> | string
    middleName?: StringNullableFilter<"Parent"> | string | null
    lastName?: StringFilter<"Parent"> | string
    email?: StringFilter<"Parent"> | string
    phone?: StringFilter<"Parent"> | string
    occupation?: StringNullableFilter<"Parent"> | string | null
    relationship?: StringNullableFilter<"Parent"> | string | null
    address?: StringNullableFilter<"Parent"> | string | null
    isPrimaryContact?: BoolFilter<"Parent"> | boolean
    isEmergencyContact?: BoolFilter<"Parent"> | boolean
    preferredContactTime?: StringNullableFilter<"Parent"> | string | null
    createdAt?: DateTimeFilter<"Parent"> | Date | string
    updatedAt?: DateTimeFilter<"Parent"> | Date | string
    student?: XOR<StudentNullableScalarRelationFilter, StudentWhereInput> | null
    user?: UserToParentListRelationFilter
  }

  export type ParentOrderByWithRelationInput = {
    id?: SortOrder
    studentId?: SortOrder
    institutionId?: SortOrder
    firstName?: SortOrder
    middleName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    occupation?: SortOrder
    relationship?: SortOrder
    address?: SortOrder
    isPrimaryContact?: SortOrder
    isEmergencyContact?: SortOrder
    preferredContactTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    student?: StudentOrderByWithRelationInput
    user?: UserToParentOrderByRelationAggregateInput
  }

  export type ParentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    studentId?: string
    AND?: ParentWhereInput | ParentWhereInput[]
    OR?: ParentWhereInput[]
    NOT?: ParentWhereInput | ParentWhereInput[]
    institutionId?: StringFilter<"Parent"> | string
    firstName?: StringFilter<"Parent"> | string
    middleName?: StringNullableFilter<"Parent"> | string | null
    lastName?: StringFilter<"Parent"> | string
    email?: StringFilter<"Parent"> | string
    phone?: StringFilter<"Parent"> | string
    occupation?: StringNullableFilter<"Parent"> | string | null
    relationship?: StringNullableFilter<"Parent"> | string | null
    address?: StringNullableFilter<"Parent"> | string | null
    isPrimaryContact?: BoolFilter<"Parent"> | boolean
    isEmergencyContact?: BoolFilter<"Parent"> | boolean
    preferredContactTime?: StringNullableFilter<"Parent"> | string | null
    createdAt?: DateTimeFilter<"Parent"> | Date | string
    updatedAt?: DateTimeFilter<"Parent"> | Date | string
    student?: XOR<StudentNullableScalarRelationFilter, StudentWhereInput> | null
    user?: UserToParentListRelationFilter
  }, "id" | "studentId">

  export type ParentOrderByWithAggregationInput = {
    id?: SortOrder
    studentId?: SortOrder
    institutionId?: SortOrder
    firstName?: SortOrder
    middleName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    occupation?: SortOrder
    relationship?: SortOrder
    address?: SortOrder
    isPrimaryContact?: SortOrder
    isEmergencyContact?: SortOrder
    preferredContactTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ParentCountOrderByAggregateInput
    _max?: ParentMaxOrderByAggregateInput
    _min?: ParentMinOrderByAggregateInput
  }

  export type ParentScalarWhereWithAggregatesInput = {
    AND?: ParentScalarWhereWithAggregatesInput | ParentScalarWhereWithAggregatesInput[]
    OR?: ParentScalarWhereWithAggregatesInput[]
    NOT?: ParentScalarWhereWithAggregatesInput | ParentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Parent"> | string
    studentId?: StringNullableWithAggregatesFilter<"Parent"> | string | null
    institutionId?: StringWithAggregatesFilter<"Parent"> | string
    firstName?: StringWithAggregatesFilter<"Parent"> | string
    middleName?: StringNullableWithAggregatesFilter<"Parent"> | string | null
    lastName?: StringWithAggregatesFilter<"Parent"> | string
    email?: StringWithAggregatesFilter<"Parent"> | string
    phone?: StringWithAggregatesFilter<"Parent"> | string
    occupation?: StringNullableWithAggregatesFilter<"Parent"> | string | null
    relationship?: StringNullableWithAggregatesFilter<"Parent"> | string | null
    address?: StringNullableWithAggregatesFilter<"Parent"> | string | null
    isPrimaryContact?: BoolWithAggregatesFilter<"Parent"> | boolean
    isEmergencyContact?: BoolWithAggregatesFilter<"Parent"> | boolean
    preferredContactTime?: StringNullableWithAggregatesFilter<"Parent"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Parent"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Parent"> | Date | string
  }

  export type StudentDocumentWhereInput = {
    AND?: StudentDocumentWhereInput | StudentDocumentWhereInput[]
    OR?: StudentDocumentWhereInput[]
    NOT?: StudentDocumentWhereInput | StudentDocumentWhereInput[]
    id?: StringFilter<"StudentDocument"> | string
    studentId?: StringNullableFilter<"StudentDocument"> | string | null
    documentType?: StringFilter<"StudentDocument"> | string
    documentName?: StringFilter<"StudentDocument"> | string
    documentUrl?: StringFilter<"StudentDocument"> | string
    fileSize?: IntNullableFilter<"StudentDocument"> | number | null
    mimeType?: StringNullableFilter<"StudentDocument"> | string | null
    uploadedAt?: DateTimeFilter<"StudentDocument"> | Date | string
    uploadedBy?: StringNullableFilter<"StudentDocument"> | string | null
    verified?: BoolFilter<"StudentDocument"> | boolean
    verifiedBy?: StringNullableFilter<"StudentDocument"> | string | null
    verifiedAt?: DateTimeNullableFilter<"StudentDocument"> | Date | string | null
    student?: XOR<StudentNullableScalarRelationFilter, StudentWhereInput> | null
  }

  export type StudentDocumentOrderByWithRelationInput = {
    id?: SortOrder
    studentId?: SortOrder
    documentType?: SortOrder
    documentName?: SortOrder
    documentUrl?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    uploadedAt?: SortOrder
    uploadedBy?: SortOrder
    verified?: SortOrder
    verifiedBy?: SortOrder
    verifiedAt?: SortOrder
    student?: StudentOrderByWithRelationInput
  }

  export type StudentDocumentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StudentDocumentWhereInput | StudentDocumentWhereInput[]
    OR?: StudentDocumentWhereInput[]
    NOT?: StudentDocumentWhereInput | StudentDocumentWhereInput[]
    studentId?: StringNullableFilter<"StudentDocument"> | string | null
    documentType?: StringFilter<"StudentDocument"> | string
    documentName?: StringFilter<"StudentDocument"> | string
    documentUrl?: StringFilter<"StudentDocument"> | string
    fileSize?: IntNullableFilter<"StudentDocument"> | number | null
    mimeType?: StringNullableFilter<"StudentDocument"> | string | null
    uploadedAt?: DateTimeFilter<"StudentDocument"> | Date | string
    uploadedBy?: StringNullableFilter<"StudentDocument"> | string | null
    verified?: BoolFilter<"StudentDocument"> | boolean
    verifiedBy?: StringNullableFilter<"StudentDocument"> | string | null
    verifiedAt?: DateTimeNullableFilter<"StudentDocument"> | Date | string | null
    student?: XOR<StudentNullableScalarRelationFilter, StudentWhereInput> | null
  }, "id">

  export type StudentDocumentOrderByWithAggregationInput = {
    id?: SortOrder
    studentId?: SortOrder
    documentType?: SortOrder
    documentName?: SortOrder
    documentUrl?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    uploadedAt?: SortOrder
    uploadedBy?: SortOrder
    verified?: SortOrder
    verifiedBy?: SortOrder
    verifiedAt?: SortOrder
    _count?: StudentDocumentCountOrderByAggregateInput
    _avg?: StudentDocumentAvgOrderByAggregateInput
    _max?: StudentDocumentMaxOrderByAggregateInput
    _min?: StudentDocumentMinOrderByAggregateInput
    _sum?: StudentDocumentSumOrderByAggregateInput
  }

  export type StudentDocumentScalarWhereWithAggregatesInput = {
    AND?: StudentDocumentScalarWhereWithAggregatesInput | StudentDocumentScalarWhereWithAggregatesInput[]
    OR?: StudentDocumentScalarWhereWithAggregatesInput[]
    NOT?: StudentDocumentScalarWhereWithAggregatesInput | StudentDocumentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StudentDocument"> | string
    studentId?: StringNullableWithAggregatesFilter<"StudentDocument"> | string | null
    documentType?: StringWithAggregatesFilter<"StudentDocument"> | string
    documentName?: StringWithAggregatesFilter<"StudentDocument"> | string
    documentUrl?: StringWithAggregatesFilter<"StudentDocument"> | string
    fileSize?: IntNullableWithAggregatesFilter<"StudentDocument"> | number | null
    mimeType?: StringNullableWithAggregatesFilter<"StudentDocument"> | string | null
    uploadedAt?: DateTimeWithAggregatesFilter<"StudentDocument"> | Date | string
    uploadedBy?: StringNullableWithAggregatesFilter<"StudentDocument"> | string | null
    verified?: BoolWithAggregatesFilter<"StudentDocument"> | boolean
    verifiedBy?: StringNullableWithAggregatesFilter<"StudentDocument"> | string | null
    verifiedAt?: DateTimeNullableWithAggregatesFilter<"StudentDocument"> | Date | string | null
  }

  export type TeacherOnInstitutionWhereInput = {
    AND?: TeacherOnInstitutionWhereInput | TeacherOnInstitutionWhereInput[]
    OR?: TeacherOnInstitutionWhereInput[]
    NOT?: TeacherOnInstitutionWhereInput | TeacherOnInstitutionWhereInput[]
    id?: StringFilter<"TeacherOnInstitution"> | string
    teacherId?: StringFilter<"TeacherOnInstitution"> | string
    institutionId?: StringFilter<"TeacherOnInstitution"> | string
    teacher?: XOR<TeacherScalarRelationFilter, TeacherWhereInput>
    institution?: XOR<InstitutionScalarRelationFilter, InstitutionWhereInput>
  }

  export type TeacherOnInstitutionOrderByWithRelationInput = {
    id?: SortOrder
    teacherId?: SortOrder
    institutionId?: SortOrder
    teacher?: TeacherOrderByWithRelationInput
    institution?: InstitutionOrderByWithRelationInput
  }

  export type TeacherOnInstitutionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TeacherOnInstitutionWhereInput | TeacherOnInstitutionWhereInput[]
    OR?: TeacherOnInstitutionWhereInput[]
    NOT?: TeacherOnInstitutionWhereInput | TeacherOnInstitutionWhereInput[]
    teacherId?: StringFilter<"TeacherOnInstitution"> | string
    institutionId?: StringFilter<"TeacherOnInstitution"> | string
    teacher?: XOR<TeacherScalarRelationFilter, TeacherWhereInput>
    institution?: XOR<InstitutionScalarRelationFilter, InstitutionWhereInput>
  }, "id">

  export type TeacherOnInstitutionOrderByWithAggregationInput = {
    id?: SortOrder
    teacherId?: SortOrder
    institutionId?: SortOrder
    _count?: TeacherOnInstitutionCountOrderByAggregateInput
    _max?: TeacherOnInstitutionMaxOrderByAggregateInput
    _min?: TeacherOnInstitutionMinOrderByAggregateInput
  }

  export type TeacherOnInstitutionScalarWhereWithAggregatesInput = {
    AND?: TeacherOnInstitutionScalarWhereWithAggregatesInput | TeacherOnInstitutionScalarWhereWithAggregatesInput[]
    OR?: TeacherOnInstitutionScalarWhereWithAggregatesInput[]
    NOT?: TeacherOnInstitutionScalarWhereWithAggregatesInput | TeacherOnInstitutionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TeacherOnInstitution"> | string
    teacherId?: StringWithAggregatesFilter<"TeacherOnInstitution"> | string
    institutionId?: StringWithAggregatesFilter<"TeacherOnInstitution"> | string
  }

  export type TeacherWhereInput = {
    AND?: TeacherWhereInput | TeacherWhereInput[]
    OR?: TeacherWhereInput[]
    NOT?: TeacherWhereInput | TeacherWhereInput[]
    id?: StringFilter<"Teacher"> | string
    userId?: StringNullableFilter<"Teacher"> | string | null
    firstName?: StringFilter<"Teacher"> | string
    middleName?: StringNullableFilter<"Teacher"> | string | null
    lastName?: StringFilter<"Teacher"> | string
    email?: StringNullableFilter<"Teacher"> | string | null
    phone?: StringFilter<"Teacher"> | string
    avatar?: StringNullableFilter<"Teacher"> | string | null
    employeeNumber?: StringNullableFilter<"Teacher"> | string | null
    subjects?: StringNullableListFilter<"Teacher">
    qualification?: StringNullableFilter<"Teacher"> | string | null
    experience?: IntNullableFilter<"Teacher"> | number | null
    salary?: FloatNullableFilter<"Teacher"> | number | null
    joinDate?: DateTimeNullableFilter<"Teacher"> | Date | string | null
    createdAt?: DateTimeFilter<"Teacher"> | Date | string
    updatedAt?: DateTimeFilter<"Teacher"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    institution?: TeacherOnInstitutionListRelationFilter
    classes?: TeacherOnClassListRelationFilter
  }

  export type TeacherOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    firstName?: SortOrder
    middleName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    avatar?: SortOrder
    employeeNumber?: SortOrder
    subjects?: SortOrder
    qualification?: SortOrder
    experience?: SortOrder
    salary?: SortOrder
    joinDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    institution?: TeacherOnInstitutionOrderByRelationAggregateInput
    classes?: TeacherOnClassOrderByRelationAggregateInput
  }

  export type TeacherWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TeacherWhereInput | TeacherWhereInput[]
    OR?: TeacherWhereInput[]
    NOT?: TeacherWhereInput | TeacherWhereInput[]
    userId?: StringNullableFilter<"Teacher"> | string | null
    firstName?: StringFilter<"Teacher"> | string
    middleName?: StringNullableFilter<"Teacher"> | string | null
    lastName?: StringFilter<"Teacher"> | string
    email?: StringNullableFilter<"Teacher"> | string | null
    phone?: StringFilter<"Teacher"> | string
    avatar?: StringNullableFilter<"Teacher"> | string | null
    employeeNumber?: StringNullableFilter<"Teacher"> | string | null
    subjects?: StringNullableListFilter<"Teacher">
    qualification?: StringNullableFilter<"Teacher"> | string | null
    experience?: IntNullableFilter<"Teacher"> | number | null
    salary?: FloatNullableFilter<"Teacher"> | number | null
    joinDate?: DateTimeNullableFilter<"Teacher"> | Date | string | null
    createdAt?: DateTimeFilter<"Teacher"> | Date | string
    updatedAt?: DateTimeFilter<"Teacher"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    institution?: TeacherOnInstitutionListRelationFilter
    classes?: TeacherOnClassListRelationFilter
  }, "id">

  export type TeacherOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    firstName?: SortOrder
    middleName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    avatar?: SortOrder
    employeeNumber?: SortOrder
    subjects?: SortOrder
    qualification?: SortOrder
    experience?: SortOrder
    salary?: SortOrder
    joinDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TeacherCountOrderByAggregateInput
    _avg?: TeacherAvgOrderByAggregateInput
    _max?: TeacherMaxOrderByAggregateInput
    _min?: TeacherMinOrderByAggregateInput
    _sum?: TeacherSumOrderByAggregateInput
  }

  export type TeacherScalarWhereWithAggregatesInput = {
    AND?: TeacherScalarWhereWithAggregatesInput | TeacherScalarWhereWithAggregatesInput[]
    OR?: TeacherScalarWhereWithAggregatesInput[]
    NOT?: TeacherScalarWhereWithAggregatesInput | TeacherScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Teacher"> | string
    userId?: StringNullableWithAggregatesFilter<"Teacher"> | string | null
    firstName?: StringWithAggregatesFilter<"Teacher"> | string
    middleName?: StringNullableWithAggregatesFilter<"Teacher"> | string | null
    lastName?: StringWithAggregatesFilter<"Teacher"> | string
    email?: StringNullableWithAggregatesFilter<"Teacher"> | string | null
    phone?: StringWithAggregatesFilter<"Teacher"> | string
    avatar?: StringNullableWithAggregatesFilter<"Teacher"> | string | null
    employeeNumber?: StringNullableWithAggregatesFilter<"Teacher"> | string | null
    subjects?: StringNullableListFilter<"Teacher">
    qualification?: StringNullableWithAggregatesFilter<"Teacher"> | string | null
    experience?: IntNullableWithAggregatesFilter<"Teacher"> | number | null
    salary?: FloatNullableWithAggregatesFilter<"Teacher"> | number | null
    joinDate?: DateTimeNullableWithAggregatesFilter<"Teacher"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Teacher"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Teacher"> | Date | string
  }

  export type TeacherOnClassWhereInput = {
    AND?: TeacherOnClassWhereInput | TeacherOnClassWhereInput[]
    OR?: TeacherOnClassWhereInput[]
    NOT?: TeacherOnClassWhereInput | TeacherOnClassWhereInput[]
    id?: StringFilter<"TeacherOnClass"> | string
    teacherId?: StringFilter<"TeacherOnClass"> | string
    classId?: StringFilter<"TeacherOnClass"> | string
    teacher?: XOR<TeacherScalarRelationFilter, TeacherWhereInput>
    class?: XOR<ClassScalarRelationFilter, ClassWhereInput>
  }

  export type TeacherOnClassOrderByWithRelationInput = {
    id?: SortOrder
    teacherId?: SortOrder
    classId?: SortOrder
    teacher?: TeacherOrderByWithRelationInput
    class?: ClassOrderByWithRelationInput
  }

  export type TeacherOnClassWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TeacherOnClassWhereInput | TeacherOnClassWhereInput[]
    OR?: TeacherOnClassWhereInput[]
    NOT?: TeacherOnClassWhereInput | TeacherOnClassWhereInput[]
    teacherId?: StringFilter<"TeacherOnClass"> | string
    classId?: StringFilter<"TeacherOnClass"> | string
    teacher?: XOR<TeacherScalarRelationFilter, TeacherWhereInput>
    class?: XOR<ClassScalarRelationFilter, ClassWhereInput>
  }, "id">

  export type TeacherOnClassOrderByWithAggregationInput = {
    id?: SortOrder
    teacherId?: SortOrder
    classId?: SortOrder
    _count?: TeacherOnClassCountOrderByAggregateInput
    _max?: TeacherOnClassMaxOrderByAggregateInput
    _min?: TeacherOnClassMinOrderByAggregateInput
  }

  export type TeacherOnClassScalarWhereWithAggregatesInput = {
    AND?: TeacherOnClassScalarWhereWithAggregatesInput | TeacherOnClassScalarWhereWithAggregatesInput[]
    OR?: TeacherOnClassScalarWhereWithAggregatesInput[]
    NOT?: TeacherOnClassScalarWhereWithAggregatesInput | TeacherOnClassScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TeacherOnClass"> | string
    teacherId?: StringWithAggregatesFilter<"TeacherOnClass"> | string
    classId?: StringWithAggregatesFilter<"TeacherOnClass"> | string
  }

  export type ClassWhereInput = {
    AND?: ClassWhereInput | ClassWhereInput[]
    OR?: ClassWhereInput[]
    NOT?: ClassWhereInput | ClassWhereInput[]
    id?: StringFilter<"Class"> | string
    institutionId?: StringFilter<"Class"> | string
    name?: StringFilter<"Class"> | string
    section?: StringNullableFilter<"Class"> | string | null
    academicYear?: StringNullableFilter<"Class"> | string | null
    capacity?: IntNullableFilter<"Class"> | number | null
    roomNumber?: StringNullableFilter<"Class"> | string | null
    createdAt?: DateTimeFilter<"Class"> | Date | string
    updatedAt?: DateTimeFilter<"Class"> | Date | string
    teacherIds?: StringNullableListFilter<"Class">
    institution?: XOR<InstitutionScalarRelationFilter, InstitutionWhereInput>
    students?: StudentListRelationFilter
    teachers?: TeacherOnClassListRelationFilter
    enrollments?: EnrollmentListRelationFilter
    attendances?: AttendanceListRelationFilter
    timetables?: TimetableListRelationFilter
  }

  export type ClassOrderByWithRelationInput = {
    id?: SortOrder
    institutionId?: SortOrder
    name?: SortOrder
    section?: SortOrder
    academicYear?: SortOrder
    capacity?: SortOrder
    roomNumber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    teacherIds?: SortOrder
    institution?: InstitutionOrderByWithRelationInput
    students?: StudentOrderByRelationAggregateInput
    teachers?: TeacherOnClassOrderByRelationAggregateInput
    enrollments?: EnrollmentOrderByRelationAggregateInput
    attendances?: AttendanceOrderByRelationAggregateInput
    timetables?: TimetableOrderByRelationAggregateInput
  }

  export type ClassWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ClassWhereInput | ClassWhereInput[]
    OR?: ClassWhereInput[]
    NOT?: ClassWhereInput | ClassWhereInput[]
    institutionId?: StringFilter<"Class"> | string
    name?: StringFilter<"Class"> | string
    section?: StringNullableFilter<"Class"> | string | null
    academicYear?: StringNullableFilter<"Class"> | string | null
    capacity?: IntNullableFilter<"Class"> | number | null
    roomNumber?: StringNullableFilter<"Class"> | string | null
    createdAt?: DateTimeFilter<"Class"> | Date | string
    updatedAt?: DateTimeFilter<"Class"> | Date | string
    teacherIds?: StringNullableListFilter<"Class">
    institution?: XOR<InstitutionScalarRelationFilter, InstitutionWhereInput>
    students?: StudentListRelationFilter
    teachers?: TeacherOnClassListRelationFilter
    enrollments?: EnrollmentListRelationFilter
    attendances?: AttendanceListRelationFilter
    timetables?: TimetableListRelationFilter
  }, "id">

  export type ClassOrderByWithAggregationInput = {
    id?: SortOrder
    institutionId?: SortOrder
    name?: SortOrder
    section?: SortOrder
    academicYear?: SortOrder
    capacity?: SortOrder
    roomNumber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    teacherIds?: SortOrder
    _count?: ClassCountOrderByAggregateInput
    _avg?: ClassAvgOrderByAggregateInput
    _max?: ClassMaxOrderByAggregateInput
    _min?: ClassMinOrderByAggregateInput
    _sum?: ClassSumOrderByAggregateInput
  }

  export type ClassScalarWhereWithAggregatesInput = {
    AND?: ClassScalarWhereWithAggregatesInput | ClassScalarWhereWithAggregatesInput[]
    OR?: ClassScalarWhereWithAggregatesInput[]
    NOT?: ClassScalarWhereWithAggregatesInput | ClassScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Class"> | string
    institutionId?: StringWithAggregatesFilter<"Class"> | string
    name?: StringWithAggregatesFilter<"Class"> | string
    section?: StringNullableWithAggregatesFilter<"Class"> | string | null
    academicYear?: StringNullableWithAggregatesFilter<"Class"> | string | null
    capacity?: IntNullableWithAggregatesFilter<"Class"> | number | null
    roomNumber?: StringNullableWithAggregatesFilter<"Class"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Class"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Class"> | Date | string
    teacherIds?: StringNullableListFilter<"Class">
  }

  export type EnrollmentWhereInput = {
    AND?: EnrollmentWhereInput | EnrollmentWhereInput[]
    OR?: EnrollmentWhereInput[]
    NOT?: EnrollmentWhereInput | EnrollmentWhereInput[]
    id?: StringFilter<"Enrollment"> | string
    studentId?: StringFilter<"Enrollment"> | string
    classId?: StringFilter<"Enrollment"> | string
    academicYear?: StringFilter<"Enrollment"> | string
    enrollDate?: DateTimeFilter<"Enrollment"> | Date | string
    status?: StringFilter<"Enrollment"> | string
    createdAt?: DateTimeFilter<"Enrollment"> | Date | string
    updatedAt?: DateTimeFilter<"Enrollment"> | Date | string
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    class?: XOR<ClassScalarRelationFilter, ClassWhereInput>
  }

  export type EnrollmentOrderByWithRelationInput = {
    id?: SortOrder
    studentId?: SortOrder
    classId?: SortOrder
    academicYear?: SortOrder
    enrollDate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    student?: StudentOrderByWithRelationInput
    class?: ClassOrderByWithRelationInput
  }

  export type EnrollmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EnrollmentWhereInput | EnrollmentWhereInput[]
    OR?: EnrollmentWhereInput[]
    NOT?: EnrollmentWhereInput | EnrollmentWhereInput[]
    studentId?: StringFilter<"Enrollment"> | string
    classId?: StringFilter<"Enrollment"> | string
    academicYear?: StringFilter<"Enrollment"> | string
    enrollDate?: DateTimeFilter<"Enrollment"> | Date | string
    status?: StringFilter<"Enrollment"> | string
    createdAt?: DateTimeFilter<"Enrollment"> | Date | string
    updatedAt?: DateTimeFilter<"Enrollment"> | Date | string
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    class?: XOR<ClassScalarRelationFilter, ClassWhereInput>
  }, "id">

  export type EnrollmentOrderByWithAggregationInput = {
    id?: SortOrder
    studentId?: SortOrder
    classId?: SortOrder
    academicYear?: SortOrder
    enrollDate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EnrollmentCountOrderByAggregateInput
    _max?: EnrollmentMaxOrderByAggregateInput
    _min?: EnrollmentMinOrderByAggregateInput
  }

  export type EnrollmentScalarWhereWithAggregatesInput = {
    AND?: EnrollmentScalarWhereWithAggregatesInput | EnrollmentScalarWhereWithAggregatesInput[]
    OR?: EnrollmentScalarWhereWithAggregatesInput[]
    NOT?: EnrollmentScalarWhereWithAggregatesInput | EnrollmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Enrollment"> | string
    studentId?: StringWithAggregatesFilter<"Enrollment"> | string
    classId?: StringWithAggregatesFilter<"Enrollment"> | string
    academicYear?: StringWithAggregatesFilter<"Enrollment"> | string
    enrollDate?: DateTimeWithAggregatesFilter<"Enrollment"> | Date | string
    status?: StringWithAggregatesFilter<"Enrollment"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Enrollment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Enrollment"> | Date | string
  }

  export type AttendanceWhereInput = {
    AND?: AttendanceWhereInput | AttendanceWhereInput[]
    OR?: AttendanceWhereInput[]
    NOT?: AttendanceWhereInput | AttendanceWhereInput[]
    id?: StringFilter<"Attendance"> | string
    studentId?: StringFilter<"Attendance"> | string
    classId?: StringFilter<"Attendance"> | string
    date?: DateTimeFilter<"Attendance"> | Date | string
    status?: StringFilter<"Attendance"> | string
    remarks?: StringNullableFilter<"Attendance"> | string | null
    createdAt?: DateTimeFilter<"Attendance"> | Date | string
    updatedAt?: DateTimeFilter<"Attendance"> | Date | string
    class?: XOR<ClassScalarRelationFilter, ClassWhereInput>
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
  }

  export type AttendanceOrderByWithRelationInput = {
    id?: SortOrder
    studentId?: SortOrder
    classId?: SortOrder
    date?: SortOrder
    status?: SortOrder
    remarks?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    class?: ClassOrderByWithRelationInput
    student?: StudentOrderByWithRelationInput
  }

  export type AttendanceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AttendanceWhereInput | AttendanceWhereInput[]
    OR?: AttendanceWhereInput[]
    NOT?: AttendanceWhereInput | AttendanceWhereInput[]
    studentId?: StringFilter<"Attendance"> | string
    classId?: StringFilter<"Attendance"> | string
    date?: DateTimeFilter<"Attendance"> | Date | string
    status?: StringFilter<"Attendance"> | string
    remarks?: StringNullableFilter<"Attendance"> | string | null
    createdAt?: DateTimeFilter<"Attendance"> | Date | string
    updatedAt?: DateTimeFilter<"Attendance"> | Date | string
    class?: XOR<ClassScalarRelationFilter, ClassWhereInput>
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
  }, "id">

  export type AttendanceOrderByWithAggregationInput = {
    id?: SortOrder
    studentId?: SortOrder
    classId?: SortOrder
    date?: SortOrder
    status?: SortOrder
    remarks?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AttendanceCountOrderByAggregateInput
    _max?: AttendanceMaxOrderByAggregateInput
    _min?: AttendanceMinOrderByAggregateInput
  }

  export type AttendanceScalarWhereWithAggregatesInput = {
    AND?: AttendanceScalarWhereWithAggregatesInput | AttendanceScalarWhereWithAggregatesInput[]
    OR?: AttendanceScalarWhereWithAggregatesInput[]
    NOT?: AttendanceScalarWhereWithAggregatesInput | AttendanceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Attendance"> | string
    studentId?: StringWithAggregatesFilter<"Attendance"> | string
    classId?: StringWithAggregatesFilter<"Attendance"> | string
    date?: DateTimeWithAggregatesFilter<"Attendance"> | Date | string
    status?: StringWithAggregatesFilter<"Attendance"> | string
    remarks?: StringNullableWithAggregatesFilter<"Attendance"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Attendance"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Attendance"> | Date | string
  }

  export type GradeWhereInput = {
    AND?: GradeWhereInput | GradeWhereInput[]
    OR?: GradeWhereInput[]
    NOT?: GradeWhereInput | GradeWhereInput[]
    id?: StringFilter<"Grade"> | string
    studentId?: StringFilter<"Grade"> | string
    subject?: StringFilter<"Grade"> | string
    examType?: StringNullableFilter<"Grade"> | string | null
    score?: FloatFilter<"Grade"> | number
    maxScore?: FloatFilter<"Grade"> | number
    grade?: StringNullableFilter<"Grade"> | string | null
    term?: StringFilter<"Grade"> | string
    academicYear?: StringFilter<"Grade"> | string
    remarks?: StringNullableFilter<"Grade"> | string | null
    createdAt?: DateTimeFilter<"Grade"> | Date | string
    updatedAt?: DateTimeFilter<"Grade"> | Date | string
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
  }

  export type GradeOrderByWithRelationInput = {
    id?: SortOrder
    studentId?: SortOrder
    subject?: SortOrder
    examType?: SortOrder
    score?: SortOrder
    maxScore?: SortOrder
    grade?: SortOrder
    term?: SortOrder
    academicYear?: SortOrder
    remarks?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    student?: StudentOrderByWithRelationInput
  }

  export type GradeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: GradeWhereInput | GradeWhereInput[]
    OR?: GradeWhereInput[]
    NOT?: GradeWhereInput | GradeWhereInput[]
    studentId?: StringFilter<"Grade"> | string
    subject?: StringFilter<"Grade"> | string
    examType?: StringNullableFilter<"Grade"> | string | null
    score?: FloatFilter<"Grade"> | number
    maxScore?: FloatFilter<"Grade"> | number
    grade?: StringNullableFilter<"Grade"> | string | null
    term?: StringFilter<"Grade"> | string
    academicYear?: StringFilter<"Grade"> | string
    remarks?: StringNullableFilter<"Grade"> | string | null
    createdAt?: DateTimeFilter<"Grade"> | Date | string
    updatedAt?: DateTimeFilter<"Grade"> | Date | string
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
  }, "id">

  export type GradeOrderByWithAggregationInput = {
    id?: SortOrder
    studentId?: SortOrder
    subject?: SortOrder
    examType?: SortOrder
    score?: SortOrder
    maxScore?: SortOrder
    grade?: SortOrder
    term?: SortOrder
    academicYear?: SortOrder
    remarks?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: GradeCountOrderByAggregateInput
    _avg?: GradeAvgOrderByAggregateInput
    _max?: GradeMaxOrderByAggregateInput
    _min?: GradeMinOrderByAggregateInput
    _sum?: GradeSumOrderByAggregateInput
  }

  export type GradeScalarWhereWithAggregatesInput = {
    AND?: GradeScalarWhereWithAggregatesInput | GradeScalarWhereWithAggregatesInput[]
    OR?: GradeScalarWhereWithAggregatesInput[]
    NOT?: GradeScalarWhereWithAggregatesInput | GradeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Grade"> | string
    studentId?: StringWithAggregatesFilter<"Grade"> | string
    subject?: StringWithAggregatesFilter<"Grade"> | string
    examType?: StringNullableWithAggregatesFilter<"Grade"> | string | null
    score?: FloatWithAggregatesFilter<"Grade"> | number
    maxScore?: FloatWithAggregatesFilter<"Grade"> | number
    grade?: StringNullableWithAggregatesFilter<"Grade"> | string | null
    term?: StringWithAggregatesFilter<"Grade"> | string
    academicYear?: StringWithAggregatesFilter<"Grade"> | string
    remarks?: StringNullableWithAggregatesFilter<"Grade"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Grade"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Grade"> | Date | string
  }

  export type TimetableWhereInput = {
    AND?: TimetableWhereInput | TimetableWhereInput[]
    OR?: TimetableWhereInput[]
    NOT?: TimetableWhereInput | TimetableWhereInput[]
    id?: StringFilter<"Timetable"> | string
    classId?: StringFilter<"Timetable"> | string
    dayOfWeek?: IntFilter<"Timetable"> | number
    startTime?: StringFilter<"Timetable"> | string
    endTime?: StringFilter<"Timetable"> | string
    subject?: StringFilter<"Timetable"> | string
    teacherId?: StringNullableFilter<"Timetable"> | string | null
    room?: StringNullableFilter<"Timetable"> | string | null
    createdAt?: DateTimeFilter<"Timetable"> | Date | string
    updatedAt?: DateTimeFilter<"Timetable"> | Date | string
    class?: XOR<ClassScalarRelationFilter, ClassWhereInput>
  }

  export type TimetableOrderByWithRelationInput = {
    id?: SortOrder
    classId?: SortOrder
    dayOfWeek?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    subject?: SortOrder
    teacherId?: SortOrder
    room?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    class?: ClassOrderByWithRelationInput
  }

  export type TimetableWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TimetableWhereInput | TimetableWhereInput[]
    OR?: TimetableWhereInput[]
    NOT?: TimetableWhereInput | TimetableWhereInput[]
    classId?: StringFilter<"Timetable"> | string
    dayOfWeek?: IntFilter<"Timetable"> | number
    startTime?: StringFilter<"Timetable"> | string
    endTime?: StringFilter<"Timetable"> | string
    subject?: StringFilter<"Timetable"> | string
    teacherId?: StringNullableFilter<"Timetable"> | string | null
    room?: StringNullableFilter<"Timetable"> | string | null
    createdAt?: DateTimeFilter<"Timetable"> | Date | string
    updatedAt?: DateTimeFilter<"Timetable"> | Date | string
    class?: XOR<ClassScalarRelationFilter, ClassWhereInput>
  }, "id">

  export type TimetableOrderByWithAggregationInput = {
    id?: SortOrder
    classId?: SortOrder
    dayOfWeek?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    subject?: SortOrder
    teacherId?: SortOrder
    room?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TimetableCountOrderByAggregateInput
    _avg?: TimetableAvgOrderByAggregateInput
    _max?: TimetableMaxOrderByAggregateInput
    _min?: TimetableMinOrderByAggregateInput
    _sum?: TimetableSumOrderByAggregateInput
  }

  export type TimetableScalarWhereWithAggregatesInput = {
    AND?: TimetableScalarWhereWithAggregatesInput | TimetableScalarWhereWithAggregatesInput[]
    OR?: TimetableScalarWhereWithAggregatesInput[]
    NOT?: TimetableScalarWhereWithAggregatesInput | TimetableScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Timetable"> | string
    classId?: StringWithAggregatesFilter<"Timetable"> | string
    dayOfWeek?: IntWithAggregatesFilter<"Timetable"> | number
    startTime?: StringWithAggregatesFilter<"Timetable"> | string
    endTime?: StringWithAggregatesFilter<"Timetable"> | string
    subject?: StringWithAggregatesFilter<"Timetable"> | string
    teacherId?: StringNullableWithAggregatesFilter<"Timetable"> | string | null
    room?: StringNullableWithAggregatesFilter<"Timetable"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Timetable"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Timetable"> | Date | string
  }

  export type InvoiceWhereInput = {
    AND?: InvoiceWhereInput | InvoiceWhereInput[]
    OR?: InvoiceWhereInput[]
    NOT?: InvoiceWhereInput | InvoiceWhereInput[]
    id?: StringFilter<"Invoice"> | string
    institutionId?: StringFilter<"Invoice"> | string
    studentId?: StringNullableFilter<"Invoice"> | string | null
    invoiceNumber?: StringFilter<"Invoice"> | string
    description?: StringNullableFilter<"Invoice"> | string | null
    amount?: FloatFilter<"Invoice"> | number
    amountPaid?: FloatFilter<"Invoice"> | number
    status?: StringFilter<"Invoice"> | string
    dueDate?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    paidDate?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    paymentMethod?: StringNullableFilter<"Invoice"> | string | null
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeFilter<"Invoice"> | Date | string
    institution?: XOR<InstitutionNullableScalarRelationFilter, InstitutionWhereInput> | null
    student?: XOR<StudentNullableScalarRelationFilter, StudentWhereInput> | null
  }

  export type InvoiceOrderByWithRelationInput = {
    id?: SortOrder
    institutionId?: SortOrder
    studentId?: SortOrder
    invoiceNumber?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    amountPaid?: SortOrder
    status?: SortOrder
    dueDate?: SortOrder
    paidDate?: SortOrder
    paymentMethod?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    institution?: InstitutionOrderByWithRelationInput
    student?: StudentOrderByWithRelationInput
  }

  export type InvoiceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    invoiceNumber?: string
    AND?: InvoiceWhereInput | InvoiceWhereInput[]
    OR?: InvoiceWhereInput[]
    NOT?: InvoiceWhereInput | InvoiceWhereInput[]
    institutionId?: StringFilter<"Invoice"> | string
    studentId?: StringNullableFilter<"Invoice"> | string | null
    description?: StringNullableFilter<"Invoice"> | string | null
    amount?: FloatFilter<"Invoice"> | number
    amountPaid?: FloatFilter<"Invoice"> | number
    status?: StringFilter<"Invoice"> | string
    dueDate?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    paidDate?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    paymentMethod?: StringNullableFilter<"Invoice"> | string | null
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeFilter<"Invoice"> | Date | string
    institution?: XOR<InstitutionNullableScalarRelationFilter, InstitutionWhereInput> | null
    student?: XOR<StudentNullableScalarRelationFilter, StudentWhereInput> | null
  }, "id" | "invoiceNumber">

  export type InvoiceOrderByWithAggregationInput = {
    id?: SortOrder
    institutionId?: SortOrder
    studentId?: SortOrder
    invoiceNumber?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    amountPaid?: SortOrder
    status?: SortOrder
    dueDate?: SortOrder
    paidDate?: SortOrder
    paymentMethod?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: InvoiceCountOrderByAggregateInput
    _avg?: InvoiceAvgOrderByAggregateInput
    _max?: InvoiceMaxOrderByAggregateInput
    _min?: InvoiceMinOrderByAggregateInput
    _sum?: InvoiceSumOrderByAggregateInput
  }

  export type InvoiceScalarWhereWithAggregatesInput = {
    AND?: InvoiceScalarWhereWithAggregatesInput | InvoiceScalarWhereWithAggregatesInput[]
    OR?: InvoiceScalarWhereWithAggregatesInput[]
    NOT?: InvoiceScalarWhereWithAggregatesInput | InvoiceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Invoice"> | string
    institutionId?: StringWithAggregatesFilter<"Invoice"> | string
    studentId?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    invoiceNumber?: StringWithAggregatesFilter<"Invoice"> | string
    description?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    amount?: FloatWithAggregatesFilter<"Invoice"> | number
    amountPaid?: FloatWithAggregatesFilter<"Invoice"> | number
    status?: StringWithAggregatesFilter<"Invoice"> | string
    dueDate?: DateTimeNullableWithAggregatesFilter<"Invoice"> | Date | string | null
    paidDate?: DateTimeNullableWithAggregatesFilter<"Invoice"> | Date | string | null
    paymentMethod?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
  }

  export type MessageWhereInput = {
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    id?: StringFilter<"Message"> | string
    fromUserId?: StringFilter<"Message"> | string
    toUserId?: StringFilter<"Message"> | string
    institutionId?: StringFilter<"Message"> | string
    subject?: StringNullableFilter<"Message"> | string | null
    body?: StringFilter<"Message"> | string
    isRead?: BoolFilter<"Message"> | boolean
    readAt?: DateTimeNullableFilter<"Message"> | Date | string | null
    createdAt?: DateTimeFilter<"Message"> | Date | string
    updatedAt?: DateTimeFilter<"Message"> | Date | string
    fromUser?: XOR<UserScalarRelationFilter, UserWhereInput>
    institution?: XOR<InstitutionScalarRelationFilter, InstitutionWhereInput>
  }

  export type MessageOrderByWithRelationInput = {
    id?: SortOrder
    fromUserId?: SortOrder
    toUserId?: SortOrder
    institutionId?: SortOrder
    subject?: SortOrder
    body?: SortOrder
    isRead?: SortOrder
    readAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    fromUser?: UserOrderByWithRelationInput
    institution?: InstitutionOrderByWithRelationInput
  }

  export type MessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    fromUserId?: StringFilter<"Message"> | string
    toUserId?: StringFilter<"Message"> | string
    institutionId?: StringFilter<"Message"> | string
    subject?: StringNullableFilter<"Message"> | string | null
    body?: StringFilter<"Message"> | string
    isRead?: BoolFilter<"Message"> | boolean
    readAt?: DateTimeNullableFilter<"Message"> | Date | string | null
    createdAt?: DateTimeFilter<"Message"> | Date | string
    updatedAt?: DateTimeFilter<"Message"> | Date | string
    fromUser?: XOR<UserScalarRelationFilter, UserWhereInput>
    institution?: XOR<InstitutionScalarRelationFilter, InstitutionWhereInput>
  }, "id">

  export type MessageOrderByWithAggregationInput = {
    id?: SortOrder
    fromUserId?: SortOrder
    toUserId?: SortOrder
    institutionId?: SortOrder
    subject?: SortOrder
    body?: SortOrder
    isRead?: SortOrder
    readAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MessageCountOrderByAggregateInput
    _max?: MessageMaxOrderByAggregateInput
    _min?: MessageMinOrderByAggregateInput
  }

  export type MessageScalarWhereWithAggregatesInput = {
    AND?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    OR?: MessageScalarWhereWithAggregatesInput[]
    NOT?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Message"> | string
    fromUserId?: StringWithAggregatesFilter<"Message"> | string
    toUserId?: StringWithAggregatesFilter<"Message"> | string
    institutionId?: StringWithAggregatesFilter<"Message"> | string
    subject?: StringNullableWithAggregatesFilter<"Message"> | string | null
    body?: StringWithAggregatesFilter<"Message"> | string
    isRead?: BoolWithAggregatesFilter<"Message"> | boolean
    readAt?: DateTimeNullableWithAggregatesFilter<"Message"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Message"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Message"> | Date | string
  }

  export type InstitutionCreateInput = {
    id?: string
    name: string
    institutionType?: $Enums.InstitutionType
    address: string
    city: string
    state: string
    country: string
    phone: string
    email: string
    website?: string | null
    plan?: $Enums.InstitutionPlan
    subscriptionStatus?: $Enums.SubscriptionStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UsersOnInstitutionCreateNestedManyWithoutInstitutionInput
    classes?: ClassCreateNestedManyWithoutInstitutionInput
    students?: StudentCreateNestedManyWithoutInstitutionInput
    teachers?: TeacherOnInstitutionCreateNestedManyWithoutInstitutionInput
    invoices?: InvoiceCreateNestedManyWithoutInstitutionInput
    messages?: MessageCreateNestedManyWithoutInstitutionInput
  }

  export type InstitutionUncheckedCreateInput = {
    id?: string
    name: string
    institutionType?: $Enums.InstitutionType
    address: string
    city: string
    state: string
    country: string
    phone: string
    email: string
    website?: string | null
    plan?: $Enums.InstitutionPlan
    subscriptionStatus?: $Enums.SubscriptionStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UsersOnInstitutionUncheckedCreateNestedManyWithoutInstitutionInput
    classes?: ClassUncheckedCreateNestedManyWithoutInstitutionInput
    students?: StudentUncheckedCreateNestedManyWithoutInstitutionInput
    teachers?: TeacherOnInstitutionUncheckedCreateNestedManyWithoutInstitutionInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutInstitutionInput
    messages?: MessageUncheckedCreateNestedManyWithoutInstitutionInput
  }

  export type InstitutionUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    institutionType?: EnumInstitutionTypeFieldUpdateOperationsInput | $Enums.InstitutionType
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: EnumInstitutionPlanFieldUpdateOperationsInput | $Enums.InstitutionPlan
    subscriptionStatus?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UsersOnInstitutionUpdateManyWithoutInstitutionNestedInput
    classes?: ClassUpdateManyWithoutInstitutionNestedInput
    students?: StudentUpdateManyWithoutInstitutionNestedInput
    teachers?: TeacherOnInstitutionUpdateManyWithoutInstitutionNestedInput
    invoices?: InvoiceUpdateManyWithoutInstitutionNestedInput
    messages?: MessageUpdateManyWithoutInstitutionNestedInput
  }

  export type InstitutionUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    institutionType?: EnumInstitutionTypeFieldUpdateOperationsInput | $Enums.InstitutionType
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: EnumInstitutionPlanFieldUpdateOperationsInput | $Enums.InstitutionPlan
    subscriptionStatus?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UsersOnInstitutionUncheckedUpdateManyWithoutInstitutionNestedInput
    classes?: ClassUncheckedUpdateManyWithoutInstitutionNestedInput
    students?: StudentUncheckedUpdateManyWithoutInstitutionNestedInput
    teachers?: TeacherOnInstitutionUncheckedUpdateManyWithoutInstitutionNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutInstitutionNestedInput
    messages?: MessageUncheckedUpdateManyWithoutInstitutionNestedInput
  }

  export type InstitutionCreateManyInput = {
    id?: string
    name: string
    institutionType?: $Enums.InstitutionType
    address: string
    city: string
    state: string
    country: string
    phone: string
    email: string
    website?: string | null
    plan?: $Enums.InstitutionPlan
    subscriptionStatus?: $Enums.SubscriptionStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InstitutionUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    institutionType?: EnumInstitutionTypeFieldUpdateOperationsInput | $Enums.InstitutionType
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: EnumInstitutionPlanFieldUpdateOperationsInput | $Enums.InstitutionPlan
    subscriptionStatus?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InstitutionUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    institutionType?: EnumInstitutionTypeFieldUpdateOperationsInput | $Enums.InstitutionType
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: EnumInstitutionPlanFieldUpdateOperationsInput | $Enums.InstitutionPlan
    subscriptionStatus?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsersOnInstitutionCreateInput = {
    id?: string
    user: UserCreateNestedOneWithoutInstitutionsInput
    institution: InstitutionCreateNestedOneWithoutUsersInput
  }

  export type UsersOnInstitutionUncheckedCreateInput = {
    id?: string
    userId: string
    institutionId: string
  }

  export type UsersOnInstitutionUpdateInput = {
    user?: UserUpdateOneRequiredWithoutInstitutionsNestedInput
    institution?: InstitutionUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UsersOnInstitutionUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    institutionId?: StringFieldUpdateOperationsInput | string
  }

  export type UsersOnInstitutionCreateManyInput = {
    id?: string
    userId: string
    institutionId: string
  }

  export type UsersOnInstitutionUpdateManyMutationInput = {

  }

  export type UsersOnInstitutionUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    institutionId?: StringFieldUpdateOperationsInput | string
  }

  export type UserCreateInput = {
    id?: string
    firstName: string
    middleName?: string | null
    lastName: string
    dateOfBirth: Date | string
    role: $Enums.Role
    email: string
    password: string
    avatar?: string | null
    phone?: string | null
    isActive?: boolean
    lastlogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    student?: StudentCreateNestedManyWithoutUserInput
    teacher?: TeacherCreateNestedManyWithoutUserInput
    parent?: UserToParentCreateNestedManyWithoutUserInput
    institutions?: UsersOnInstitutionCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutFromUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    firstName: string
    middleName?: string | null
    lastName: string
    dateOfBirth: Date | string
    role: $Enums.Role
    email: string
    password: string
    avatar?: string | null
    phone?: string | null
    isActive?: boolean
    lastlogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    student?: StudentUncheckedCreateNestedManyWithoutUserInput
    teacher?: TeacherUncheckedCreateNestedManyWithoutUserInput
    parent?: UserToParentUncheckedCreateNestedManyWithoutUserInput
    institutions?: UsersOnInstitutionUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutFromUserInput
  }

  export type UserUpdateInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastlogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateManyWithoutUserNestedInput
    teacher?: TeacherUpdateManyWithoutUserNestedInput
    parent?: UserToParentUpdateManyWithoutUserNestedInput
    institutions?: UsersOnInstitutionUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutFromUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastlogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUncheckedUpdateManyWithoutUserNestedInput
    teacher?: TeacherUncheckedUpdateManyWithoutUserNestedInput
    parent?: UserToParentUncheckedUpdateManyWithoutUserNestedInput
    institutions?: UsersOnInstitutionUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutFromUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    firstName: string
    middleName?: string | null
    lastName: string
    dateOfBirth: Date | string
    role: $Enums.Role
    email: string
    password: string
    avatar?: string | null
    phone?: string | null
    isActive?: boolean
    lastlogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastlogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastlogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentCreateInput = {
    id?: string
    firstName: string
    middleName?: string | null
    lastName: string
    admissionNumber?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    bloodGroup?: string | null
    address?: string | null
    gradeApplying?: string | null
    academicYear?: string | null
    phone?: string | null
    email?: string | null
    guardians?: InputJsonValue | null
    fingerprintEnrolled?: boolean
    fingerprintData?: InputJsonValue | null
    faceData?: InputJsonValue | null
    documents?: InputJsonValue | null
    photo?: string | null
    emergencyContacts?: InputJsonValue | null
    medicalConditions?: string | null
    allergies?: string | null
    medications?: string | null
    previousSchool?: string | null
    previousGrade?: string | null
    transferReason?: string | null
    enrollmentStatus?: string
    enrollmentDate?: Date | string | null
    nationality?: string | null
    religion?: string | null
    languagesSpoken?: StudentCreatelanguagesSpokenInput | string[]
    specialNeeds?: string | null
    transportRequired?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    parentIds?: StudentCreateparentIdsInput | string[]
    StudentDocument?: StudentDocumentCreateNestedManyWithoutStudentInput
    user?: UserCreateNestedOneWithoutStudentInput
    institution: InstitutionCreateNestedOneWithoutStudentsInput
    class?: ClassCreateNestedOneWithoutStudentsInput
    parents?: ParentCreateNestedManyWithoutStudentInput
    enrollments?: EnrollmentCreateNestedManyWithoutStudentInput
    attendances?: AttendanceCreateNestedManyWithoutStudentInput
    grades?: GradeCreateNestedManyWithoutStudentInput
    invoices?: InvoiceCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateInput = {
    id?: string
    userId?: string | null
    institutionId: string
    firstName: string
    middleName?: string | null
    lastName: string
    admissionNumber?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    bloodGroup?: string | null
    address?: string | null
    gradeApplying?: string | null
    academicYear?: string | null
    classId?: string | null
    phone?: string | null
    email?: string | null
    guardians?: InputJsonValue | null
    fingerprintEnrolled?: boolean
    fingerprintData?: InputJsonValue | null
    faceData?: InputJsonValue | null
    documents?: InputJsonValue | null
    photo?: string | null
    emergencyContacts?: InputJsonValue | null
    medicalConditions?: string | null
    allergies?: string | null
    medications?: string | null
    previousSchool?: string | null
    previousGrade?: string | null
    transferReason?: string | null
    enrollmentStatus?: string
    enrollmentDate?: Date | string | null
    nationality?: string | null
    religion?: string | null
    languagesSpoken?: StudentCreatelanguagesSpokenInput | string[]
    specialNeeds?: string | null
    transportRequired?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    parentIds?: StudentCreateparentIdsInput | string[]
    StudentDocument?: StudentDocumentUncheckedCreateNestedManyWithoutStudentInput
    parents?: ParentUncheckedCreateNestedManyWithoutStudentInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutStudentInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutStudentInput
    grades?: GradeUncheckedCreateNestedManyWithoutStudentInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentUpdateInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    admissionNumber?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gradeApplying?: NullableStringFieldUpdateOperationsInput | string | null
    academicYear?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    guardians?: InputJsonValue | InputJsonValue | null
    fingerprintEnrolled?: BoolFieldUpdateOperationsInput | boolean
    fingerprintData?: InputJsonValue | InputJsonValue | null
    faceData?: InputJsonValue | InputJsonValue | null
    documents?: InputJsonValue | InputJsonValue | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContacts?: InputJsonValue | InputJsonValue | null
    medicalConditions?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    medications?: NullableStringFieldUpdateOperationsInput | string | null
    previousSchool?: NullableStringFieldUpdateOperationsInput | string | null
    previousGrade?: NullableStringFieldUpdateOperationsInput | string | null
    transferReason?: NullableStringFieldUpdateOperationsInput | string | null
    enrollmentStatus?: StringFieldUpdateOperationsInput | string
    enrollmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    languagesSpoken?: StudentUpdatelanguagesSpokenInput | string[]
    specialNeeds?: NullableStringFieldUpdateOperationsInput | string | null
    transportRequired?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentIds?: StudentUpdateparentIdsInput | string[]
    StudentDocument?: StudentDocumentUpdateManyWithoutStudentNestedInput
    user?: UserUpdateOneWithoutStudentNestedInput
    institution?: InstitutionUpdateOneRequiredWithoutStudentsNestedInput
    class?: ClassUpdateOneWithoutStudentsNestedInput
    parents?: ParentUpdateManyWithoutStudentNestedInput
    enrollments?: EnrollmentUpdateManyWithoutStudentNestedInput
    attendances?: AttendanceUpdateManyWithoutStudentNestedInput
    grades?: GradeUpdateManyWithoutStudentNestedInput
    invoices?: InvoiceUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateInput = {
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    institutionId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    admissionNumber?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gradeApplying?: NullableStringFieldUpdateOperationsInput | string | null
    academicYear?: NullableStringFieldUpdateOperationsInput | string | null
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    guardians?: InputJsonValue | InputJsonValue | null
    fingerprintEnrolled?: BoolFieldUpdateOperationsInput | boolean
    fingerprintData?: InputJsonValue | InputJsonValue | null
    faceData?: InputJsonValue | InputJsonValue | null
    documents?: InputJsonValue | InputJsonValue | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContacts?: InputJsonValue | InputJsonValue | null
    medicalConditions?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    medications?: NullableStringFieldUpdateOperationsInput | string | null
    previousSchool?: NullableStringFieldUpdateOperationsInput | string | null
    previousGrade?: NullableStringFieldUpdateOperationsInput | string | null
    transferReason?: NullableStringFieldUpdateOperationsInput | string | null
    enrollmentStatus?: StringFieldUpdateOperationsInput | string
    enrollmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    languagesSpoken?: StudentUpdatelanguagesSpokenInput | string[]
    specialNeeds?: NullableStringFieldUpdateOperationsInput | string | null
    transportRequired?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentIds?: StudentUpdateparentIdsInput | string[]
    StudentDocument?: StudentDocumentUncheckedUpdateManyWithoutStudentNestedInput
    parents?: ParentUncheckedUpdateManyWithoutStudentNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutStudentNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutStudentNestedInput
    grades?: GradeUncheckedUpdateManyWithoutStudentNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type StudentCreateManyInput = {
    id?: string
    userId?: string | null
    institutionId: string
    firstName: string
    middleName?: string | null
    lastName: string
    admissionNumber?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    bloodGroup?: string | null
    address?: string | null
    gradeApplying?: string | null
    academicYear?: string | null
    classId?: string | null
    phone?: string | null
    email?: string | null
    guardians?: InputJsonValue | null
    fingerprintEnrolled?: boolean
    fingerprintData?: InputJsonValue | null
    faceData?: InputJsonValue | null
    documents?: InputJsonValue | null
    photo?: string | null
    emergencyContacts?: InputJsonValue | null
    medicalConditions?: string | null
    allergies?: string | null
    medications?: string | null
    previousSchool?: string | null
    previousGrade?: string | null
    transferReason?: string | null
    enrollmentStatus?: string
    enrollmentDate?: Date | string | null
    nationality?: string | null
    religion?: string | null
    languagesSpoken?: StudentCreatelanguagesSpokenInput | string[]
    specialNeeds?: string | null
    transportRequired?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    parentIds?: StudentCreateparentIdsInput | string[]
  }

  export type StudentUpdateManyMutationInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    admissionNumber?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gradeApplying?: NullableStringFieldUpdateOperationsInput | string | null
    academicYear?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    guardians?: InputJsonValue | InputJsonValue | null
    fingerprintEnrolled?: BoolFieldUpdateOperationsInput | boolean
    fingerprintData?: InputJsonValue | InputJsonValue | null
    faceData?: InputJsonValue | InputJsonValue | null
    documents?: InputJsonValue | InputJsonValue | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContacts?: InputJsonValue | InputJsonValue | null
    medicalConditions?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    medications?: NullableStringFieldUpdateOperationsInput | string | null
    previousSchool?: NullableStringFieldUpdateOperationsInput | string | null
    previousGrade?: NullableStringFieldUpdateOperationsInput | string | null
    transferReason?: NullableStringFieldUpdateOperationsInput | string | null
    enrollmentStatus?: StringFieldUpdateOperationsInput | string
    enrollmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    languagesSpoken?: StudentUpdatelanguagesSpokenInput | string[]
    specialNeeds?: NullableStringFieldUpdateOperationsInput | string | null
    transportRequired?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentIds?: StudentUpdateparentIdsInput | string[]
  }

  export type StudentUncheckedUpdateManyInput = {
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    institutionId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    admissionNumber?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gradeApplying?: NullableStringFieldUpdateOperationsInput | string | null
    academicYear?: NullableStringFieldUpdateOperationsInput | string | null
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    guardians?: InputJsonValue | InputJsonValue | null
    fingerprintEnrolled?: BoolFieldUpdateOperationsInput | boolean
    fingerprintData?: InputJsonValue | InputJsonValue | null
    faceData?: InputJsonValue | InputJsonValue | null
    documents?: InputJsonValue | InputJsonValue | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContacts?: InputJsonValue | InputJsonValue | null
    medicalConditions?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    medications?: NullableStringFieldUpdateOperationsInput | string | null
    previousSchool?: NullableStringFieldUpdateOperationsInput | string | null
    previousGrade?: NullableStringFieldUpdateOperationsInput | string | null
    transferReason?: NullableStringFieldUpdateOperationsInput | string | null
    enrollmentStatus?: StringFieldUpdateOperationsInput | string
    enrollmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    languagesSpoken?: StudentUpdatelanguagesSpokenInput | string[]
    specialNeeds?: NullableStringFieldUpdateOperationsInput | string | null
    transportRequired?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentIds?: StudentUpdateparentIdsInput | string[]
  }

  export type UserToParentCreateInput = {
    id?: string
    user: UserCreateNestedOneWithoutParentInput
    parent: ParentCreateNestedOneWithoutUserInput
  }

  export type UserToParentUncheckedCreateInput = {
    id?: string
    userId: string
    parentId: string
  }

  export type UserToParentUpdateInput = {
    user?: UserUpdateOneRequiredWithoutParentNestedInput
    parent?: ParentUpdateOneRequiredWithoutUserNestedInput
  }

  export type UserToParentUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    parentId?: StringFieldUpdateOperationsInput | string
  }

  export type UserToParentCreateManyInput = {
    id?: string
    userId: string
    parentId: string
  }

  export type UserToParentUpdateManyMutationInput = {

  }

  export type UserToParentUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    parentId?: StringFieldUpdateOperationsInput | string
  }

  export type ParentCreateInput = {
    id?: string
    institutionId: string
    firstName: string
    middleName?: string | null
    lastName: string
    email: string
    phone: string
    occupation?: string | null
    relationship?: string | null
    address?: string | null
    isPrimaryContact?: boolean
    isEmergencyContact?: boolean
    preferredContactTime?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    student?: StudentCreateNestedOneWithoutParentsInput
    user?: UserToParentCreateNestedManyWithoutParentInput
  }

  export type ParentUncheckedCreateInput = {
    id?: string
    studentId?: string | null
    institutionId: string
    firstName: string
    middleName?: string | null
    lastName: string
    email: string
    phone: string
    occupation?: string | null
    relationship?: string | null
    address?: string | null
    isPrimaryContact?: boolean
    isEmergencyContact?: boolean
    preferredContactTime?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserToParentUncheckedCreateNestedManyWithoutParentInput
  }

  export type ParentUpdateInput = {
    institutionId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    relationship?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isPrimaryContact?: BoolFieldUpdateOperationsInput | boolean
    isEmergencyContact?: BoolFieldUpdateOperationsInput | boolean
    preferredContactTime?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneWithoutParentsNestedInput
    user?: UserToParentUpdateManyWithoutParentNestedInput
  }

  export type ParentUncheckedUpdateInput = {
    studentId?: NullableStringFieldUpdateOperationsInput | string | null
    institutionId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    relationship?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isPrimaryContact?: BoolFieldUpdateOperationsInput | boolean
    isEmergencyContact?: BoolFieldUpdateOperationsInput | boolean
    preferredContactTime?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserToParentUncheckedUpdateManyWithoutParentNestedInput
  }

  export type ParentCreateManyInput = {
    id?: string
    studentId?: string | null
    institutionId: string
    firstName: string
    middleName?: string | null
    lastName: string
    email: string
    phone: string
    occupation?: string | null
    relationship?: string | null
    address?: string | null
    isPrimaryContact?: boolean
    isEmergencyContact?: boolean
    preferredContactTime?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ParentUpdateManyMutationInput = {
    institutionId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    relationship?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isPrimaryContact?: BoolFieldUpdateOperationsInput | boolean
    isEmergencyContact?: BoolFieldUpdateOperationsInput | boolean
    preferredContactTime?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ParentUncheckedUpdateManyInput = {
    studentId?: NullableStringFieldUpdateOperationsInput | string | null
    institutionId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    relationship?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isPrimaryContact?: BoolFieldUpdateOperationsInput | boolean
    isEmergencyContact?: BoolFieldUpdateOperationsInput | boolean
    preferredContactTime?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentDocumentCreateInput = {
    id?: string
    documentType: string
    documentName: string
    documentUrl: string
    fileSize?: number | null
    mimeType?: string | null
    uploadedAt?: Date | string
    uploadedBy?: string | null
    verified?: boolean
    verifiedBy?: string | null
    verifiedAt?: Date | string | null
    student?: StudentCreateNestedOneWithoutStudentDocumentInput
  }

  export type StudentDocumentUncheckedCreateInput = {
    id?: string
    studentId?: string | null
    documentType: string
    documentName: string
    documentUrl: string
    fileSize?: number | null
    mimeType?: string | null
    uploadedAt?: Date | string
    uploadedBy?: string | null
    verified?: boolean
    verifiedBy?: string | null
    verifiedAt?: Date | string | null
  }

  export type StudentDocumentUpdateInput = {
    documentType?: StringFieldUpdateOperationsInput | string
    documentName?: StringFieldUpdateOperationsInput | string
    documentUrl?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    student?: StudentUpdateOneWithoutStudentDocumentNestedInput
  }

  export type StudentDocumentUncheckedUpdateInput = {
    studentId?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: StringFieldUpdateOperationsInput | string
    documentName?: StringFieldUpdateOperationsInput | string
    documentUrl?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type StudentDocumentCreateManyInput = {
    id?: string
    studentId?: string | null
    documentType: string
    documentName: string
    documentUrl: string
    fileSize?: number | null
    mimeType?: string | null
    uploadedAt?: Date | string
    uploadedBy?: string | null
    verified?: boolean
    verifiedBy?: string | null
    verifiedAt?: Date | string | null
  }

  export type StudentDocumentUpdateManyMutationInput = {
    documentType?: StringFieldUpdateOperationsInput | string
    documentName?: StringFieldUpdateOperationsInput | string
    documentUrl?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type StudentDocumentUncheckedUpdateManyInput = {
    studentId?: NullableStringFieldUpdateOperationsInput | string | null
    documentType?: StringFieldUpdateOperationsInput | string
    documentName?: StringFieldUpdateOperationsInput | string
    documentUrl?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TeacherOnInstitutionCreateInput = {
    id?: string
    teacher: TeacherCreateNestedOneWithoutInstitutionInput
    institution: InstitutionCreateNestedOneWithoutTeachersInput
  }

  export type TeacherOnInstitutionUncheckedCreateInput = {
    id?: string
    teacherId: string
    institutionId: string
  }

  export type TeacherOnInstitutionUpdateInput = {
    teacher?: TeacherUpdateOneRequiredWithoutInstitutionNestedInput
    institution?: InstitutionUpdateOneRequiredWithoutTeachersNestedInput
  }

  export type TeacherOnInstitutionUncheckedUpdateInput = {
    teacherId?: StringFieldUpdateOperationsInput | string
    institutionId?: StringFieldUpdateOperationsInput | string
  }

  export type TeacherOnInstitutionCreateManyInput = {
    id?: string
    teacherId: string
    institutionId: string
  }

  export type TeacherOnInstitutionUpdateManyMutationInput = {

  }

  export type TeacherOnInstitutionUncheckedUpdateManyInput = {
    teacherId?: StringFieldUpdateOperationsInput | string
    institutionId?: StringFieldUpdateOperationsInput | string
  }

  export type TeacherCreateInput = {
    id?: string
    firstName: string
    middleName?: string | null
    lastName: string
    email?: string | null
    phone: string
    avatar?: string | null
    employeeNumber?: string | null
    subjects?: TeacherCreatesubjectsInput | string[]
    qualification?: string | null
    experience?: number | null
    salary?: number | null
    joinDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutTeacherInput
    institution?: TeacherOnInstitutionCreateNestedManyWithoutTeacherInput
    classes?: TeacherOnClassCreateNestedManyWithoutTeacherInput
  }

  export type TeacherUncheckedCreateInput = {
    id?: string
    userId?: string | null
    firstName: string
    middleName?: string | null
    lastName: string
    email?: string | null
    phone: string
    avatar?: string | null
    employeeNumber?: string | null
    subjects?: TeacherCreatesubjectsInput | string[]
    qualification?: string | null
    experience?: number | null
    salary?: number | null
    joinDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    institution?: TeacherOnInstitutionUncheckedCreateNestedManyWithoutTeacherInput
    classes?: TeacherOnClassUncheckedCreateNestedManyWithoutTeacherInput
  }

  export type TeacherUpdateInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    employeeNumber?: NullableStringFieldUpdateOperationsInput | string | null
    subjects?: TeacherUpdatesubjectsInput | string[]
    qualification?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    joinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutTeacherNestedInput
    institution?: TeacherOnInstitutionUpdateManyWithoutTeacherNestedInput
    classes?: TeacherOnClassUpdateManyWithoutTeacherNestedInput
  }

  export type TeacherUncheckedUpdateInput = {
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    employeeNumber?: NullableStringFieldUpdateOperationsInput | string | null
    subjects?: TeacherUpdatesubjectsInput | string[]
    qualification?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    joinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    institution?: TeacherOnInstitutionUncheckedUpdateManyWithoutTeacherNestedInput
    classes?: TeacherOnClassUncheckedUpdateManyWithoutTeacherNestedInput
  }

  export type TeacherCreateManyInput = {
    id?: string
    userId?: string | null
    firstName: string
    middleName?: string | null
    lastName: string
    email?: string | null
    phone: string
    avatar?: string | null
    employeeNumber?: string | null
    subjects?: TeacherCreatesubjectsInput | string[]
    qualification?: string | null
    experience?: number | null
    salary?: number | null
    joinDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeacherUpdateManyMutationInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    employeeNumber?: NullableStringFieldUpdateOperationsInput | string | null
    subjects?: TeacherUpdatesubjectsInput | string[]
    qualification?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    joinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeacherUncheckedUpdateManyInput = {
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    employeeNumber?: NullableStringFieldUpdateOperationsInput | string | null
    subjects?: TeacherUpdatesubjectsInput | string[]
    qualification?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    joinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeacherOnClassCreateInput = {
    id?: string
    teacher: TeacherCreateNestedOneWithoutClassesInput
    class: ClassCreateNestedOneWithoutTeachersInput
  }

  export type TeacherOnClassUncheckedCreateInput = {
    id?: string
    teacherId: string
    classId: string
  }

  export type TeacherOnClassUpdateInput = {
    teacher?: TeacherUpdateOneRequiredWithoutClassesNestedInput
    class?: ClassUpdateOneRequiredWithoutTeachersNestedInput
  }

  export type TeacherOnClassUncheckedUpdateInput = {
    teacherId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
  }

  export type TeacherOnClassCreateManyInput = {
    id?: string
    teacherId: string
    classId: string
  }

  export type TeacherOnClassUpdateManyMutationInput = {

  }

  export type TeacherOnClassUncheckedUpdateManyInput = {
    teacherId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
  }

  export type ClassCreateInput = {
    id?: string
    name: string
    section?: string | null
    academicYear?: string | null
    capacity?: number | null
    roomNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    teacherIds?: ClassCreateteacherIdsInput | string[]
    institution: InstitutionCreateNestedOneWithoutClassesInput
    students?: StudentCreateNestedManyWithoutClassInput
    teachers?: TeacherOnClassCreateNestedManyWithoutClassInput
    enrollments?: EnrollmentCreateNestedManyWithoutClassInput
    attendances?: AttendanceCreateNestedManyWithoutClassInput
    timetables?: TimetableCreateNestedManyWithoutClassInput
  }

  export type ClassUncheckedCreateInput = {
    id?: string
    institutionId: string
    name: string
    section?: string | null
    academicYear?: string | null
    capacity?: number | null
    roomNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    teacherIds?: ClassCreateteacherIdsInput | string[]
    students?: StudentUncheckedCreateNestedManyWithoutClassInput
    teachers?: TeacherOnClassUncheckedCreateNestedManyWithoutClassInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutClassInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutClassInput
    timetables?: TimetableUncheckedCreateNestedManyWithoutClassInput
  }

  export type ClassUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    section?: NullableStringFieldUpdateOperationsInput | string | null
    academicYear?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    roomNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teacherIds?: ClassUpdateteacherIdsInput | string[]
    institution?: InstitutionUpdateOneRequiredWithoutClassesNestedInput
    students?: StudentUpdateManyWithoutClassNestedInput
    teachers?: TeacherOnClassUpdateManyWithoutClassNestedInput
    enrollments?: EnrollmentUpdateManyWithoutClassNestedInput
    attendances?: AttendanceUpdateManyWithoutClassNestedInput
    timetables?: TimetableUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateInput = {
    institutionId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    section?: NullableStringFieldUpdateOperationsInput | string | null
    academicYear?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    roomNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teacherIds?: ClassUpdateteacherIdsInput | string[]
    students?: StudentUncheckedUpdateManyWithoutClassNestedInput
    teachers?: TeacherOnClassUncheckedUpdateManyWithoutClassNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutClassNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutClassNestedInput
    timetables?: TimetableUncheckedUpdateManyWithoutClassNestedInput
  }

  export type ClassCreateManyInput = {
    id?: string
    institutionId: string
    name: string
    section?: string | null
    academicYear?: string | null
    capacity?: number | null
    roomNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    teacherIds?: ClassCreateteacherIdsInput | string[]
  }

  export type ClassUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    section?: NullableStringFieldUpdateOperationsInput | string | null
    academicYear?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    roomNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teacherIds?: ClassUpdateteacherIdsInput | string[]
  }

  export type ClassUncheckedUpdateManyInput = {
    institutionId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    section?: NullableStringFieldUpdateOperationsInput | string | null
    academicYear?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    roomNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teacherIds?: ClassUpdateteacherIdsInput | string[]
  }

  export type EnrollmentCreateInput = {
    id?: string
    academicYear: string
    enrollDate?: Date | string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutEnrollmentsInput
    class: ClassCreateNestedOneWithoutEnrollmentsInput
  }

  export type EnrollmentUncheckedCreateInput = {
    id?: string
    studentId: string
    classId: string
    academicYear: string
    enrollDate?: Date | string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EnrollmentUpdateInput = {
    academicYear?: StringFieldUpdateOperationsInput | string
    enrollDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutEnrollmentsNestedInput
    class?: ClassUpdateOneRequiredWithoutEnrollmentsNestedInput
  }

  export type EnrollmentUncheckedUpdateInput = {
    studentId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    enrollDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EnrollmentCreateManyInput = {
    id?: string
    studentId: string
    classId: string
    academicYear: string
    enrollDate?: Date | string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EnrollmentUpdateManyMutationInput = {
    academicYear?: StringFieldUpdateOperationsInput | string
    enrollDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EnrollmentUncheckedUpdateManyInput = {
    studentId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    enrollDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceCreateInput = {
    id?: string
    date: Date | string
    status: string
    remarks?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    class: ClassCreateNestedOneWithoutAttendancesInput
    student: StudentCreateNestedOneWithoutAttendancesInput
  }

  export type AttendanceUncheckedCreateInput = {
    id?: string
    studentId: string
    classId: string
    date: Date | string
    status: string
    remarks?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttendanceUpdateInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    class?: ClassUpdateOneRequiredWithoutAttendancesNestedInput
    student?: StudentUpdateOneRequiredWithoutAttendancesNestedInput
  }

  export type AttendanceUncheckedUpdateInput = {
    studentId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceCreateManyInput = {
    id?: string
    studentId: string
    classId: string
    date: Date | string
    status: string
    remarks?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttendanceUpdateManyMutationInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceUncheckedUpdateManyInput = {
    studentId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GradeCreateInput = {
    id?: string
    subject: string
    examType?: string | null
    score: number
    maxScore?: number
    grade?: string | null
    term: string
    academicYear: string
    remarks?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutGradesInput
  }

  export type GradeUncheckedCreateInput = {
    id?: string
    studentId: string
    subject: string
    examType?: string | null
    score: number
    maxScore?: number
    grade?: string | null
    term: string
    academicYear: string
    remarks?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GradeUpdateInput = {
    subject?: StringFieldUpdateOperationsInput | string
    examType?: NullableStringFieldUpdateOperationsInput | string | null
    score?: FloatFieldUpdateOperationsInput | number
    maxScore?: FloatFieldUpdateOperationsInput | number
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    term?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutGradesNestedInput
  }

  export type GradeUncheckedUpdateInput = {
    studentId?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    examType?: NullableStringFieldUpdateOperationsInput | string | null
    score?: FloatFieldUpdateOperationsInput | number
    maxScore?: FloatFieldUpdateOperationsInput | number
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    term?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GradeCreateManyInput = {
    id?: string
    studentId: string
    subject: string
    examType?: string | null
    score: number
    maxScore?: number
    grade?: string | null
    term: string
    academicYear: string
    remarks?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GradeUpdateManyMutationInput = {
    subject?: StringFieldUpdateOperationsInput | string
    examType?: NullableStringFieldUpdateOperationsInput | string | null
    score?: FloatFieldUpdateOperationsInput | number
    maxScore?: FloatFieldUpdateOperationsInput | number
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    term?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GradeUncheckedUpdateManyInput = {
    studentId?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    examType?: NullableStringFieldUpdateOperationsInput | string | null
    score?: FloatFieldUpdateOperationsInput | number
    maxScore?: FloatFieldUpdateOperationsInput | number
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    term?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TimetableCreateInput = {
    id?: string
    dayOfWeek: number
    startTime: string
    endTime: string
    subject: string
    teacherId?: string | null
    room?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    class: ClassCreateNestedOneWithoutTimetablesInput
  }

  export type TimetableUncheckedCreateInput = {
    id?: string
    classId: string
    dayOfWeek: number
    startTime: string
    endTime: string
    subject: string
    teacherId?: string | null
    room?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TimetableUpdateInput = {
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    class?: ClassUpdateOneRequiredWithoutTimetablesNestedInput
  }

  export type TimetableUncheckedUpdateInput = {
    classId?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TimetableCreateManyInput = {
    id?: string
    classId: string
    dayOfWeek: number
    startTime: string
    endTime: string
    subject: string
    teacherId?: string | null
    room?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TimetableUpdateManyMutationInput = {
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TimetableUncheckedUpdateManyInput = {
    classId?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceCreateInput = {
    id?: string
    invoiceNumber: string
    description?: string | null
    amount: number
    amountPaid?: number
    status: string
    dueDate?: Date | string | null
    paidDate?: Date | string | null
    paymentMethod?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    institution?: InstitutionCreateNestedOneWithoutInvoicesInput
    student?: StudentCreateNestedOneWithoutInvoicesInput
  }

  export type InvoiceUncheckedCreateInput = {
    id?: string
    institutionId: string
    studentId?: string | null
    invoiceNumber: string
    description?: string | null
    amount: number
    amountPaid?: number
    status: string
    dueDate?: Date | string | null
    paidDate?: Date | string | null
    paymentMethod?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceUpdateInput = {
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    amountPaid?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    institution?: InstitutionUpdateOneWithoutInvoicesNestedInput
    student?: StudentUpdateOneWithoutInvoicesNestedInput
  }

  export type InvoiceUncheckedUpdateInput = {
    institutionId?: StringFieldUpdateOperationsInput | string
    studentId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    amountPaid?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceCreateManyInput = {
    id?: string
    institutionId: string
    studentId?: string | null
    invoiceNumber: string
    description?: string | null
    amount: number
    amountPaid?: number
    status: string
    dueDate?: Date | string | null
    paidDate?: Date | string | null
    paymentMethod?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceUpdateManyMutationInput = {
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    amountPaid?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUncheckedUpdateManyInput = {
    institutionId?: StringFieldUpdateOperationsInput | string
    studentId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    amountPaid?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageCreateInput = {
    id?: string
    toUserId: string
    subject?: string | null
    body: string
    isRead?: boolean
    readAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    fromUser: UserCreateNestedOneWithoutSentMessagesInput
    institution: InstitutionCreateNestedOneWithoutMessagesInput
  }

  export type MessageUncheckedCreateInput = {
    id?: string
    fromUserId: string
    toUserId: string
    institutionId: string
    subject?: string | null
    body: string
    isRead?: boolean
    readAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessageUpdateInput = {
    toUserId?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    body?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fromUser?: UserUpdateOneRequiredWithoutSentMessagesNestedInput
    institution?: InstitutionUpdateOneRequiredWithoutMessagesNestedInput
  }

  export type MessageUncheckedUpdateInput = {
    fromUserId?: StringFieldUpdateOperationsInput | string
    toUserId?: StringFieldUpdateOperationsInput | string
    institutionId?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    body?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageCreateManyInput = {
    id?: string
    fromUserId: string
    toUserId: string
    institutionId: string
    subject?: string | null
    body: string
    isRead?: boolean
    readAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessageUpdateManyMutationInput = {
    toUserId?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    body?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateManyInput = {
    fromUserId?: StringFieldUpdateOperationsInput | string
    toUserId?: StringFieldUpdateOperationsInput | string
    institutionId?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    body?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type EnumInstitutionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.InstitutionType | EnumInstitutionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InstitutionType[] | ListEnumInstitutionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InstitutionType[] | ListEnumInstitutionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInstitutionTypeFilter<$PrismaModel> | $Enums.InstitutionType
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
    isSet?: boolean
  }

  export type EnumInstitutionPlanFilter<$PrismaModel = never> = {
    equals?: $Enums.InstitutionPlan | EnumInstitutionPlanFieldRefInput<$PrismaModel>
    in?: $Enums.InstitutionPlan[] | ListEnumInstitutionPlanFieldRefInput<$PrismaModel>
    notIn?: $Enums.InstitutionPlan[] | ListEnumInstitutionPlanFieldRefInput<$PrismaModel>
    not?: NestedEnumInstitutionPlanFilter<$PrismaModel> | $Enums.InstitutionPlan
  }

  export type EnumSubscriptionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionStatusFilter<$PrismaModel> | $Enums.SubscriptionStatus
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type UsersOnInstitutionListRelationFilter = {
    every?: UsersOnInstitutionWhereInput
    some?: UsersOnInstitutionWhereInput
    none?: UsersOnInstitutionWhereInput
  }

  export type ClassListRelationFilter = {
    every?: ClassWhereInput
    some?: ClassWhereInput
    none?: ClassWhereInput
  }

  export type StudentListRelationFilter = {
    every?: StudentWhereInput
    some?: StudentWhereInput
    none?: StudentWhereInput
  }

  export type TeacherOnInstitutionListRelationFilter = {
    every?: TeacherOnInstitutionWhereInput
    some?: TeacherOnInstitutionWhereInput
    none?: TeacherOnInstitutionWhereInput
  }

  export type InvoiceListRelationFilter = {
    every?: InvoiceWhereInput
    some?: InvoiceWhereInput
    none?: InvoiceWhereInput
  }

  export type MessageListRelationFilter = {
    every?: MessageWhereInput
    some?: MessageWhereInput
    none?: MessageWhereInput
  }

  export type UsersOnInstitutionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClassOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StudentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TeacherOnInstitutionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InvoiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InstitutionCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    institutionType?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    country?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    website?: SortOrder
    plan?: SortOrder
    subscriptionStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InstitutionMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    institutionType?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    country?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    website?: SortOrder
    plan?: SortOrder
    subscriptionStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InstitutionMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    institutionType?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    country?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    website?: SortOrder
    plan?: SortOrder
    subscriptionStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumInstitutionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InstitutionType | EnumInstitutionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InstitutionType[] | ListEnumInstitutionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InstitutionType[] | ListEnumInstitutionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInstitutionTypeWithAggregatesFilter<$PrismaModel> | $Enums.InstitutionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInstitutionTypeFilter<$PrismaModel>
    _max?: NestedEnumInstitutionTypeFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type EnumInstitutionPlanWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InstitutionPlan | EnumInstitutionPlanFieldRefInput<$PrismaModel>
    in?: $Enums.InstitutionPlan[] | ListEnumInstitutionPlanFieldRefInput<$PrismaModel>
    notIn?: $Enums.InstitutionPlan[] | ListEnumInstitutionPlanFieldRefInput<$PrismaModel>
    not?: NestedEnumInstitutionPlanWithAggregatesFilter<$PrismaModel> | $Enums.InstitutionPlan
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInstitutionPlanFilter<$PrismaModel>
    _max?: NestedEnumInstitutionPlanFilter<$PrismaModel>
  }

  export type EnumSubscriptionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionStatusWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionStatusFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionStatusFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type InstitutionScalarRelationFilter = {
    is?: InstitutionWhereInput
    isNot?: InstitutionWhereInput
  }

  export type UsersOnInstitutionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    institutionId?: SortOrder
  }

  export type UsersOnInstitutionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    institutionId?: SortOrder
  }

  export type UsersOnInstitutionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    institutionId?: SortOrder
  }

  export type EnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
    isSet?: boolean
  }

  export type TeacherListRelationFilter = {
    every?: TeacherWhereInput
    some?: TeacherWhereInput
    none?: TeacherWhereInput
  }

  export type UserToParentListRelationFilter = {
    every?: UserToParentWhereInput
    some?: UserToParentWhereInput
    none?: UserToParentWhereInput
  }

  export type TeacherOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserToParentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    middleName?: SortOrder
    lastName?: SortOrder
    dateOfBirth?: SortOrder
    role?: SortOrder
    email?: SortOrder
    password?: SortOrder
    avatar?: SortOrder
    phone?: SortOrder
    isActive?: SortOrder
    lastlogin?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    middleName?: SortOrder
    lastName?: SortOrder
    dateOfBirth?: SortOrder
    role?: SortOrder
    email?: SortOrder
    password?: SortOrder
    avatar?: SortOrder
    phone?: SortOrder
    isActive?: SortOrder
    lastlogin?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    middleName?: SortOrder
    lastName?: SortOrder
    dateOfBirth?: SortOrder
    role?: SortOrder
    email?: SortOrder
    password?: SortOrder
    avatar?: SortOrder
    phone?: SortOrder
    isActive?: SortOrder
    lastlogin?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
    isSet?: boolean
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    isSet?: boolean
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type StudentDocumentListRelationFilter = {
    every?: StudentDocumentWhereInput
    some?: StudentDocumentWhereInput
    none?: StudentDocumentWhereInput
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type ClassNullableScalarRelationFilter = {
    is?: ClassWhereInput | null
    isNot?: ClassWhereInput | null
  }

  export type ParentListRelationFilter = {
    every?: ParentWhereInput
    some?: ParentWhereInput
    none?: ParentWhereInput
  }

  export type EnrollmentListRelationFilter = {
    every?: EnrollmentWhereInput
    some?: EnrollmentWhereInput
    none?: EnrollmentWhereInput
  }

  export type AttendanceListRelationFilter = {
    every?: AttendanceWhereInput
    some?: AttendanceWhereInput
    none?: AttendanceWhereInput
  }

  export type GradeListRelationFilter = {
    every?: GradeWhereInput
    some?: GradeWhereInput
    none?: GradeWhereInput
  }

  export type StudentDocumentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ParentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EnrollmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AttendanceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GradeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StudentInstitutionIdAdmissionNumberCompoundUniqueInput = {
    institutionId: string
    admissionNumber: string
  }

  export type StudentCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    institutionId?: SortOrder
    firstName?: SortOrder
    middleName?: SortOrder
    lastName?: SortOrder
    admissionNumber?: SortOrder
    dateOfBirth?: SortOrder
    gender?: SortOrder
    bloodGroup?: SortOrder
    address?: SortOrder
    gradeApplying?: SortOrder
    academicYear?: SortOrder
    classId?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    guardians?: SortOrder
    fingerprintEnrolled?: SortOrder
    fingerprintData?: SortOrder
    faceData?: SortOrder
    documents?: SortOrder
    photo?: SortOrder
    emergencyContacts?: SortOrder
    medicalConditions?: SortOrder
    allergies?: SortOrder
    medications?: SortOrder
    previousSchool?: SortOrder
    previousGrade?: SortOrder
    transferReason?: SortOrder
    enrollmentStatus?: SortOrder
    enrollmentDate?: SortOrder
    nationality?: SortOrder
    religion?: SortOrder
    languagesSpoken?: SortOrder
    specialNeeds?: SortOrder
    transportRequired?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    parentIds?: SortOrder
  }

  export type StudentMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    institutionId?: SortOrder
    firstName?: SortOrder
    middleName?: SortOrder
    lastName?: SortOrder
    admissionNumber?: SortOrder
    dateOfBirth?: SortOrder
    gender?: SortOrder
    bloodGroup?: SortOrder
    address?: SortOrder
    gradeApplying?: SortOrder
    academicYear?: SortOrder
    classId?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    fingerprintEnrolled?: SortOrder
    photo?: SortOrder
    medicalConditions?: SortOrder
    allergies?: SortOrder
    medications?: SortOrder
    previousSchool?: SortOrder
    previousGrade?: SortOrder
    transferReason?: SortOrder
    enrollmentStatus?: SortOrder
    enrollmentDate?: SortOrder
    nationality?: SortOrder
    religion?: SortOrder
    specialNeeds?: SortOrder
    transportRequired?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    institutionId?: SortOrder
    firstName?: SortOrder
    middleName?: SortOrder
    lastName?: SortOrder
    admissionNumber?: SortOrder
    dateOfBirth?: SortOrder
    gender?: SortOrder
    bloodGroup?: SortOrder
    address?: SortOrder
    gradeApplying?: SortOrder
    academicYear?: SortOrder
    classId?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    fingerprintEnrolled?: SortOrder
    photo?: SortOrder
    medicalConditions?: SortOrder
    allergies?: SortOrder
    medications?: SortOrder
    previousSchool?: SortOrder
    previousGrade?: SortOrder
    transferReason?: SortOrder
    enrollmentStatus?: SortOrder
    enrollmentDate?: SortOrder
    nationality?: SortOrder
    religion?: SortOrder
    specialNeeds?: SortOrder
    transportRequired?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type ParentScalarRelationFilter = {
    is?: ParentWhereInput
    isNot?: ParentWhereInput
  }

  export type UserToParentCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    parentId?: SortOrder
  }

  export type UserToParentMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    parentId?: SortOrder
  }

  export type UserToParentMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    parentId?: SortOrder
  }

  export type StudentNullableScalarRelationFilter = {
    is?: StudentWhereInput | null
    isNot?: StudentWhereInput | null
  }

  export type ParentCountOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    institutionId?: SortOrder
    firstName?: SortOrder
    middleName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    occupation?: SortOrder
    relationship?: SortOrder
    address?: SortOrder
    isPrimaryContact?: SortOrder
    isEmergencyContact?: SortOrder
    preferredContactTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ParentMaxOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    institutionId?: SortOrder
    firstName?: SortOrder
    middleName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    occupation?: SortOrder
    relationship?: SortOrder
    address?: SortOrder
    isPrimaryContact?: SortOrder
    isEmergencyContact?: SortOrder
    preferredContactTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ParentMinOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    institutionId?: SortOrder
    firstName?: SortOrder
    middleName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    occupation?: SortOrder
    relationship?: SortOrder
    address?: SortOrder
    isPrimaryContact?: SortOrder
    isEmergencyContact?: SortOrder
    preferredContactTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
    isSet?: boolean
  }

  export type StudentDocumentCountOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    documentType?: SortOrder
    documentName?: SortOrder
    documentUrl?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    uploadedAt?: SortOrder
    uploadedBy?: SortOrder
    verified?: SortOrder
    verifiedBy?: SortOrder
    verifiedAt?: SortOrder
  }

  export type StudentDocumentAvgOrderByAggregateInput = {
    fileSize?: SortOrder
  }

  export type StudentDocumentMaxOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    documentType?: SortOrder
    documentName?: SortOrder
    documentUrl?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    uploadedAt?: SortOrder
    uploadedBy?: SortOrder
    verified?: SortOrder
    verifiedBy?: SortOrder
    verifiedAt?: SortOrder
  }

  export type StudentDocumentMinOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    documentType?: SortOrder
    documentName?: SortOrder
    documentUrl?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    uploadedAt?: SortOrder
    uploadedBy?: SortOrder
    verified?: SortOrder
    verifiedBy?: SortOrder
    verifiedAt?: SortOrder
  }

  export type StudentDocumentSumOrderByAggregateInput = {
    fileSize?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type TeacherScalarRelationFilter = {
    is?: TeacherWhereInput
    isNot?: TeacherWhereInput
  }

  export type TeacherOnInstitutionCountOrderByAggregateInput = {
    id?: SortOrder
    teacherId?: SortOrder
    institutionId?: SortOrder
  }

  export type TeacherOnInstitutionMaxOrderByAggregateInput = {
    id?: SortOrder
    teacherId?: SortOrder
    institutionId?: SortOrder
  }

  export type TeacherOnInstitutionMinOrderByAggregateInput = {
    id?: SortOrder
    teacherId?: SortOrder
    institutionId?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
    isSet?: boolean
  }

  export type TeacherOnClassListRelationFilter = {
    every?: TeacherOnClassWhereInput
    some?: TeacherOnClassWhereInput
    none?: TeacherOnClassWhereInput
  }

  export type TeacherOnClassOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TeacherCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    firstName?: SortOrder
    middleName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    avatar?: SortOrder
    employeeNumber?: SortOrder
    subjects?: SortOrder
    qualification?: SortOrder
    experience?: SortOrder
    salary?: SortOrder
    joinDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeacherAvgOrderByAggregateInput = {
    experience?: SortOrder
    salary?: SortOrder
  }

  export type TeacherMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    firstName?: SortOrder
    middleName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    avatar?: SortOrder
    employeeNumber?: SortOrder
    qualification?: SortOrder
    experience?: SortOrder
    salary?: SortOrder
    joinDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeacherMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    firstName?: SortOrder
    middleName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    avatar?: SortOrder
    employeeNumber?: SortOrder
    qualification?: SortOrder
    experience?: SortOrder
    salary?: SortOrder
    joinDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeacherSumOrderByAggregateInput = {
    experience?: SortOrder
    salary?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type ClassScalarRelationFilter = {
    is?: ClassWhereInput
    isNot?: ClassWhereInput
  }

  export type TeacherOnClassCountOrderByAggregateInput = {
    id?: SortOrder
    teacherId?: SortOrder
    classId?: SortOrder
  }

  export type TeacherOnClassMaxOrderByAggregateInput = {
    id?: SortOrder
    teacherId?: SortOrder
    classId?: SortOrder
  }

  export type TeacherOnClassMinOrderByAggregateInput = {
    id?: SortOrder
    teacherId?: SortOrder
    classId?: SortOrder
  }

  export type TimetableListRelationFilter = {
    every?: TimetableWhereInput
    some?: TimetableWhereInput
    none?: TimetableWhereInput
  }

  export type TimetableOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClassCountOrderByAggregateInput = {
    id?: SortOrder
    institutionId?: SortOrder
    name?: SortOrder
    section?: SortOrder
    academicYear?: SortOrder
    capacity?: SortOrder
    roomNumber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    teacherIds?: SortOrder
  }

  export type ClassAvgOrderByAggregateInput = {
    capacity?: SortOrder
  }

  export type ClassMaxOrderByAggregateInput = {
    id?: SortOrder
    institutionId?: SortOrder
    name?: SortOrder
    section?: SortOrder
    academicYear?: SortOrder
    capacity?: SortOrder
    roomNumber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClassMinOrderByAggregateInput = {
    id?: SortOrder
    institutionId?: SortOrder
    name?: SortOrder
    section?: SortOrder
    academicYear?: SortOrder
    capacity?: SortOrder
    roomNumber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClassSumOrderByAggregateInput = {
    capacity?: SortOrder
  }

  export type StudentScalarRelationFilter = {
    is?: StudentWhereInput
    isNot?: StudentWhereInput
  }

  export type EnrollmentCountOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    classId?: SortOrder
    academicYear?: SortOrder
    enrollDate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnrollmentMaxOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    classId?: SortOrder
    academicYear?: SortOrder
    enrollDate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnrollmentMinOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    classId?: SortOrder
    academicYear?: SortOrder
    enrollDate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AttendanceCountOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    classId?: SortOrder
    date?: SortOrder
    status?: SortOrder
    remarks?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AttendanceMaxOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    classId?: SortOrder
    date?: SortOrder
    status?: SortOrder
    remarks?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AttendanceMinOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    classId?: SortOrder
    date?: SortOrder
    status?: SortOrder
    remarks?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type GradeCountOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    subject?: SortOrder
    examType?: SortOrder
    score?: SortOrder
    maxScore?: SortOrder
    grade?: SortOrder
    term?: SortOrder
    academicYear?: SortOrder
    remarks?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GradeAvgOrderByAggregateInput = {
    score?: SortOrder
    maxScore?: SortOrder
  }

  export type GradeMaxOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    subject?: SortOrder
    examType?: SortOrder
    score?: SortOrder
    maxScore?: SortOrder
    grade?: SortOrder
    term?: SortOrder
    academicYear?: SortOrder
    remarks?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GradeMinOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    subject?: SortOrder
    examType?: SortOrder
    score?: SortOrder
    maxScore?: SortOrder
    grade?: SortOrder
    term?: SortOrder
    academicYear?: SortOrder
    remarks?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GradeSumOrderByAggregateInput = {
    score?: SortOrder
    maxScore?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type TimetableCountOrderByAggregateInput = {
    id?: SortOrder
    classId?: SortOrder
    dayOfWeek?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    subject?: SortOrder
    teacherId?: SortOrder
    room?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TimetableAvgOrderByAggregateInput = {
    dayOfWeek?: SortOrder
  }

  export type TimetableMaxOrderByAggregateInput = {
    id?: SortOrder
    classId?: SortOrder
    dayOfWeek?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    subject?: SortOrder
    teacherId?: SortOrder
    room?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TimetableMinOrderByAggregateInput = {
    id?: SortOrder
    classId?: SortOrder
    dayOfWeek?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    subject?: SortOrder
    teacherId?: SortOrder
    room?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TimetableSumOrderByAggregateInput = {
    dayOfWeek?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type InstitutionNullableScalarRelationFilter = {
    is?: InstitutionWhereInput | null
    isNot?: InstitutionWhereInput | null
  }

  export type InvoiceCountOrderByAggregateInput = {
    id?: SortOrder
    institutionId?: SortOrder
    studentId?: SortOrder
    invoiceNumber?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    amountPaid?: SortOrder
    status?: SortOrder
    dueDate?: SortOrder
    paidDate?: SortOrder
    paymentMethod?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvoiceAvgOrderByAggregateInput = {
    amount?: SortOrder
    amountPaid?: SortOrder
  }

  export type InvoiceMaxOrderByAggregateInput = {
    id?: SortOrder
    institutionId?: SortOrder
    studentId?: SortOrder
    invoiceNumber?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    amountPaid?: SortOrder
    status?: SortOrder
    dueDate?: SortOrder
    paidDate?: SortOrder
    paymentMethod?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvoiceMinOrderByAggregateInput = {
    id?: SortOrder
    institutionId?: SortOrder
    studentId?: SortOrder
    invoiceNumber?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    amountPaid?: SortOrder
    status?: SortOrder
    dueDate?: SortOrder
    paidDate?: SortOrder
    paymentMethod?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvoiceSumOrderByAggregateInput = {
    amount?: SortOrder
    amountPaid?: SortOrder
  }

  export type MessageCountOrderByAggregateInput = {
    id?: SortOrder
    fromUserId?: SortOrder
    toUserId?: SortOrder
    institutionId?: SortOrder
    subject?: SortOrder
    body?: SortOrder
    isRead?: SortOrder
    readAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MessageMaxOrderByAggregateInput = {
    id?: SortOrder
    fromUserId?: SortOrder
    toUserId?: SortOrder
    institutionId?: SortOrder
    subject?: SortOrder
    body?: SortOrder
    isRead?: SortOrder
    readAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MessageMinOrderByAggregateInput = {
    id?: SortOrder
    fromUserId?: SortOrder
    toUserId?: SortOrder
    institutionId?: SortOrder
    subject?: SortOrder
    body?: SortOrder
    isRead?: SortOrder
    readAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UsersOnInstitutionCreateNestedManyWithoutInstitutionInput = {
    create?: XOR<UsersOnInstitutionCreateWithoutInstitutionInput, UsersOnInstitutionUncheckedCreateWithoutInstitutionInput> | UsersOnInstitutionCreateWithoutInstitutionInput[] | UsersOnInstitutionUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: UsersOnInstitutionCreateOrConnectWithoutInstitutionInput | UsersOnInstitutionCreateOrConnectWithoutInstitutionInput[]
    createMany?: UsersOnInstitutionCreateManyInstitutionInputEnvelope
    connect?: UsersOnInstitutionWhereUniqueInput | UsersOnInstitutionWhereUniqueInput[]
  }

  export type ClassCreateNestedManyWithoutInstitutionInput = {
    create?: XOR<ClassCreateWithoutInstitutionInput, ClassUncheckedCreateWithoutInstitutionInput> | ClassCreateWithoutInstitutionInput[] | ClassUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: ClassCreateOrConnectWithoutInstitutionInput | ClassCreateOrConnectWithoutInstitutionInput[]
    createMany?: ClassCreateManyInstitutionInputEnvelope
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
  }

  export type StudentCreateNestedManyWithoutInstitutionInput = {
    create?: XOR<StudentCreateWithoutInstitutionInput, StudentUncheckedCreateWithoutInstitutionInput> | StudentCreateWithoutInstitutionInput[] | StudentUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutInstitutionInput | StudentCreateOrConnectWithoutInstitutionInput[]
    createMany?: StudentCreateManyInstitutionInputEnvelope
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
  }

  export type TeacherOnInstitutionCreateNestedManyWithoutInstitutionInput = {
    create?: XOR<TeacherOnInstitutionCreateWithoutInstitutionInput, TeacherOnInstitutionUncheckedCreateWithoutInstitutionInput> | TeacherOnInstitutionCreateWithoutInstitutionInput[] | TeacherOnInstitutionUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: TeacherOnInstitutionCreateOrConnectWithoutInstitutionInput | TeacherOnInstitutionCreateOrConnectWithoutInstitutionInput[]
    createMany?: TeacherOnInstitutionCreateManyInstitutionInputEnvelope
    connect?: TeacherOnInstitutionWhereUniqueInput | TeacherOnInstitutionWhereUniqueInput[]
  }

  export type InvoiceCreateNestedManyWithoutInstitutionInput = {
    create?: XOR<InvoiceCreateWithoutInstitutionInput, InvoiceUncheckedCreateWithoutInstitutionInput> | InvoiceCreateWithoutInstitutionInput[] | InvoiceUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutInstitutionInput | InvoiceCreateOrConnectWithoutInstitutionInput[]
    createMany?: InvoiceCreateManyInstitutionInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type MessageCreateNestedManyWithoutInstitutionInput = {
    create?: XOR<MessageCreateWithoutInstitutionInput, MessageUncheckedCreateWithoutInstitutionInput> | MessageCreateWithoutInstitutionInput[] | MessageUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutInstitutionInput | MessageCreateOrConnectWithoutInstitutionInput[]
    createMany?: MessageCreateManyInstitutionInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type UsersOnInstitutionUncheckedCreateNestedManyWithoutInstitutionInput = {
    create?: XOR<UsersOnInstitutionCreateWithoutInstitutionInput, UsersOnInstitutionUncheckedCreateWithoutInstitutionInput> | UsersOnInstitutionCreateWithoutInstitutionInput[] | UsersOnInstitutionUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: UsersOnInstitutionCreateOrConnectWithoutInstitutionInput | UsersOnInstitutionCreateOrConnectWithoutInstitutionInput[]
    createMany?: UsersOnInstitutionCreateManyInstitutionInputEnvelope
    connect?: UsersOnInstitutionWhereUniqueInput | UsersOnInstitutionWhereUniqueInput[]
  }

  export type ClassUncheckedCreateNestedManyWithoutInstitutionInput = {
    create?: XOR<ClassCreateWithoutInstitutionInput, ClassUncheckedCreateWithoutInstitutionInput> | ClassCreateWithoutInstitutionInput[] | ClassUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: ClassCreateOrConnectWithoutInstitutionInput | ClassCreateOrConnectWithoutInstitutionInput[]
    createMany?: ClassCreateManyInstitutionInputEnvelope
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
  }

  export type StudentUncheckedCreateNestedManyWithoutInstitutionInput = {
    create?: XOR<StudentCreateWithoutInstitutionInput, StudentUncheckedCreateWithoutInstitutionInput> | StudentCreateWithoutInstitutionInput[] | StudentUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutInstitutionInput | StudentCreateOrConnectWithoutInstitutionInput[]
    createMany?: StudentCreateManyInstitutionInputEnvelope
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
  }

  export type TeacherOnInstitutionUncheckedCreateNestedManyWithoutInstitutionInput = {
    create?: XOR<TeacherOnInstitutionCreateWithoutInstitutionInput, TeacherOnInstitutionUncheckedCreateWithoutInstitutionInput> | TeacherOnInstitutionCreateWithoutInstitutionInput[] | TeacherOnInstitutionUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: TeacherOnInstitutionCreateOrConnectWithoutInstitutionInput | TeacherOnInstitutionCreateOrConnectWithoutInstitutionInput[]
    createMany?: TeacherOnInstitutionCreateManyInstitutionInputEnvelope
    connect?: TeacherOnInstitutionWhereUniqueInput | TeacherOnInstitutionWhereUniqueInput[]
  }

  export type InvoiceUncheckedCreateNestedManyWithoutInstitutionInput = {
    create?: XOR<InvoiceCreateWithoutInstitutionInput, InvoiceUncheckedCreateWithoutInstitutionInput> | InvoiceCreateWithoutInstitutionInput[] | InvoiceUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutInstitutionInput | InvoiceCreateOrConnectWithoutInstitutionInput[]
    createMany?: InvoiceCreateManyInstitutionInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutInstitutionInput = {
    create?: XOR<MessageCreateWithoutInstitutionInput, MessageUncheckedCreateWithoutInstitutionInput> | MessageCreateWithoutInstitutionInput[] | MessageUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutInstitutionInput | MessageCreateOrConnectWithoutInstitutionInput[]
    createMany?: MessageCreateManyInstitutionInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type EnumInstitutionTypeFieldUpdateOperationsInput = {
    set?: $Enums.InstitutionType
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
    unset?: boolean
  }

  export type EnumInstitutionPlanFieldUpdateOperationsInput = {
    set?: $Enums.InstitutionPlan
  }

  export type EnumSubscriptionStatusFieldUpdateOperationsInput = {
    set?: $Enums.SubscriptionStatus
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UsersOnInstitutionUpdateManyWithoutInstitutionNestedInput = {
    create?: XOR<UsersOnInstitutionCreateWithoutInstitutionInput, UsersOnInstitutionUncheckedCreateWithoutInstitutionInput> | UsersOnInstitutionCreateWithoutInstitutionInput[] | UsersOnInstitutionUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: UsersOnInstitutionCreateOrConnectWithoutInstitutionInput | UsersOnInstitutionCreateOrConnectWithoutInstitutionInput[]
    upsert?: UsersOnInstitutionUpsertWithWhereUniqueWithoutInstitutionInput | UsersOnInstitutionUpsertWithWhereUniqueWithoutInstitutionInput[]
    createMany?: UsersOnInstitutionCreateManyInstitutionInputEnvelope
    set?: UsersOnInstitutionWhereUniqueInput | UsersOnInstitutionWhereUniqueInput[]
    disconnect?: UsersOnInstitutionWhereUniqueInput | UsersOnInstitutionWhereUniqueInput[]
    delete?: UsersOnInstitutionWhereUniqueInput | UsersOnInstitutionWhereUniqueInput[]
    connect?: UsersOnInstitutionWhereUniqueInput | UsersOnInstitutionWhereUniqueInput[]
    update?: UsersOnInstitutionUpdateWithWhereUniqueWithoutInstitutionInput | UsersOnInstitutionUpdateWithWhereUniqueWithoutInstitutionInput[]
    updateMany?: UsersOnInstitutionUpdateManyWithWhereWithoutInstitutionInput | UsersOnInstitutionUpdateManyWithWhereWithoutInstitutionInput[]
    deleteMany?: UsersOnInstitutionScalarWhereInput | UsersOnInstitutionScalarWhereInput[]
  }

  export type ClassUpdateManyWithoutInstitutionNestedInput = {
    create?: XOR<ClassCreateWithoutInstitutionInput, ClassUncheckedCreateWithoutInstitutionInput> | ClassCreateWithoutInstitutionInput[] | ClassUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: ClassCreateOrConnectWithoutInstitutionInput | ClassCreateOrConnectWithoutInstitutionInput[]
    upsert?: ClassUpsertWithWhereUniqueWithoutInstitutionInput | ClassUpsertWithWhereUniqueWithoutInstitutionInput[]
    createMany?: ClassCreateManyInstitutionInputEnvelope
    set?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    disconnect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    delete?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    update?: ClassUpdateWithWhereUniqueWithoutInstitutionInput | ClassUpdateWithWhereUniqueWithoutInstitutionInput[]
    updateMany?: ClassUpdateManyWithWhereWithoutInstitutionInput | ClassUpdateManyWithWhereWithoutInstitutionInput[]
    deleteMany?: ClassScalarWhereInput | ClassScalarWhereInput[]
  }

  export type StudentUpdateManyWithoutInstitutionNestedInput = {
    create?: XOR<StudentCreateWithoutInstitutionInput, StudentUncheckedCreateWithoutInstitutionInput> | StudentCreateWithoutInstitutionInput[] | StudentUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutInstitutionInput | StudentCreateOrConnectWithoutInstitutionInput[]
    upsert?: StudentUpsertWithWhereUniqueWithoutInstitutionInput | StudentUpsertWithWhereUniqueWithoutInstitutionInput[]
    createMany?: StudentCreateManyInstitutionInputEnvelope
    set?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    disconnect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    delete?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    update?: StudentUpdateWithWhereUniqueWithoutInstitutionInput | StudentUpdateWithWhereUniqueWithoutInstitutionInput[]
    updateMany?: StudentUpdateManyWithWhereWithoutInstitutionInput | StudentUpdateManyWithWhereWithoutInstitutionInput[]
    deleteMany?: StudentScalarWhereInput | StudentScalarWhereInput[]
  }

  export type TeacherOnInstitutionUpdateManyWithoutInstitutionNestedInput = {
    create?: XOR<TeacherOnInstitutionCreateWithoutInstitutionInput, TeacherOnInstitutionUncheckedCreateWithoutInstitutionInput> | TeacherOnInstitutionCreateWithoutInstitutionInput[] | TeacherOnInstitutionUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: TeacherOnInstitutionCreateOrConnectWithoutInstitutionInput | TeacherOnInstitutionCreateOrConnectWithoutInstitutionInput[]
    upsert?: TeacherOnInstitutionUpsertWithWhereUniqueWithoutInstitutionInput | TeacherOnInstitutionUpsertWithWhereUniqueWithoutInstitutionInput[]
    createMany?: TeacherOnInstitutionCreateManyInstitutionInputEnvelope
    set?: TeacherOnInstitutionWhereUniqueInput | TeacherOnInstitutionWhereUniqueInput[]
    disconnect?: TeacherOnInstitutionWhereUniqueInput | TeacherOnInstitutionWhereUniqueInput[]
    delete?: TeacherOnInstitutionWhereUniqueInput | TeacherOnInstitutionWhereUniqueInput[]
    connect?: TeacherOnInstitutionWhereUniqueInput | TeacherOnInstitutionWhereUniqueInput[]
    update?: TeacherOnInstitutionUpdateWithWhereUniqueWithoutInstitutionInput | TeacherOnInstitutionUpdateWithWhereUniqueWithoutInstitutionInput[]
    updateMany?: TeacherOnInstitutionUpdateManyWithWhereWithoutInstitutionInput | TeacherOnInstitutionUpdateManyWithWhereWithoutInstitutionInput[]
    deleteMany?: TeacherOnInstitutionScalarWhereInput | TeacherOnInstitutionScalarWhereInput[]
  }

  export type InvoiceUpdateManyWithoutInstitutionNestedInput = {
    create?: XOR<InvoiceCreateWithoutInstitutionInput, InvoiceUncheckedCreateWithoutInstitutionInput> | InvoiceCreateWithoutInstitutionInput[] | InvoiceUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutInstitutionInput | InvoiceCreateOrConnectWithoutInstitutionInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutInstitutionInput | InvoiceUpsertWithWhereUniqueWithoutInstitutionInput[]
    createMany?: InvoiceCreateManyInstitutionInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutInstitutionInput | InvoiceUpdateWithWhereUniqueWithoutInstitutionInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutInstitutionInput | InvoiceUpdateManyWithWhereWithoutInstitutionInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type MessageUpdateManyWithoutInstitutionNestedInput = {
    create?: XOR<MessageCreateWithoutInstitutionInput, MessageUncheckedCreateWithoutInstitutionInput> | MessageCreateWithoutInstitutionInput[] | MessageUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutInstitutionInput | MessageCreateOrConnectWithoutInstitutionInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutInstitutionInput | MessageUpsertWithWhereUniqueWithoutInstitutionInput[]
    createMany?: MessageCreateManyInstitutionInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutInstitutionInput | MessageUpdateWithWhereUniqueWithoutInstitutionInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutInstitutionInput | MessageUpdateManyWithWhereWithoutInstitutionInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type UsersOnInstitutionUncheckedUpdateManyWithoutInstitutionNestedInput = {
    create?: XOR<UsersOnInstitutionCreateWithoutInstitutionInput, UsersOnInstitutionUncheckedCreateWithoutInstitutionInput> | UsersOnInstitutionCreateWithoutInstitutionInput[] | UsersOnInstitutionUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: UsersOnInstitutionCreateOrConnectWithoutInstitutionInput | UsersOnInstitutionCreateOrConnectWithoutInstitutionInput[]
    upsert?: UsersOnInstitutionUpsertWithWhereUniqueWithoutInstitutionInput | UsersOnInstitutionUpsertWithWhereUniqueWithoutInstitutionInput[]
    createMany?: UsersOnInstitutionCreateManyInstitutionInputEnvelope
    set?: UsersOnInstitutionWhereUniqueInput | UsersOnInstitutionWhereUniqueInput[]
    disconnect?: UsersOnInstitutionWhereUniqueInput | UsersOnInstitutionWhereUniqueInput[]
    delete?: UsersOnInstitutionWhereUniqueInput | UsersOnInstitutionWhereUniqueInput[]
    connect?: UsersOnInstitutionWhereUniqueInput | UsersOnInstitutionWhereUniqueInput[]
    update?: UsersOnInstitutionUpdateWithWhereUniqueWithoutInstitutionInput | UsersOnInstitutionUpdateWithWhereUniqueWithoutInstitutionInput[]
    updateMany?: UsersOnInstitutionUpdateManyWithWhereWithoutInstitutionInput | UsersOnInstitutionUpdateManyWithWhereWithoutInstitutionInput[]
    deleteMany?: UsersOnInstitutionScalarWhereInput | UsersOnInstitutionScalarWhereInput[]
  }

  export type ClassUncheckedUpdateManyWithoutInstitutionNestedInput = {
    create?: XOR<ClassCreateWithoutInstitutionInput, ClassUncheckedCreateWithoutInstitutionInput> | ClassCreateWithoutInstitutionInput[] | ClassUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: ClassCreateOrConnectWithoutInstitutionInput | ClassCreateOrConnectWithoutInstitutionInput[]
    upsert?: ClassUpsertWithWhereUniqueWithoutInstitutionInput | ClassUpsertWithWhereUniqueWithoutInstitutionInput[]
    createMany?: ClassCreateManyInstitutionInputEnvelope
    set?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    disconnect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    delete?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    update?: ClassUpdateWithWhereUniqueWithoutInstitutionInput | ClassUpdateWithWhereUniqueWithoutInstitutionInput[]
    updateMany?: ClassUpdateManyWithWhereWithoutInstitutionInput | ClassUpdateManyWithWhereWithoutInstitutionInput[]
    deleteMany?: ClassScalarWhereInput | ClassScalarWhereInput[]
  }

  export type StudentUncheckedUpdateManyWithoutInstitutionNestedInput = {
    create?: XOR<StudentCreateWithoutInstitutionInput, StudentUncheckedCreateWithoutInstitutionInput> | StudentCreateWithoutInstitutionInput[] | StudentUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutInstitutionInput | StudentCreateOrConnectWithoutInstitutionInput[]
    upsert?: StudentUpsertWithWhereUniqueWithoutInstitutionInput | StudentUpsertWithWhereUniqueWithoutInstitutionInput[]
    createMany?: StudentCreateManyInstitutionInputEnvelope
    set?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    disconnect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    delete?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    update?: StudentUpdateWithWhereUniqueWithoutInstitutionInput | StudentUpdateWithWhereUniqueWithoutInstitutionInput[]
    updateMany?: StudentUpdateManyWithWhereWithoutInstitutionInput | StudentUpdateManyWithWhereWithoutInstitutionInput[]
    deleteMany?: StudentScalarWhereInput | StudentScalarWhereInput[]
  }

  export type TeacherOnInstitutionUncheckedUpdateManyWithoutInstitutionNestedInput = {
    create?: XOR<TeacherOnInstitutionCreateWithoutInstitutionInput, TeacherOnInstitutionUncheckedCreateWithoutInstitutionInput> | TeacherOnInstitutionCreateWithoutInstitutionInput[] | TeacherOnInstitutionUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: TeacherOnInstitutionCreateOrConnectWithoutInstitutionInput | TeacherOnInstitutionCreateOrConnectWithoutInstitutionInput[]
    upsert?: TeacherOnInstitutionUpsertWithWhereUniqueWithoutInstitutionInput | TeacherOnInstitutionUpsertWithWhereUniqueWithoutInstitutionInput[]
    createMany?: TeacherOnInstitutionCreateManyInstitutionInputEnvelope
    set?: TeacherOnInstitutionWhereUniqueInput | TeacherOnInstitutionWhereUniqueInput[]
    disconnect?: TeacherOnInstitutionWhereUniqueInput | TeacherOnInstitutionWhereUniqueInput[]
    delete?: TeacherOnInstitutionWhereUniqueInput | TeacherOnInstitutionWhereUniqueInput[]
    connect?: TeacherOnInstitutionWhereUniqueInput | TeacherOnInstitutionWhereUniqueInput[]
    update?: TeacherOnInstitutionUpdateWithWhereUniqueWithoutInstitutionInput | TeacherOnInstitutionUpdateWithWhereUniqueWithoutInstitutionInput[]
    updateMany?: TeacherOnInstitutionUpdateManyWithWhereWithoutInstitutionInput | TeacherOnInstitutionUpdateManyWithWhereWithoutInstitutionInput[]
    deleteMany?: TeacherOnInstitutionScalarWhereInput | TeacherOnInstitutionScalarWhereInput[]
  }

  export type InvoiceUncheckedUpdateManyWithoutInstitutionNestedInput = {
    create?: XOR<InvoiceCreateWithoutInstitutionInput, InvoiceUncheckedCreateWithoutInstitutionInput> | InvoiceCreateWithoutInstitutionInput[] | InvoiceUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutInstitutionInput | InvoiceCreateOrConnectWithoutInstitutionInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutInstitutionInput | InvoiceUpsertWithWhereUniqueWithoutInstitutionInput[]
    createMany?: InvoiceCreateManyInstitutionInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutInstitutionInput | InvoiceUpdateWithWhereUniqueWithoutInstitutionInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutInstitutionInput | InvoiceUpdateManyWithWhereWithoutInstitutionInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutInstitutionNestedInput = {
    create?: XOR<MessageCreateWithoutInstitutionInput, MessageUncheckedCreateWithoutInstitutionInput> | MessageCreateWithoutInstitutionInput[] | MessageUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutInstitutionInput | MessageCreateOrConnectWithoutInstitutionInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutInstitutionInput | MessageUpsertWithWhereUniqueWithoutInstitutionInput[]
    createMany?: MessageCreateManyInstitutionInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutInstitutionInput | MessageUpdateWithWhereUniqueWithoutInstitutionInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutInstitutionInput | MessageUpdateManyWithWhereWithoutInstitutionInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutInstitutionsInput = {
    create?: XOR<UserCreateWithoutInstitutionsInput, UserUncheckedCreateWithoutInstitutionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutInstitutionsInput
    connect?: UserWhereUniqueInput
  }

  export type InstitutionCreateNestedOneWithoutUsersInput = {
    create?: XOR<InstitutionCreateWithoutUsersInput, InstitutionUncheckedCreateWithoutUsersInput>
    connectOrCreate?: InstitutionCreateOrConnectWithoutUsersInput
    connect?: InstitutionWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutInstitutionsNestedInput = {
    create?: XOR<UserCreateWithoutInstitutionsInput, UserUncheckedCreateWithoutInstitutionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutInstitutionsInput
    upsert?: UserUpsertWithoutInstitutionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutInstitutionsInput, UserUpdateWithoutInstitutionsInput>, UserUncheckedUpdateWithoutInstitutionsInput>
  }

  export type InstitutionUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<InstitutionCreateWithoutUsersInput, InstitutionUncheckedCreateWithoutUsersInput>
    connectOrCreate?: InstitutionCreateOrConnectWithoutUsersInput
    upsert?: InstitutionUpsertWithoutUsersInput
    connect?: InstitutionWhereUniqueInput
    update?: XOR<XOR<InstitutionUpdateToOneWithWhereWithoutUsersInput, InstitutionUpdateWithoutUsersInput>, InstitutionUncheckedUpdateWithoutUsersInput>
  }

  export type StudentCreateNestedManyWithoutUserInput = {
    create?: XOR<StudentCreateWithoutUserInput, StudentUncheckedCreateWithoutUserInput> | StudentCreateWithoutUserInput[] | StudentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutUserInput | StudentCreateOrConnectWithoutUserInput[]
    createMany?: StudentCreateManyUserInputEnvelope
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
  }

  export type TeacherCreateNestedManyWithoutUserInput = {
    create?: XOR<TeacherCreateWithoutUserInput, TeacherUncheckedCreateWithoutUserInput> | TeacherCreateWithoutUserInput[] | TeacherUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TeacherCreateOrConnectWithoutUserInput | TeacherCreateOrConnectWithoutUserInput[]
    createMany?: TeacherCreateManyUserInputEnvelope
    connect?: TeacherWhereUniqueInput | TeacherWhereUniqueInput[]
  }

  export type UserToParentCreateNestedManyWithoutUserInput = {
    create?: XOR<UserToParentCreateWithoutUserInput, UserToParentUncheckedCreateWithoutUserInput> | UserToParentCreateWithoutUserInput[] | UserToParentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserToParentCreateOrConnectWithoutUserInput | UserToParentCreateOrConnectWithoutUserInput[]
    createMany?: UserToParentCreateManyUserInputEnvelope
    connect?: UserToParentWhereUniqueInput | UserToParentWhereUniqueInput[]
  }

  export type UsersOnInstitutionCreateNestedManyWithoutUserInput = {
    create?: XOR<UsersOnInstitutionCreateWithoutUserInput, UsersOnInstitutionUncheckedCreateWithoutUserInput> | UsersOnInstitutionCreateWithoutUserInput[] | UsersOnInstitutionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UsersOnInstitutionCreateOrConnectWithoutUserInput | UsersOnInstitutionCreateOrConnectWithoutUserInput[]
    createMany?: UsersOnInstitutionCreateManyUserInputEnvelope
    connect?: UsersOnInstitutionWhereUniqueInput | UsersOnInstitutionWhereUniqueInput[]
  }

  export type MessageCreateNestedManyWithoutFromUserInput = {
    create?: XOR<MessageCreateWithoutFromUserInput, MessageUncheckedCreateWithoutFromUserInput> | MessageCreateWithoutFromUserInput[] | MessageUncheckedCreateWithoutFromUserInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutFromUserInput | MessageCreateOrConnectWithoutFromUserInput[]
    createMany?: MessageCreateManyFromUserInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type StudentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<StudentCreateWithoutUserInput, StudentUncheckedCreateWithoutUserInput> | StudentCreateWithoutUserInput[] | StudentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutUserInput | StudentCreateOrConnectWithoutUserInput[]
    createMany?: StudentCreateManyUserInputEnvelope
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
  }

  export type TeacherUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TeacherCreateWithoutUserInput, TeacherUncheckedCreateWithoutUserInput> | TeacherCreateWithoutUserInput[] | TeacherUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TeacherCreateOrConnectWithoutUserInput | TeacherCreateOrConnectWithoutUserInput[]
    createMany?: TeacherCreateManyUserInputEnvelope
    connect?: TeacherWhereUniqueInput | TeacherWhereUniqueInput[]
  }

  export type UserToParentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserToParentCreateWithoutUserInput, UserToParentUncheckedCreateWithoutUserInput> | UserToParentCreateWithoutUserInput[] | UserToParentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserToParentCreateOrConnectWithoutUserInput | UserToParentCreateOrConnectWithoutUserInput[]
    createMany?: UserToParentCreateManyUserInputEnvelope
    connect?: UserToParentWhereUniqueInput | UserToParentWhereUniqueInput[]
  }

  export type UsersOnInstitutionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UsersOnInstitutionCreateWithoutUserInput, UsersOnInstitutionUncheckedCreateWithoutUserInput> | UsersOnInstitutionCreateWithoutUserInput[] | UsersOnInstitutionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UsersOnInstitutionCreateOrConnectWithoutUserInput | UsersOnInstitutionCreateOrConnectWithoutUserInput[]
    createMany?: UsersOnInstitutionCreateManyUserInputEnvelope
    connect?: UsersOnInstitutionWhereUniqueInput | UsersOnInstitutionWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutFromUserInput = {
    create?: XOR<MessageCreateWithoutFromUserInput, MessageUncheckedCreateWithoutFromUserInput> | MessageCreateWithoutFromUserInput[] | MessageUncheckedCreateWithoutFromUserInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutFromUserInput | MessageCreateOrConnectWithoutFromUserInput[]
    createMany?: MessageCreateManyFromUserInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type EnumRoleFieldUpdateOperationsInput = {
    set?: $Enums.Role
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
    unset?: boolean
  }

  export type StudentUpdateManyWithoutUserNestedInput = {
    create?: XOR<StudentCreateWithoutUserInput, StudentUncheckedCreateWithoutUserInput> | StudentCreateWithoutUserInput[] | StudentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutUserInput | StudentCreateOrConnectWithoutUserInput[]
    upsert?: StudentUpsertWithWhereUniqueWithoutUserInput | StudentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: StudentCreateManyUserInputEnvelope
    set?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    disconnect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    delete?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    update?: StudentUpdateWithWhereUniqueWithoutUserInput | StudentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: StudentUpdateManyWithWhereWithoutUserInput | StudentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: StudentScalarWhereInput | StudentScalarWhereInput[]
  }

  export type TeacherUpdateManyWithoutUserNestedInput = {
    create?: XOR<TeacherCreateWithoutUserInput, TeacherUncheckedCreateWithoutUserInput> | TeacherCreateWithoutUserInput[] | TeacherUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TeacherCreateOrConnectWithoutUserInput | TeacherCreateOrConnectWithoutUserInput[]
    upsert?: TeacherUpsertWithWhereUniqueWithoutUserInput | TeacherUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TeacherCreateManyUserInputEnvelope
    set?: TeacherWhereUniqueInput | TeacherWhereUniqueInput[]
    disconnect?: TeacherWhereUniqueInput | TeacherWhereUniqueInput[]
    delete?: TeacherWhereUniqueInput | TeacherWhereUniqueInput[]
    connect?: TeacherWhereUniqueInput | TeacherWhereUniqueInput[]
    update?: TeacherUpdateWithWhereUniqueWithoutUserInput | TeacherUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TeacherUpdateManyWithWhereWithoutUserInput | TeacherUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TeacherScalarWhereInput | TeacherScalarWhereInput[]
  }

  export type UserToParentUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserToParentCreateWithoutUserInput, UserToParentUncheckedCreateWithoutUserInput> | UserToParentCreateWithoutUserInput[] | UserToParentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserToParentCreateOrConnectWithoutUserInput | UserToParentCreateOrConnectWithoutUserInput[]
    upsert?: UserToParentUpsertWithWhereUniqueWithoutUserInput | UserToParentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserToParentCreateManyUserInputEnvelope
    set?: UserToParentWhereUniqueInput | UserToParentWhereUniqueInput[]
    disconnect?: UserToParentWhereUniqueInput | UserToParentWhereUniqueInput[]
    delete?: UserToParentWhereUniqueInput | UserToParentWhereUniqueInput[]
    connect?: UserToParentWhereUniqueInput | UserToParentWhereUniqueInput[]
    update?: UserToParentUpdateWithWhereUniqueWithoutUserInput | UserToParentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserToParentUpdateManyWithWhereWithoutUserInput | UserToParentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserToParentScalarWhereInput | UserToParentScalarWhereInput[]
  }

  export type UsersOnInstitutionUpdateManyWithoutUserNestedInput = {
    create?: XOR<UsersOnInstitutionCreateWithoutUserInput, UsersOnInstitutionUncheckedCreateWithoutUserInput> | UsersOnInstitutionCreateWithoutUserInput[] | UsersOnInstitutionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UsersOnInstitutionCreateOrConnectWithoutUserInput | UsersOnInstitutionCreateOrConnectWithoutUserInput[]
    upsert?: UsersOnInstitutionUpsertWithWhereUniqueWithoutUserInput | UsersOnInstitutionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UsersOnInstitutionCreateManyUserInputEnvelope
    set?: UsersOnInstitutionWhereUniqueInput | UsersOnInstitutionWhereUniqueInput[]
    disconnect?: UsersOnInstitutionWhereUniqueInput | UsersOnInstitutionWhereUniqueInput[]
    delete?: UsersOnInstitutionWhereUniqueInput | UsersOnInstitutionWhereUniqueInput[]
    connect?: UsersOnInstitutionWhereUniqueInput | UsersOnInstitutionWhereUniqueInput[]
    update?: UsersOnInstitutionUpdateWithWhereUniqueWithoutUserInput | UsersOnInstitutionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UsersOnInstitutionUpdateManyWithWhereWithoutUserInput | UsersOnInstitutionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UsersOnInstitutionScalarWhereInput | UsersOnInstitutionScalarWhereInput[]
  }

  export type MessageUpdateManyWithoutFromUserNestedInput = {
    create?: XOR<MessageCreateWithoutFromUserInput, MessageUncheckedCreateWithoutFromUserInput> | MessageCreateWithoutFromUserInput[] | MessageUncheckedCreateWithoutFromUserInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutFromUserInput | MessageCreateOrConnectWithoutFromUserInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutFromUserInput | MessageUpsertWithWhereUniqueWithoutFromUserInput[]
    createMany?: MessageCreateManyFromUserInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutFromUserInput | MessageUpdateWithWhereUniqueWithoutFromUserInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutFromUserInput | MessageUpdateManyWithWhereWithoutFromUserInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type StudentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<StudentCreateWithoutUserInput, StudentUncheckedCreateWithoutUserInput> | StudentCreateWithoutUserInput[] | StudentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutUserInput | StudentCreateOrConnectWithoutUserInput[]
    upsert?: StudentUpsertWithWhereUniqueWithoutUserInput | StudentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: StudentCreateManyUserInputEnvelope
    set?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    disconnect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    delete?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    update?: StudentUpdateWithWhereUniqueWithoutUserInput | StudentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: StudentUpdateManyWithWhereWithoutUserInput | StudentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: StudentScalarWhereInput | StudentScalarWhereInput[]
  }

  export type TeacherUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TeacherCreateWithoutUserInput, TeacherUncheckedCreateWithoutUserInput> | TeacherCreateWithoutUserInput[] | TeacherUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TeacherCreateOrConnectWithoutUserInput | TeacherCreateOrConnectWithoutUserInput[]
    upsert?: TeacherUpsertWithWhereUniqueWithoutUserInput | TeacherUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TeacherCreateManyUserInputEnvelope
    set?: TeacherWhereUniqueInput | TeacherWhereUniqueInput[]
    disconnect?: TeacherWhereUniqueInput | TeacherWhereUniqueInput[]
    delete?: TeacherWhereUniqueInput | TeacherWhereUniqueInput[]
    connect?: TeacherWhereUniqueInput | TeacherWhereUniqueInput[]
    update?: TeacherUpdateWithWhereUniqueWithoutUserInput | TeacherUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TeacherUpdateManyWithWhereWithoutUserInput | TeacherUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TeacherScalarWhereInput | TeacherScalarWhereInput[]
  }

  export type UserToParentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserToParentCreateWithoutUserInput, UserToParentUncheckedCreateWithoutUserInput> | UserToParentCreateWithoutUserInput[] | UserToParentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserToParentCreateOrConnectWithoutUserInput | UserToParentCreateOrConnectWithoutUserInput[]
    upsert?: UserToParentUpsertWithWhereUniqueWithoutUserInput | UserToParentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserToParentCreateManyUserInputEnvelope
    set?: UserToParentWhereUniqueInput | UserToParentWhereUniqueInput[]
    disconnect?: UserToParentWhereUniqueInput | UserToParentWhereUniqueInput[]
    delete?: UserToParentWhereUniqueInput | UserToParentWhereUniqueInput[]
    connect?: UserToParentWhereUniqueInput | UserToParentWhereUniqueInput[]
    update?: UserToParentUpdateWithWhereUniqueWithoutUserInput | UserToParentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserToParentUpdateManyWithWhereWithoutUserInput | UserToParentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserToParentScalarWhereInput | UserToParentScalarWhereInput[]
  }

  export type UsersOnInstitutionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UsersOnInstitutionCreateWithoutUserInput, UsersOnInstitutionUncheckedCreateWithoutUserInput> | UsersOnInstitutionCreateWithoutUserInput[] | UsersOnInstitutionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UsersOnInstitutionCreateOrConnectWithoutUserInput | UsersOnInstitutionCreateOrConnectWithoutUserInput[]
    upsert?: UsersOnInstitutionUpsertWithWhereUniqueWithoutUserInput | UsersOnInstitutionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UsersOnInstitutionCreateManyUserInputEnvelope
    set?: UsersOnInstitutionWhereUniqueInput | UsersOnInstitutionWhereUniqueInput[]
    disconnect?: UsersOnInstitutionWhereUniqueInput | UsersOnInstitutionWhereUniqueInput[]
    delete?: UsersOnInstitutionWhereUniqueInput | UsersOnInstitutionWhereUniqueInput[]
    connect?: UsersOnInstitutionWhereUniqueInput | UsersOnInstitutionWhereUniqueInput[]
    update?: UsersOnInstitutionUpdateWithWhereUniqueWithoutUserInput | UsersOnInstitutionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UsersOnInstitutionUpdateManyWithWhereWithoutUserInput | UsersOnInstitutionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UsersOnInstitutionScalarWhereInput | UsersOnInstitutionScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutFromUserNestedInput = {
    create?: XOR<MessageCreateWithoutFromUserInput, MessageUncheckedCreateWithoutFromUserInput> | MessageCreateWithoutFromUserInput[] | MessageUncheckedCreateWithoutFromUserInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutFromUserInput | MessageCreateOrConnectWithoutFromUserInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutFromUserInput | MessageUpsertWithWhereUniqueWithoutFromUserInput[]
    createMany?: MessageCreateManyFromUserInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutFromUserInput | MessageUpdateWithWhereUniqueWithoutFromUserInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutFromUserInput | MessageUpdateManyWithWhereWithoutFromUserInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type StudentCreatelanguagesSpokenInput = {
    set: string[]
  }

  export type StudentCreateparentIdsInput = {
    set: string[]
  }

  export type StudentDocumentCreateNestedManyWithoutStudentInput = {
    create?: XOR<StudentDocumentCreateWithoutStudentInput, StudentDocumentUncheckedCreateWithoutStudentInput> | StudentDocumentCreateWithoutStudentInput[] | StudentDocumentUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentDocumentCreateOrConnectWithoutStudentInput | StudentDocumentCreateOrConnectWithoutStudentInput[]
    createMany?: StudentDocumentCreateManyStudentInputEnvelope
    connect?: StudentDocumentWhereUniqueInput | StudentDocumentWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutStudentInput = {
    create?: XOR<UserCreateWithoutStudentInput, UserUncheckedCreateWithoutStudentInput>
    connectOrCreate?: UserCreateOrConnectWithoutStudentInput
    connect?: UserWhereUniqueInput
  }

  export type InstitutionCreateNestedOneWithoutStudentsInput = {
    create?: XOR<InstitutionCreateWithoutStudentsInput, InstitutionUncheckedCreateWithoutStudentsInput>
    connectOrCreate?: InstitutionCreateOrConnectWithoutStudentsInput
    connect?: InstitutionWhereUniqueInput
  }

  export type ClassCreateNestedOneWithoutStudentsInput = {
    create?: XOR<ClassCreateWithoutStudentsInput, ClassUncheckedCreateWithoutStudentsInput>
    connectOrCreate?: ClassCreateOrConnectWithoutStudentsInput
    connect?: ClassWhereUniqueInput
  }

  export type ParentCreateNestedManyWithoutStudentInput = {
    create?: XOR<ParentCreateWithoutStudentInput, ParentUncheckedCreateWithoutStudentInput> | ParentCreateWithoutStudentInput[] | ParentUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: ParentCreateOrConnectWithoutStudentInput | ParentCreateOrConnectWithoutStudentInput[]
    createMany?: ParentCreateManyStudentInputEnvelope
    connect?: ParentWhereUniqueInput | ParentWhereUniqueInput[]
  }

  export type EnrollmentCreateNestedManyWithoutStudentInput = {
    create?: XOR<EnrollmentCreateWithoutStudentInput, EnrollmentUncheckedCreateWithoutStudentInput> | EnrollmentCreateWithoutStudentInput[] | EnrollmentUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: EnrollmentCreateOrConnectWithoutStudentInput | EnrollmentCreateOrConnectWithoutStudentInput[]
    createMany?: EnrollmentCreateManyStudentInputEnvelope
    connect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
  }

  export type AttendanceCreateNestedManyWithoutStudentInput = {
    create?: XOR<AttendanceCreateWithoutStudentInput, AttendanceUncheckedCreateWithoutStudentInput> | AttendanceCreateWithoutStudentInput[] | AttendanceUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutStudentInput | AttendanceCreateOrConnectWithoutStudentInput[]
    createMany?: AttendanceCreateManyStudentInputEnvelope
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
  }

  export type GradeCreateNestedManyWithoutStudentInput = {
    create?: XOR<GradeCreateWithoutStudentInput, GradeUncheckedCreateWithoutStudentInput> | GradeCreateWithoutStudentInput[] | GradeUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: GradeCreateOrConnectWithoutStudentInput | GradeCreateOrConnectWithoutStudentInput[]
    createMany?: GradeCreateManyStudentInputEnvelope
    connect?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
  }

  export type InvoiceCreateNestedManyWithoutStudentInput = {
    create?: XOR<InvoiceCreateWithoutStudentInput, InvoiceUncheckedCreateWithoutStudentInput> | InvoiceCreateWithoutStudentInput[] | InvoiceUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutStudentInput | InvoiceCreateOrConnectWithoutStudentInput[]
    createMany?: InvoiceCreateManyStudentInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type StudentDocumentUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<StudentDocumentCreateWithoutStudentInput, StudentDocumentUncheckedCreateWithoutStudentInput> | StudentDocumentCreateWithoutStudentInput[] | StudentDocumentUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentDocumentCreateOrConnectWithoutStudentInput | StudentDocumentCreateOrConnectWithoutStudentInput[]
    createMany?: StudentDocumentCreateManyStudentInputEnvelope
    connect?: StudentDocumentWhereUniqueInput | StudentDocumentWhereUniqueInput[]
  }

  export type ParentUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<ParentCreateWithoutStudentInput, ParentUncheckedCreateWithoutStudentInput> | ParentCreateWithoutStudentInput[] | ParentUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: ParentCreateOrConnectWithoutStudentInput | ParentCreateOrConnectWithoutStudentInput[]
    createMany?: ParentCreateManyStudentInputEnvelope
    connect?: ParentWhereUniqueInput | ParentWhereUniqueInput[]
  }

  export type EnrollmentUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<EnrollmentCreateWithoutStudentInput, EnrollmentUncheckedCreateWithoutStudentInput> | EnrollmentCreateWithoutStudentInput[] | EnrollmentUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: EnrollmentCreateOrConnectWithoutStudentInput | EnrollmentCreateOrConnectWithoutStudentInput[]
    createMany?: EnrollmentCreateManyStudentInputEnvelope
    connect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
  }

  export type AttendanceUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<AttendanceCreateWithoutStudentInput, AttendanceUncheckedCreateWithoutStudentInput> | AttendanceCreateWithoutStudentInput[] | AttendanceUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutStudentInput | AttendanceCreateOrConnectWithoutStudentInput[]
    createMany?: AttendanceCreateManyStudentInputEnvelope
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
  }

  export type GradeUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<GradeCreateWithoutStudentInput, GradeUncheckedCreateWithoutStudentInput> | GradeCreateWithoutStudentInput[] | GradeUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: GradeCreateOrConnectWithoutStudentInput | GradeCreateOrConnectWithoutStudentInput[]
    createMany?: GradeCreateManyStudentInputEnvelope
    connect?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
  }

  export type InvoiceUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<InvoiceCreateWithoutStudentInput, InvoiceUncheckedCreateWithoutStudentInput> | InvoiceCreateWithoutStudentInput[] | InvoiceUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutStudentInput | InvoiceCreateOrConnectWithoutStudentInput[]
    createMany?: InvoiceCreateManyStudentInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type StudentUpdatelanguagesSpokenInput = {
    set?: string[]
    push?: string | string[]
  }

  export type StudentUpdateparentIdsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type StudentDocumentUpdateManyWithoutStudentNestedInput = {
    create?: XOR<StudentDocumentCreateWithoutStudentInput, StudentDocumentUncheckedCreateWithoutStudentInput> | StudentDocumentCreateWithoutStudentInput[] | StudentDocumentUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentDocumentCreateOrConnectWithoutStudentInput | StudentDocumentCreateOrConnectWithoutStudentInput[]
    upsert?: StudentDocumentUpsertWithWhereUniqueWithoutStudentInput | StudentDocumentUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: StudentDocumentCreateManyStudentInputEnvelope
    set?: StudentDocumentWhereUniqueInput | StudentDocumentWhereUniqueInput[]
    disconnect?: StudentDocumentWhereUniqueInput | StudentDocumentWhereUniqueInput[]
    delete?: StudentDocumentWhereUniqueInput | StudentDocumentWhereUniqueInput[]
    connect?: StudentDocumentWhereUniqueInput | StudentDocumentWhereUniqueInput[]
    update?: StudentDocumentUpdateWithWhereUniqueWithoutStudentInput | StudentDocumentUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: StudentDocumentUpdateManyWithWhereWithoutStudentInput | StudentDocumentUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: StudentDocumentScalarWhereInput | StudentDocumentScalarWhereInput[]
  }

  export type UserUpdateOneWithoutStudentNestedInput = {
    create?: XOR<UserCreateWithoutStudentInput, UserUncheckedCreateWithoutStudentInput>
    connectOrCreate?: UserCreateOrConnectWithoutStudentInput
    upsert?: UserUpsertWithoutStudentInput
    disconnect?: boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutStudentInput, UserUpdateWithoutStudentInput>, UserUncheckedUpdateWithoutStudentInput>
  }

  export type InstitutionUpdateOneRequiredWithoutStudentsNestedInput = {
    create?: XOR<InstitutionCreateWithoutStudentsInput, InstitutionUncheckedCreateWithoutStudentsInput>
    connectOrCreate?: InstitutionCreateOrConnectWithoutStudentsInput
    upsert?: InstitutionUpsertWithoutStudentsInput
    connect?: InstitutionWhereUniqueInput
    update?: XOR<XOR<InstitutionUpdateToOneWithWhereWithoutStudentsInput, InstitutionUpdateWithoutStudentsInput>, InstitutionUncheckedUpdateWithoutStudentsInput>
  }

  export type ClassUpdateOneWithoutStudentsNestedInput = {
    create?: XOR<ClassCreateWithoutStudentsInput, ClassUncheckedCreateWithoutStudentsInput>
    connectOrCreate?: ClassCreateOrConnectWithoutStudentsInput
    upsert?: ClassUpsertWithoutStudentsInput
    disconnect?: boolean
    delete?: ClassWhereInput | boolean
    connect?: ClassWhereUniqueInput
    update?: XOR<XOR<ClassUpdateToOneWithWhereWithoutStudentsInput, ClassUpdateWithoutStudentsInput>, ClassUncheckedUpdateWithoutStudentsInput>
  }

  export type ParentUpdateManyWithoutStudentNestedInput = {
    create?: XOR<ParentCreateWithoutStudentInput, ParentUncheckedCreateWithoutStudentInput> | ParentCreateWithoutStudentInput[] | ParentUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: ParentCreateOrConnectWithoutStudentInput | ParentCreateOrConnectWithoutStudentInput[]
    upsert?: ParentUpsertWithWhereUniqueWithoutStudentInput | ParentUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: ParentCreateManyStudentInputEnvelope
    set?: ParentWhereUniqueInput | ParentWhereUniqueInput[]
    disconnect?: ParentWhereUniqueInput | ParentWhereUniqueInput[]
    delete?: ParentWhereUniqueInput | ParentWhereUniqueInput[]
    connect?: ParentWhereUniqueInput | ParentWhereUniqueInput[]
    update?: ParentUpdateWithWhereUniqueWithoutStudentInput | ParentUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: ParentUpdateManyWithWhereWithoutStudentInput | ParentUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: ParentScalarWhereInput | ParentScalarWhereInput[]
  }

  export type EnrollmentUpdateManyWithoutStudentNestedInput = {
    create?: XOR<EnrollmentCreateWithoutStudentInput, EnrollmentUncheckedCreateWithoutStudentInput> | EnrollmentCreateWithoutStudentInput[] | EnrollmentUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: EnrollmentCreateOrConnectWithoutStudentInput | EnrollmentCreateOrConnectWithoutStudentInput[]
    upsert?: EnrollmentUpsertWithWhereUniqueWithoutStudentInput | EnrollmentUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: EnrollmentCreateManyStudentInputEnvelope
    set?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    disconnect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    delete?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    connect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    update?: EnrollmentUpdateWithWhereUniqueWithoutStudentInput | EnrollmentUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: EnrollmentUpdateManyWithWhereWithoutStudentInput | EnrollmentUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: EnrollmentScalarWhereInput | EnrollmentScalarWhereInput[]
  }

  export type AttendanceUpdateManyWithoutStudentNestedInput = {
    create?: XOR<AttendanceCreateWithoutStudentInput, AttendanceUncheckedCreateWithoutStudentInput> | AttendanceCreateWithoutStudentInput[] | AttendanceUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutStudentInput | AttendanceCreateOrConnectWithoutStudentInput[]
    upsert?: AttendanceUpsertWithWhereUniqueWithoutStudentInput | AttendanceUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: AttendanceCreateManyStudentInputEnvelope
    set?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    disconnect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    delete?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    update?: AttendanceUpdateWithWhereUniqueWithoutStudentInput | AttendanceUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: AttendanceUpdateManyWithWhereWithoutStudentInput | AttendanceUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
  }

  export type GradeUpdateManyWithoutStudentNestedInput = {
    create?: XOR<GradeCreateWithoutStudentInput, GradeUncheckedCreateWithoutStudentInput> | GradeCreateWithoutStudentInput[] | GradeUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: GradeCreateOrConnectWithoutStudentInput | GradeCreateOrConnectWithoutStudentInput[]
    upsert?: GradeUpsertWithWhereUniqueWithoutStudentInput | GradeUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: GradeCreateManyStudentInputEnvelope
    set?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
    disconnect?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
    delete?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
    connect?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
    update?: GradeUpdateWithWhereUniqueWithoutStudentInput | GradeUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: GradeUpdateManyWithWhereWithoutStudentInput | GradeUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: GradeScalarWhereInput | GradeScalarWhereInput[]
  }

  export type InvoiceUpdateManyWithoutStudentNestedInput = {
    create?: XOR<InvoiceCreateWithoutStudentInput, InvoiceUncheckedCreateWithoutStudentInput> | InvoiceCreateWithoutStudentInput[] | InvoiceUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutStudentInput | InvoiceCreateOrConnectWithoutStudentInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutStudentInput | InvoiceUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: InvoiceCreateManyStudentInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutStudentInput | InvoiceUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutStudentInput | InvoiceUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type StudentDocumentUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<StudentDocumentCreateWithoutStudentInput, StudentDocumentUncheckedCreateWithoutStudentInput> | StudentDocumentCreateWithoutStudentInput[] | StudentDocumentUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentDocumentCreateOrConnectWithoutStudentInput | StudentDocumentCreateOrConnectWithoutStudentInput[]
    upsert?: StudentDocumentUpsertWithWhereUniqueWithoutStudentInput | StudentDocumentUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: StudentDocumentCreateManyStudentInputEnvelope
    set?: StudentDocumentWhereUniqueInput | StudentDocumentWhereUniqueInput[]
    disconnect?: StudentDocumentWhereUniqueInput | StudentDocumentWhereUniqueInput[]
    delete?: StudentDocumentWhereUniqueInput | StudentDocumentWhereUniqueInput[]
    connect?: StudentDocumentWhereUniqueInput | StudentDocumentWhereUniqueInput[]
    update?: StudentDocumentUpdateWithWhereUniqueWithoutStudentInput | StudentDocumentUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: StudentDocumentUpdateManyWithWhereWithoutStudentInput | StudentDocumentUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: StudentDocumentScalarWhereInput | StudentDocumentScalarWhereInput[]
  }

  export type ParentUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<ParentCreateWithoutStudentInput, ParentUncheckedCreateWithoutStudentInput> | ParentCreateWithoutStudentInput[] | ParentUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: ParentCreateOrConnectWithoutStudentInput | ParentCreateOrConnectWithoutStudentInput[]
    upsert?: ParentUpsertWithWhereUniqueWithoutStudentInput | ParentUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: ParentCreateManyStudentInputEnvelope
    set?: ParentWhereUniqueInput | ParentWhereUniqueInput[]
    disconnect?: ParentWhereUniqueInput | ParentWhereUniqueInput[]
    delete?: ParentWhereUniqueInput | ParentWhereUniqueInput[]
    connect?: ParentWhereUniqueInput | ParentWhereUniqueInput[]
    update?: ParentUpdateWithWhereUniqueWithoutStudentInput | ParentUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: ParentUpdateManyWithWhereWithoutStudentInput | ParentUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: ParentScalarWhereInput | ParentScalarWhereInput[]
  }

  export type EnrollmentUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<EnrollmentCreateWithoutStudentInput, EnrollmentUncheckedCreateWithoutStudentInput> | EnrollmentCreateWithoutStudentInput[] | EnrollmentUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: EnrollmentCreateOrConnectWithoutStudentInput | EnrollmentCreateOrConnectWithoutStudentInput[]
    upsert?: EnrollmentUpsertWithWhereUniqueWithoutStudentInput | EnrollmentUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: EnrollmentCreateManyStudentInputEnvelope
    set?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    disconnect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    delete?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    connect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    update?: EnrollmentUpdateWithWhereUniqueWithoutStudentInput | EnrollmentUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: EnrollmentUpdateManyWithWhereWithoutStudentInput | EnrollmentUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: EnrollmentScalarWhereInput | EnrollmentScalarWhereInput[]
  }

  export type AttendanceUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<AttendanceCreateWithoutStudentInput, AttendanceUncheckedCreateWithoutStudentInput> | AttendanceCreateWithoutStudentInput[] | AttendanceUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutStudentInput | AttendanceCreateOrConnectWithoutStudentInput[]
    upsert?: AttendanceUpsertWithWhereUniqueWithoutStudentInput | AttendanceUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: AttendanceCreateManyStudentInputEnvelope
    set?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    disconnect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    delete?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    update?: AttendanceUpdateWithWhereUniqueWithoutStudentInput | AttendanceUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: AttendanceUpdateManyWithWhereWithoutStudentInput | AttendanceUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
  }

  export type GradeUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<GradeCreateWithoutStudentInput, GradeUncheckedCreateWithoutStudentInput> | GradeCreateWithoutStudentInput[] | GradeUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: GradeCreateOrConnectWithoutStudentInput | GradeCreateOrConnectWithoutStudentInput[]
    upsert?: GradeUpsertWithWhereUniqueWithoutStudentInput | GradeUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: GradeCreateManyStudentInputEnvelope
    set?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
    disconnect?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
    delete?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
    connect?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
    update?: GradeUpdateWithWhereUniqueWithoutStudentInput | GradeUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: GradeUpdateManyWithWhereWithoutStudentInput | GradeUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: GradeScalarWhereInput | GradeScalarWhereInput[]
  }

  export type InvoiceUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<InvoiceCreateWithoutStudentInput, InvoiceUncheckedCreateWithoutStudentInput> | InvoiceCreateWithoutStudentInput[] | InvoiceUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutStudentInput | InvoiceCreateOrConnectWithoutStudentInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutStudentInput | InvoiceUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: InvoiceCreateManyStudentInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutStudentInput | InvoiceUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutStudentInput | InvoiceUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutParentInput = {
    create?: XOR<UserCreateWithoutParentInput, UserUncheckedCreateWithoutParentInput>
    connectOrCreate?: UserCreateOrConnectWithoutParentInput
    connect?: UserWhereUniqueInput
  }

  export type ParentCreateNestedOneWithoutUserInput = {
    create?: XOR<ParentCreateWithoutUserInput, ParentUncheckedCreateWithoutUserInput>
    connectOrCreate?: ParentCreateOrConnectWithoutUserInput
    connect?: ParentWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutParentNestedInput = {
    create?: XOR<UserCreateWithoutParentInput, UserUncheckedCreateWithoutParentInput>
    connectOrCreate?: UserCreateOrConnectWithoutParentInput
    upsert?: UserUpsertWithoutParentInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutParentInput, UserUpdateWithoutParentInput>, UserUncheckedUpdateWithoutParentInput>
  }

  export type ParentUpdateOneRequiredWithoutUserNestedInput = {
    create?: XOR<ParentCreateWithoutUserInput, ParentUncheckedCreateWithoutUserInput>
    connectOrCreate?: ParentCreateOrConnectWithoutUserInput
    upsert?: ParentUpsertWithoutUserInput
    connect?: ParentWhereUniqueInput
    update?: XOR<XOR<ParentUpdateToOneWithWhereWithoutUserInput, ParentUpdateWithoutUserInput>, ParentUncheckedUpdateWithoutUserInput>
  }

  export type StudentCreateNestedOneWithoutParentsInput = {
    create?: XOR<StudentCreateWithoutParentsInput, StudentUncheckedCreateWithoutParentsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutParentsInput
    connect?: StudentWhereUniqueInput
  }

  export type UserToParentCreateNestedManyWithoutParentInput = {
    create?: XOR<UserToParentCreateWithoutParentInput, UserToParentUncheckedCreateWithoutParentInput> | UserToParentCreateWithoutParentInput[] | UserToParentUncheckedCreateWithoutParentInput[]
    connectOrCreate?: UserToParentCreateOrConnectWithoutParentInput | UserToParentCreateOrConnectWithoutParentInput[]
    createMany?: UserToParentCreateManyParentInputEnvelope
    connect?: UserToParentWhereUniqueInput | UserToParentWhereUniqueInput[]
  }

  export type UserToParentUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<UserToParentCreateWithoutParentInput, UserToParentUncheckedCreateWithoutParentInput> | UserToParentCreateWithoutParentInput[] | UserToParentUncheckedCreateWithoutParentInput[]
    connectOrCreate?: UserToParentCreateOrConnectWithoutParentInput | UserToParentCreateOrConnectWithoutParentInput[]
    createMany?: UserToParentCreateManyParentInputEnvelope
    connect?: UserToParentWhereUniqueInput | UserToParentWhereUniqueInput[]
  }

  export type StudentUpdateOneWithoutParentsNestedInput = {
    create?: XOR<StudentCreateWithoutParentsInput, StudentUncheckedCreateWithoutParentsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutParentsInput
    upsert?: StudentUpsertWithoutParentsInput
    disconnect?: boolean
    delete?: StudentWhereInput | boolean
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutParentsInput, StudentUpdateWithoutParentsInput>, StudentUncheckedUpdateWithoutParentsInput>
  }

  export type UserToParentUpdateManyWithoutParentNestedInput = {
    create?: XOR<UserToParentCreateWithoutParentInput, UserToParentUncheckedCreateWithoutParentInput> | UserToParentCreateWithoutParentInput[] | UserToParentUncheckedCreateWithoutParentInput[]
    connectOrCreate?: UserToParentCreateOrConnectWithoutParentInput | UserToParentCreateOrConnectWithoutParentInput[]
    upsert?: UserToParentUpsertWithWhereUniqueWithoutParentInput | UserToParentUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: UserToParentCreateManyParentInputEnvelope
    set?: UserToParentWhereUniqueInput | UserToParentWhereUniqueInput[]
    disconnect?: UserToParentWhereUniqueInput | UserToParentWhereUniqueInput[]
    delete?: UserToParentWhereUniqueInput | UserToParentWhereUniqueInput[]
    connect?: UserToParentWhereUniqueInput | UserToParentWhereUniqueInput[]
    update?: UserToParentUpdateWithWhereUniqueWithoutParentInput | UserToParentUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: UserToParentUpdateManyWithWhereWithoutParentInput | UserToParentUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: UserToParentScalarWhereInput | UserToParentScalarWhereInput[]
  }

  export type UserToParentUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<UserToParentCreateWithoutParentInput, UserToParentUncheckedCreateWithoutParentInput> | UserToParentCreateWithoutParentInput[] | UserToParentUncheckedCreateWithoutParentInput[]
    connectOrCreate?: UserToParentCreateOrConnectWithoutParentInput | UserToParentCreateOrConnectWithoutParentInput[]
    upsert?: UserToParentUpsertWithWhereUniqueWithoutParentInput | UserToParentUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: UserToParentCreateManyParentInputEnvelope
    set?: UserToParentWhereUniqueInput | UserToParentWhereUniqueInput[]
    disconnect?: UserToParentWhereUniqueInput | UserToParentWhereUniqueInput[]
    delete?: UserToParentWhereUniqueInput | UserToParentWhereUniqueInput[]
    connect?: UserToParentWhereUniqueInput | UserToParentWhereUniqueInput[]
    update?: UserToParentUpdateWithWhereUniqueWithoutParentInput | UserToParentUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: UserToParentUpdateManyWithWhereWithoutParentInput | UserToParentUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: UserToParentScalarWhereInput | UserToParentScalarWhereInput[]
  }

  export type StudentCreateNestedOneWithoutStudentDocumentInput = {
    create?: XOR<StudentCreateWithoutStudentDocumentInput, StudentUncheckedCreateWithoutStudentDocumentInput>
    connectOrCreate?: StudentCreateOrConnectWithoutStudentDocumentInput
    connect?: StudentWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
    unset?: boolean
  }

  export type StudentUpdateOneWithoutStudentDocumentNestedInput = {
    create?: XOR<StudentCreateWithoutStudentDocumentInput, StudentUncheckedCreateWithoutStudentDocumentInput>
    connectOrCreate?: StudentCreateOrConnectWithoutStudentDocumentInput
    upsert?: StudentUpsertWithoutStudentDocumentInput
    disconnect?: boolean
    delete?: StudentWhereInput | boolean
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutStudentDocumentInput, StudentUpdateWithoutStudentDocumentInput>, StudentUncheckedUpdateWithoutStudentDocumentInput>
  }

  export type TeacherCreateNestedOneWithoutInstitutionInput = {
    create?: XOR<TeacherCreateWithoutInstitutionInput, TeacherUncheckedCreateWithoutInstitutionInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutInstitutionInput
    connect?: TeacherWhereUniqueInput
  }

  export type InstitutionCreateNestedOneWithoutTeachersInput = {
    create?: XOR<InstitutionCreateWithoutTeachersInput, InstitutionUncheckedCreateWithoutTeachersInput>
    connectOrCreate?: InstitutionCreateOrConnectWithoutTeachersInput
    connect?: InstitutionWhereUniqueInput
  }

  export type TeacherUpdateOneRequiredWithoutInstitutionNestedInput = {
    create?: XOR<TeacherCreateWithoutInstitutionInput, TeacherUncheckedCreateWithoutInstitutionInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutInstitutionInput
    upsert?: TeacherUpsertWithoutInstitutionInput
    connect?: TeacherWhereUniqueInput
    update?: XOR<XOR<TeacherUpdateToOneWithWhereWithoutInstitutionInput, TeacherUpdateWithoutInstitutionInput>, TeacherUncheckedUpdateWithoutInstitutionInput>
  }

  export type InstitutionUpdateOneRequiredWithoutTeachersNestedInput = {
    create?: XOR<InstitutionCreateWithoutTeachersInput, InstitutionUncheckedCreateWithoutTeachersInput>
    connectOrCreate?: InstitutionCreateOrConnectWithoutTeachersInput
    upsert?: InstitutionUpsertWithoutTeachersInput
    connect?: InstitutionWhereUniqueInput
    update?: XOR<XOR<InstitutionUpdateToOneWithWhereWithoutTeachersInput, InstitutionUpdateWithoutTeachersInput>, InstitutionUncheckedUpdateWithoutTeachersInput>
  }

  export type TeacherCreatesubjectsInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutTeacherInput = {
    create?: XOR<UserCreateWithoutTeacherInput, UserUncheckedCreateWithoutTeacherInput>
    connectOrCreate?: UserCreateOrConnectWithoutTeacherInput
    connect?: UserWhereUniqueInput
  }

  export type TeacherOnInstitutionCreateNestedManyWithoutTeacherInput = {
    create?: XOR<TeacherOnInstitutionCreateWithoutTeacherInput, TeacherOnInstitutionUncheckedCreateWithoutTeacherInput> | TeacherOnInstitutionCreateWithoutTeacherInput[] | TeacherOnInstitutionUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: TeacherOnInstitutionCreateOrConnectWithoutTeacherInput | TeacherOnInstitutionCreateOrConnectWithoutTeacherInput[]
    createMany?: TeacherOnInstitutionCreateManyTeacherInputEnvelope
    connect?: TeacherOnInstitutionWhereUniqueInput | TeacherOnInstitutionWhereUniqueInput[]
  }

  export type TeacherOnClassCreateNestedManyWithoutTeacherInput = {
    create?: XOR<TeacherOnClassCreateWithoutTeacherInput, TeacherOnClassUncheckedCreateWithoutTeacherInput> | TeacherOnClassCreateWithoutTeacherInput[] | TeacherOnClassUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: TeacherOnClassCreateOrConnectWithoutTeacherInput | TeacherOnClassCreateOrConnectWithoutTeacherInput[]
    createMany?: TeacherOnClassCreateManyTeacherInputEnvelope
    connect?: TeacherOnClassWhereUniqueInput | TeacherOnClassWhereUniqueInput[]
  }

  export type TeacherOnInstitutionUncheckedCreateNestedManyWithoutTeacherInput = {
    create?: XOR<TeacherOnInstitutionCreateWithoutTeacherInput, TeacherOnInstitutionUncheckedCreateWithoutTeacherInput> | TeacherOnInstitutionCreateWithoutTeacherInput[] | TeacherOnInstitutionUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: TeacherOnInstitutionCreateOrConnectWithoutTeacherInput | TeacherOnInstitutionCreateOrConnectWithoutTeacherInput[]
    createMany?: TeacherOnInstitutionCreateManyTeacherInputEnvelope
    connect?: TeacherOnInstitutionWhereUniqueInput | TeacherOnInstitutionWhereUniqueInput[]
  }

  export type TeacherOnClassUncheckedCreateNestedManyWithoutTeacherInput = {
    create?: XOR<TeacherOnClassCreateWithoutTeacherInput, TeacherOnClassUncheckedCreateWithoutTeacherInput> | TeacherOnClassCreateWithoutTeacherInput[] | TeacherOnClassUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: TeacherOnClassCreateOrConnectWithoutTeacherInput | TeacherOnClassCreateOrConnectWithoutTeacherInput[]
    createMany?: TeacherOnClassCreateManyTeacherInputEnvelope
    connect?: TeacherOnClassWhereUniqueInput | TeacherOnClassWhereUniqueInput[]
  }

  export type TeacherUpdatesubjectsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
    unset?: boolean
  }

  export type UserUpdateOneWithoutTeacherNestedInput = {
    create?: XOR<UserCreateWithoutTeacherInput, UserUncheckedCreateWithoutTeacherInput>
    connectOrCreate?: UserCreateOrConnectWithoutTeacherInput
    upsert?: UserUpsertWithoutTeacherInput
    disconnect?: boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTeacherInput, UserUpdateWithoutTeacherInput>, UserUncheckedUpdateWithoutTeacherInput>
  }

  export type TeacherOnInstitutionUpdateManyWithoutTeacherNestedInput = {
    create?: XOR<TeacherOnInstitutionCreateWithoutTeacherInput, TeacherOnInstitutionUncheckedCreateWithoutTeacherInput> | TeacherOnInstitutionCreateWithoutTeacherInput[] | TeacherOnInstitutionUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: TeacherOnInstitutionCreateOrConnectWithoutTeacherInput | TeacherOnInstitutionCreateOrConnectWithoutTeacherInput[]
    upsert?: TeacherOnInstitutionUpsertWithWhereUniqueWithoutTeacherInput | TeacherOnInstitutionUpsertWithWhereUniqueWithoutTeacherInput[]
    createMany?: TeacherOnInstitutionCreateManyTeacherInputEnvelope
    set?: TeacherOnInstitutionWhereUniqueInput | TeacherOnInstitutionWhereUniqueInput[]
    disconnect?: TeacherOnInstitutionWhereUniqueInput | TeacherOnInstitutionWhereUniqueInput[]
    delete?: TeacherOnInstitutionWhereUniqueInput | TeacherOnInstitutionWhereUniqueInput[]
    connect?: TeacherOnInstitutionWhereUniqueInput | TeacherOnInstitutionWhereUniqueInput[]
    update?: TeacherOnInstitutionUpdateWithWhereUniqueWithoutTeacherInput | TeacherOnInstitutionUpdateWithWhereUniqueWithoutTeacherInput[]
    updateMany?: TeacherOnInstitutionUpdateManyWithWhereWithoutTeacherInput | TeacherOnInstitutionUpdateManyWithWhereWithoutTeacherInput[]
    deleteMany?: TeacherOnInstitutionScalarWhereInput | TeacherOnInstitutionScalarWhereInput[]
  }

  export type TeacherOnClassUpdateManyWithoutTeacherNestedInput = {
    create?: XOR<TeacherOnClassCreateWithoutTeacherInput, TeacherOnClassUncheckedCreateWithoutTeacherInput> | TeacherOnClassCreateWithoutTeacherInput[] | TeacherOnClassUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: TeacherOnClassCreateOrConnectWithoutTeacherInput | TeacherOnClassCreateOrConnectWithoutTeacherInput[]
    upsert?: TeacherOnClassUpsertWithWhereUniqueWithoutTeacherInput | TeacherOnClassUpsertWithWhereUniqueWithoutTeacherInput[]
    createMany?: TeacherOnClassCreateManyTeacherInputEnvelope
    set?: TeacherOnClassWhereUniqueInput | TeacherOnClassWhereUniqueInput[]
    disconnect?: TeacherOnClassWhereUniqueInput | TeacherOnClassWhereUniqueInput[]
    delete?: TeacherOnClassWhereUniqueInput | TeacherOnClassWhereUniqueInput[]
    connect?: TeacherOnClassWhereUniqueInput | TeacherOnClassWhereUniqueInput[]
    update?: TeacherOnClassUpdateWithWhereUniqueWithoutTeacherInput | TeacherOnClassUpdateWithWhereUniqueWithoutTeacherInput[]
    updateMany?: TeacherOnClassUpdateManyWithWhereWithoutTeacherInput | TeacherOnClassUpdateManyWithWhereWithoutTeacherInput[]
    deleteMany?: TeacherOnClassScalarWhereInput | TeacherOnClassScalarWhereInput[]
  }

  export type TeacherOnInstitutionUncheckedUpdateManyWithoutTeacherNestedInput = {
    create?: XOR<TeacherOnInstitutionCreateWithoutTeacherInput, TeacherOnInstitutionUncheckedCreateWithoutTeacherInput> | TeacherOnInstitutionCreateWithoutTeacherInput[] | TeacherOnInstitutionUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: TeacherOnInstitutionCreateOrConnectWithoutTeacherInput | TeacherOnInstitutionCreateOrConnectWithoutTeacherInput[]
    upsert?: TeacherOnInstitutionUpsertWithWhereUniqueWithoutTeacherInput | TeacherOnInstitutionUpsertWithWhereUniqueWithoutTeacherInput[]
    createMany?: TeacherOnInstitutionCreateManyTeacherInputEnvelope
    set?: TeacherOnInstitutionWhereUniqueInput | TeacherOnInstitutionWhereUniqueInput[]
    disconnect?: TeacherOnInstitutionWhereUniqueInput | TeacherOnInstitutionWhereUniqueInput[]
    delete?: TeacherOnInstitutionWhereUniqueInput | TeacherOnInstitutionWhereUniqueInput[]
    connect?: TeacherOnInstitutionWhereUniqueInput | TeacherOnInstitutionWhereUniqueInput[]
    update?: TeacherOnInstitutionUpdateWithWhereUniqueWithoutTeacherInput | TeacherOnInstitutionUpdateWithWhereUniqueWithoutTeacherInput[]
    updateMany?: TeacherOnInstitutionUpdateManyWithWhereWithoutTeacherInput | TeacherOnInstitutionUpdateManyWithWhereWithoutTeacherInput[]
    deleteMany?: TeacherOnInstitutionScalarWhereInput | TeacherOnInstitutionScalarWhereInput[]
  }

  export type TeacherOnClassUncheckedUpdateManyWithoutTeacherNestedInput = {
    create?: XOR<TeacherOnClassCreateWithoutTeacherInput, TeacherOnClassUncheckedCreateWithoutTeacherInput> | TeacherOnClassCreateWithoutTeacherInput[] | TeacherOnClassUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: TeacherOnClassCreateOrConnectWithoutTeacherInput | TeacherOnClassCreateOrConnectWithoutTeacherInput[]
    upsert?: TeacherOnClassUpsertWithWhereUniqueWithoutTeacherInput | TeacherOnClassUpsertWithWhereUniqueWithoutTeacherInput[]
    createMany?: TeacherOnClassCreateManyTeacherInputEnvelope
    set?: TeacherOnClassWhereUniqueInput | TeacherOnClassWhereUniqueInput[]
    disconnect?: TeacherOnClassWhereUniqueInput | TeacherOnClassWhereUniqueInput[]
    delete?: TeacherOnClassWhereUniqueInput | TeacherOnClassWhereUniqueInput[]
    connect?: TeacherOnClassWhereUniqueInput | TeacherOnClassWhereUniqueInput[]
    update?: TeacherOnClassUpdateWithWhereUniqueWithoutTeacherInput | TeacherOnClassUpdateWithWhereUniqueWithoutTeacherInput[]
    updateMany?: TeacherOnClassUpdateManyWithWhereWithoutTeacherInput | TeacherOnClassUpdateManyWithWhereWithoutTeacherInput[]
    deleteMany?: TeacherOnClassScalarWhereInput | TeacherOnClassScalarWhereInput[]
  }

  export type TeacherCreateNestedOneWithoutClassesInput = {
    create?: XOR<TeacherCreateWithoutClassesInput, TeacherUncheckedCreateWithoutClassesInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutClassesInput
    connect?: TeacherWhereUniqueInput
  }

  export type ClassCreateNestedOneWithoutTeachersInput = {
    create?: XOR<ClassCreateWithoutTeachersInput, ClassUncheckedCreateWithoutTeachersInput>
    connectOrCreate?: ClassCreateOrConnectWithoutTeachersInput
    connect?: ClassWhereUniqueInput
  }

  export type TeacherUpdateOneRequiredWithoutClassesNestedInput = {
    create?: XOR<TeacherCreateWithoutClassesInput, TeacherUncheckedCreateWithoutClassesInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutClassesInput
    upsert?: TeacherUpsertWithoutClassesInput
    connect?: TeacherWhereUniqueInput
    update?: XOR<XOR<TeacherUpdateToOneWithWhereWithoutClassesInput, TeacherUpdateWithoutClassesInput>, TeacherUncheckedUpdateWithoutClassesInput>
  }

  export type ClassUpdateOneRequiredWithoutTeachersNestedInput = {
    create?: XOR<ClassCreateWithoutTeachersInput, ClassUncheckedCreateWithoutTeachersInput>
    connectOrCreate?: ClassCreateOrConnectWithoutTeachersInput
    upsert?: ClassUpsertWithoutTeachersInput
    connect?: ClassWhereUniqueInput
    update?: XOR<XOR<ClassUpdateToOneWithWhereWithoutTeachersInput, ClassUpdateWithoutTeachersInput>, ClassUncheckedUpdateWithoutTeachersInput>
  }

  export type ClassCreateteacherIdsInput = {
    set: string[]
  }

  export type InstitutionCreateNestedOneWithoutClassesInput = {
    create?: XOR<InstitutionCreateWithoutClassesInput, InstitutionUncheckedCreateWithoutClassesInput>
    connectOrCreate?: InstitutionCreateOrConnectWithoutClassesInput
    connect?: InstitutionWhereUniqueInput
  }

  export type StudentCreateNestedManyWithoutClassInput = {
    create?: XOR<StudentCreateWithoutClassInput, StudentUncheckedCreateWithoutClassInput> | StudentCreateWithoutClassInput[] | StudentUncheckedCreateWithoutClassInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutClassInput | StudentCreateOrConnectWithoutClassInput[]
    createMany?: StudentCreateManyClassInputEnvelope
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
  }

  export type TeacherOnClassCreateNestedManyWithoutClassInput = {
    create?: XOR<TeacherOnClassCreateWithoutClassInput, TeacherOnClassUncheckedCreateWithoutClassInput> | TeacherOnClassCreateWithoutClassInput[] | TeacherOnClassUncheckedCreateWithoutClassInput[]
    connectOrCreate?: TeacherOnClassCreateOrConnectWithoutClassInput | TeacherOnClassCreateOrConnectWithoutClassInput[]
    createMany?: TeacherOnClassCreateManyClassInputEnvelope
    connect?: TeacherOnClassWhereUniqueInput | TeacherOnClassWhereUniqueInput[]
  }

  export type EnrollmentCreateNestedManyWithoutClassInput = {
    create?: XOR<EnrollmentCreateWithoutClassInput, EnrollmentUncheckedCreateWithoutClassInput> | EnrollmentCreateWithoutClassInput[] | EnrollmentUncheckedCreateWithoutClassInput[]
    connectOrCreate?: EnrollmentCreateOrConnectWithoutClassInput | EnrollmentCreateOrConnectWithoutClassInput[]
    createMany?: EnrollmentCreateManyClassInputEnvelope
    connect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
  }

  export type AttendanceCreateNestedManyWithoutClassInput = {
    create?: XOR<AttendanceCreateWithoutClassInput, AttendanceUncheckedCreateWithoutClassInput> | AttendanceCreateWithoutClassInput[] | AttendanceUncheckedCreateWithoutClassInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutClassInput | AttendanceCreateOrConnectWithoutClassInput[]
    createMany?: AttendanceCreateManyClassInputEnvelope
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
  }

  export type TimetableCreateNestedManyWithoutClassInput = {
    create?: XOR<TimetableCreateWithoutClassInput, TimetableUncheckedCreateWithoutClassInput> | TimetableCreateWithoutClassInput[] | TimetableUncheckedCreateWithoutClassInput[]
    connectOrCreate?: TimetableCreateOrConnectWithoutClassInput | TimetableCreateOrConnectWithoutClassInput[]
    createMany?: TimetableCreateManyClassInputEnvelope
    connect?: TimetableWhereUniqueInput | TimetableWhereUniqueInput[]
  }

  export type StudentUncheckedCreateNestedManyWithoutClassInput = {
    create?: XOR<StudentCreateWithoutClassInput, StudentUncheckedCreateWithoutClassInput> | StudentCreateWithoutClassInput[] | StudentUncheckedCreateWithoutClassInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutClassInput | StudentCreateOrConnectWithoutClassInput[]
    createMany?: StudentCreateManyClassInputEnvelope
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
  }

  export type TeacherOnClassUncheckedCreateNestedManyWithoutClassInput = {
    create?: XOR<TeacherOnClassCreateWithoutClassInput, TeacherOnClassUncheckedCreateWithoutClassInput> | TeacherOnClassCreateWithoutClassInput[] | TeacherOnClassUncheckedCreateWithoutClassInput[]
    connectOrCreate?: TeacherOnClassCreateOrConnectWithoutClassInput | TeacherOnClassCreateOrConnectWithoutClassInput[]
    createMany?: TeacherOnClassCreateManyClassInputEnvelope
    connect?: TeacherOnClassWhereUniqueInput | TeacherOnClassWhereUniqueInput[]
  }

  export type EnrollmentUncheckedCreateNestedManyWithoutClassInput = {
    create?: XOR<EnrollmentCreateWithoutClassInput, EnrollmentUncheckedCreateWithoutClassInput> | EnrollmentCreateWithoutClassInput[] | EnrollmentUncheckedCreateWithoutClassInput[]
    connectOrCreate?: EnrollmentCreateOrConnectWithoutClassInput | EnrollmentCreateOrConnectWithoutClassInput[]
    createMany?: EnrollmentCreateManyClassInputEnvelope
    connect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
  }

  export type AttendanceUncheckedCreateNestedManyWithoutClassInput = {
    create?: XOR<AttendanceCreateWithoutClassInput, AttendanceUncheckedCreateWithoutClassInput> | AttendanceCreateWithoutClassInput[] | AttendanceUncheckedCreateWithoutClassInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutClassInput | AttendanceCreateOrConnectWithoutClassInput[]
    createMany?: AttendanceCreateManyClassInputEnvelope
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
  }

  export type TimetableUncheckedCreateNestedManyWithoutClassInput = {
    create?: XOR<TimetableCreateWithoutClassInput, TimetableUncheckedCreateWithoutClassInput> | TimetableCreateWithoutClassInput[] | TimetableUncheckedCreateWithoutClassInput[]
    connectOrCreate?: TimetableCreateOrConnectWithoutClassInput | TimetableCreateOrConnectWithoutClassInput[]
    createMany?: TimetableCreateManyClassInputEnvelope
    connect?: TimetableWhereUniqueInput | TimetableWhereUniqueInput[]
  }

  export type ClassUpdateteacherIdsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type InstitutionUpdateOneRequiredWithoutClassesNestedInput = {
    create?: XOR<InstitutionCreateWithoutClassesInput, InstitutionUncheckedCreateWithoutClassesInput>
    connectOrCreate?: InstitutionCreateOrConnectWithoutClassesInput
    upsert?: InstitutionUpsertWithoutClassesInput
    connect?: InstitutionWhereUniqueInput
    update?: XOR<XOR<InstitutionUpdateToOneWithWhereWithoutClassesInput, InstitutionUpdateWithoutClassesInput>, InstitutionUncheckedUpdateWithoutClassesInput>
  }

  export type StudentUpdateManyWithoutClassNestedInput = {
    create?: XOR<StudentCreateWithoutClassInput, StudentUncheckedCreateWithoutClassInput> | StudentCreateWithoutClassInput[] | StudentUncheckedCreateWithoutClassInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutClassInput | StudentCreateOrConnectWithoutClassInput[]
    upsert?: StudentUpsertWithWhereUniqueWithoutClassInput | StudentUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: StudentCreateManyClassInputEnvelope
    set?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    disconnect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    delete?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    update?: StudentUpdateWithWhereUniqueWithoutClassInput | StudentUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: StudentUpdateManyWithWhereWithoutClassInput | StudentUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: StudentScalarWhereInput | StudentScalarWhereInput[]
  }

  export type TeacherOnClassUpdateManyWithoutClassNestedInput = {
    create?: XOR<TeacherOnClassCreateWithoutClassInput, TeacherOnClassUncheckedCreateWithoutClassInput> | TeacherOnClassCreateWithoutClassInput[] | TeacherOnClassUncheckedCreateWithoutClassInput[]
    connectOrCreate?: TeacherOnClassCreateOrConnectWithoutClassInput | TeacherOnClassCreateOrConnectWithoutClassInput[]
    upsert?: TeacherOnClassUpsertWithWhereUniqueWithoutClassInput | TeacherOnClassUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: TeacherOnClassCreateManyClassInputEnvelope
    set?: TeacherOnClassWhereUniqueInput | TeacherOnClassWhereUniqueInput[]
    disconnect?: TeacherOnClassWhereUniqueInput | TeacherOnClassWhereUniqueInput[]
    delete?: TeacherOnClassWhereUniqueInput | TeacherOnClassWhereUniqueInput[]
    connect?: TeacherOnClassWhereUniqueInput | TeacherOnClassWhereUniqueInput[]
    update?: TeacherOnClassUpdateWithWhereUniqueWithoutClassInput | TeacherOnClassUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: TeacherOnClassUpdateManyWithWhereWithoutClassInput | TeacherOnClassUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: TeacherOnClassScalarWhereInput | TeacherOnClassScalarWhereInput[]
  }

  export type EnrollmentUpdateManyWithoutClassNestedInput = {
    create?: XOR<EnrollmentCreateWithoutClassInput, EnrollmentUncheckedCreateWithoutClassInput> | EnrollmentCreateWithoutClassInput[] | EnrollmentUncheckedCreateWithoutClassInput[]
    connectOrCreate?: EnrollmentCreateOrConnectWithoutClassInput | EnrollmentCreateOrConnectWithoutClassInput[]
    upsert?: EnrollmentUpsertWithWhereUniqueWithoutClassInput | EnrollmentUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: EnrollmentCreateManyClassInputEnvelope
    set?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    disconnect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    delete?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    connect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    update?: EnrollmentUpdateWithWhereUniqueWithoutClassInput | EnrollmentUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: EnrollmentUpdateManyWithWhereWithoutClassInput | EnrollmentUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: EnrollmentScalarWhereInput | EnrollmentScalarWhereInput[]
  }

  export type AttendanceUpdateManyWithoutClassNestedInput = {
    create?: XOR<AttendanceCreateWithoutClassInput, AttendanceUncheckedCreateWithoutClassInput> | AttendanceCreateWithoutClassInput[] | AttendanceUncheckedCreateWithoutClassInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutClassInput | AttendanceCreateOrConnectWithoutClassInput[]
    upsert?: AttendanceUpsertWithWhereUniqueWithoutClassInput | AttendanceUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: AttendanceCreateManyClassInputEnvelope
    set?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    disconnect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    delete?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    update?: AttendanceUpdateWithWhereUniqueWithoutClassInput | AttendanceUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: AttendanceUpdateManyWithWhereWithoutClassInput | AttendanceUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
  }

  export type TimetableUpdateManyWithoutClassNestedInput = {
    create?: XOR<TimetableCreateWithoutClassInput, TimetableUncheckedCreateWithoutClassInput> | TimetableCreateWithoutClassInput[] | TimetableUncheckedCreateWithoutClassInput[]
    connectOrCreate?: TimetableCreateOrConnectWithoutClassInput | TimetableCreateOrConnectWithoutClassInput[]
    upsert?: TimetableUpsertWithWhereUniqueWithoutClassInput | TimetableUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: TimetableCreateManyClassInputEnvelope
    set?: TimetableWhereUniqueInput | TimetableWhereUniqueInput[]
    disconnect?: TimetableWhereUniqueInput | TimetableWhereUniqueInput[]
    delete?: TimetableWhereUniqueInput | TimetableWhereUniqueInput[]
    connect?: TimetableWhereUniqueInput | TimetableWhereUniqueInput[]
    update?: TimetableUpdateWithWhereUniqueWithoutClassInput | TimetableUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: TimetableUpdateManyWithWhereWithoutClassInput | TimetableUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: TimetableScalarWhereInput | TimetableScalarWhereInput[]
  }

  export type StudentUncheckedUpdateManyWithoutClassNestedInput = {
    create?: XOR<StudentCreateWithoutClassInput, StudentUncheckedCreateWithoutClassInput> | StudentCreateWithoutClassInput[] | StudentUncheckedCreateWithoutClassInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutClassInput | StudentCreateOrConnectWithoutClassInput[]
    upsert?: StudentUpsertWithWhereUniqueWithoutClassInput | StudentUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: StudentCreateManyClassInputEnvelope
    set?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    disconnect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    delete?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    update?: StudentUpdateWithWhereUniqueWithoutClassInput | StudentUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: StudentUpdateManyWithWhereWithoutClassInput | StudentUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: StudentScalarWhereInput | StudentScalarWhereInput[]
  }

  export type TeacherOnClassUncheckedUpdateManyWithoutClassNestedInput = {
    create?: XOR<TeacherOnClassCreateWithoutClassInput, TeacherOnClassUncheckedCreateWithoutClassInput> | TeacherOnClassCreateWithoutClassInput[] | TeacherOnClassUncheckedCreateWithoutClassInput[]
    connectOrCreate?: TeacherOnClassCreateOrConnectWithoutClassInput | TeacherOnClassCreateOrConnectWithoutClassInput[]
    upsert?: TeacherOnClassUpsertWithWhereUniqueWithoutClassInput | TeacherOnClassUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: TeacherOnClassCreateManyClassInputEnvelope
    set?: TeacherOnClassWhereUniqueInput | TeacherOnClassWhereUniqueInput[]
    disconnect?: TeacherOnClassWhereUniqueInput | TeacherOnClassWhereUniqueInput[]
    delete?: TeacherOnClassWhereUniqueInput | TeacherOnClassWhereUniqueInput[]
    connect?: TeacherOnClassWhereUniqueInput | TeacherOnClassWhereUniqueInput[]
    update?: TeacherOnClassUpdateWithWhereUniqueWithoutClassInput | TeacherOnClassUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: TeacherOnClassUpdateManyWithWhereWithoutClassInput | TeacherOnClassUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: TeacherOnClassScalarWhereInput | TeacherOnClassScalarWhereInput[]
  }

  export type EnrollmentUncheckedUpdateManyWithoutClassNestedInput = {
    create?: XOR<EnrollmentCreateWithoutClassInput, EnrollmentUncheckedCreateWithoutClassInput> | EnrollmentCreateWithoutClassInput[] | EnrollmentUncheckedCreateWithoutClassInput[]
    connectOrCreate?: EnrollmentCreateOrConnectWithoutClassInput | EnrollmentCreateOrConnectWithoutClassInput[]
    upsert?: EnrollmentUpsertWithWhereUniqueWithoutClassInput | EnrollmentUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: EnrollmentCreateManyClassInputEnvelope
    set?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    disconnect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    delete?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    connect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    update?: EnrollmentUpdateWithWhereUniqueWithoutClassInput | EnrollmentUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: EnrollmentUpdateManyWithWhereWithoutClassInput | EnrollmentUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: EnrollmentScalarWhereInput | EnrollmentScalarWhereInput[]
  }

  export type AttendanceUncheckedUpdateManyWithoutClassNestedInput = {
    create?: XOR<AttendanceCreateWithoutClassInput, AttendanceUncheckedCreateWithoutClassInput> | AttendanceCreateWithoutClassInput[] | AttendanceUncheckedCreateWithoutClassInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutClassInput | AttendanceCreateOrConnectWithoutClassInput[]
    upsert?: AttendanceUpsertWithWhereUniqueWithoutClassInput | AttendanceUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: AttendanceCreateManyClassInputEnvelope
    set?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    disconnect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    delete?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    update?: AttendanceUpdateWithWhereUniqueWithoutClassInput | AttendanceUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: AttendanceUpdateManyWithWhereWithoutClassInput | AttendanceUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
  }

  export type TimetableUncheckedUpdateManyWithoutClassNestedInput = {
    create?: XOR<TimetableCreateWithoutClassInput, TimetableUncheckedCreateWithoutClassInput> | TimetableCreateWithoutClassInput[] | TimetableUncheckedCreateWithoutClassInput[]
    connectOrCreate?: TimetableCreateOrConnectWithoutClassInput | TimetableCreateOrConnectWithoutClassInput[]
    upsert?: TimetableUpsertWithWhereUniqueWithoutClassInput | TimetableUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: TimetableCreateManyClassInputEnvelope
    set?: TimetableWhereUniqueInput | TimetableWhereUniqueInput[]
    disconnect?: TimetableWhereUniqueInput | TimetableWhereUniqueInput[]
    delete?: TimetableWhereUniqueInput | TimetableWhereUniqueInput[]
    connect?: TimetableWhereUniqueInput | TimetableWhereUniqueInput[]
    update?: TimetableUpdateWithWhereUniqueWithoutClassInput | TimetableUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: TimetableUpdateManyWithWhereWithoutClassInput | TimetableUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: TimetableScalarWhereInput | TimetableScalarWhereInput[]
  }

  export type StudentCreateNestedOneWithoutEnrollmentsInput = {
    create?: XOR<StudentCreateWithoutEnrollmentsInput, StudentUncheckedCreateWithoutEnrollmentsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutEnrollmentsInput
    connect?: StudentWhereUniqueInput
  }

  export type ClassCreateNestedOneWithoutEnrollmentsInput = {
    create?: XOR<ClassCreateWithoutEnrollmentsInput, ClassUncheckedCreateWithoutEnrollmentsInput>
    connectOrCreate?: ClassCreateOrConnectWithoutEnrollmentsInput
    connect?: ClassWhereUniqueInput
  }

  export type StudentUpdateOneRequiredWithoutEnrollmentsNestedInput = {
    create?: XOR<StudentCreateWithoutEnrollmentsInput, StudentUncheckedCreateWithoutEnrollmentsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutEnrollmentsInput
    upsert?: StudentUpsertWithoutEnrollmentsInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutEnrollmentsInput, StudentUpdateWithoutEnrollmentsInput>, StudentUncheckedUpdateWithoutEnrollmentsInput>
  }

  export type ClassUpdateOneRequiredWithoutEnrollmentsNestedInput = {
    create?: XOR<ClassCreateWithoutEnrollmentsInput, ClassUncheckedCreateWithoutEnrollmentsInput>
    connectOrCreate?: ClassCreateOrConnectWithoutEnrollmentsInput
    upsert?: ClassUpsertWithoutEnrollmentsInput
    connect?: ClassWhereUniqueInput
    update?: XOR<XOR<ClassUpdateToOneWithWhereWithoutEnrollmentsInput, ClassUpdateWithoutEnrollmentsInput>, ClassUncheckedUpdateWithoutEnrollmentsInput>
  }

  export type ClassCreateNestedOneWithoutAttendancesInput = {
    create?: XOR<ClassCreateWithoutAttendancesInput, ClassUncheckedCreateWithoutAttendancesInput>
    connectOrCreate?: ClassCreateOrConnectWithoutAttendancesInput
    connect?: ClassWhereUniqueInput
  }

  export type StudentCreateNestedOneWithoutAttendancesInput = {
    create?: XOR<StudentCreateWithoutAttendancesInput, StudentUncheckedCreateWithoutAttendancesInput>
    connectOrCreate?: StudentCreateOrConnectWithoutAttendancesInput
    connect?: StudentWhereUniqueInput
  }

  export type ClassUpdateOneRequiredWithoutAttendancesNestedInput = {
    create?: XOR<ClassCreateWithoutAttendancesInput, ClassUncheckedCreateWithoutAttendancesInput>
    connectOrCreate?: ClassCreateOrConnectWithoutAttendancesInput
    upsert?: ClassUpsertWithoutAttendancesInput
    connect?: ClassWhereUniqueInput
    update?: XOR<XOR<ClassUpdateToOneWithWhereWithoutAttendancesInput, ClassUpdateWithoutAttendancesInput>, ClassUncheckedUpdateWithoutAttendancesInput>
  }

  export type StudentUpdateOneRequiredWithoutAttendancesNestedInput = {
    create?: XOR<StudentCreateWithoutAttendancesInput, StudentUncheckedCreateWithoutAttendancesInput>
    connectOrCreate?: StudentCreateOrConnectWithoutAttendancesInput
    upsert?: StudentUpsertWithoutAttendancesInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutAttendancesInput, StudentUpdateWithoutAttendancesInput>, StudentUncheckedUpdateWithoutAttendancesInput>
  }

  export type StudentCreateNestedOneWithoutGradesInput = {
    create?: XOR<StudentCreateWithoutGradesInput, StudentUncheckedCreateWithoutGradesInput>
    connectOrCreate?: StudentCreateOrConnectWithoutGradesInput
    connect?: StudentWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type StudentUpdateOneRequiredWithoutGradesNestedInput = {
    create?: XOR<StudentCreateWithoutGradesInput, StudentUncheckedCreateWithoutGradesInput>
    connectOrCreate?: StudentCreateOrConnectWithoutGradesInput
    upsert?: StudentUpsertWithoutGradesInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutGradesInput, StudentUpdateWithoutGradesInput>, StudentUncheckedUpdateWithoutGradesInput>
  }

  export type ClassCreateNestedOneWithoutTimetablesInput = {
    create?: XOR<ClassCreateWithoutTimetablesInput, ClassUncheckedCreateWithoutTimetablesInput>
    connectOrCreate?: ClassCreateOrConnectWithoutTimetablesInput
    connect?: ClassWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ClassUpdateOneRequiredWithoutTimetablesNestedInput = {
    create?: XOR<ClassCreateWithoutTimetablesInput, ClassUncheckedCreateWithoutTimetablesInput>
    connectOrCreate?: ClassCreateOrConnectWithoutTimetablesInput
    upsert?: ClassUpsertWithoutTimetablesInput
    connect?: ClassWhereUniqueInput
    update?: XOR<XOR<ClassUpdateToOneWithWhereWithoutTimetablesInput, ClassUpdateWithoutTimetablesInput>, ClassUncheckedUpdateWithoutTimetablesInput>
  }

  export type InstitutionCreateNestedOneWithoutInvoicesInput = {
    create?: XOR<InstitutionCreateWithoutInvoicesInput, InstitutionUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: InstitutionCreateOrConnectWithoutInvoicesInput
    connect?: InstitutionWhereUniqueInput
  }

  export type StudentCreateNestedOneWithoutInvoicesInput = {
    create?: XOR<StudentCreateWithoutInvoicesInput, StudentUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: StudentCreateOrConnectWithoutInvoicesInput
    connect?: StudentWhereUniqueInput
  }

  export type InstitutionUpdateOneWithoutInvoicesNestedInput = {
    create?: XOR<InstitutionCreateWithoutInvoicesInput, InstitutionUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: InstitutionCreateOrConnectWithoutInvoicesInput
    upsert?: InstitutionUpsertWithoutInvoicesInput
    disconnect?: boolean
    delete?: InstitutionWhereInput | boolean
    connect?: InstitutionWhereUniqueInput
    update?: XOR<XOR<InstitutionUpdateToOneWithWhereWithoutInvoicesInput, InstitutionUpdateWithoutInvoicesInput>, InstitutionUncheckedUpdateWithoutInvoicesInput>
  }

  export type StudentUpdateOneWithoutInvoicesNestedInput = {
    create?: XOR<StudentCreateWithoutInvoicesInput, StudentUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: StudentCreateOrConnectWithoutInvoicesInput
    upsert?: StudentUpsertWithoutInvoicesInput
    disconnect?: boolean
    delete?: StudentWhereInput | boolean
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutInvoicesInput, StudentUpdateWithoutInvoicesInput>, StudentUncheckedUpdateWithoutInvoicesInput>
  }

  export type UserCreateNestedOneWithoutSentMessagesInput = {
    create?: XOR<UserCreateWithoutSentMessagesInput, UserUncheckedCreateWithoutSentMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSentMessagesInput
    connect?: UserWhereUniqueInput
  }

  export type InstitutionCreateNestedOneWithoutMessagesInput = {
    create?: XOR<InstitutionCreateWithoutMessagesInput, InstitutionUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: InstitutionCreateOrConnectWithoutMessagesInput
    connect?: InstitutionWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSentMessagesNestedInput = {
    create?: XOR<UserCreateWithoutSentMessagesInput, UserUncheckedCreateWithoutSentMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSentMessagesInput
    upsert?: UserUpsertWithoutSentMessagesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSentMessagesInput, UserUpdateWithoutSentMessagesInput>, UserUncheckedUpdateWithoutSentMessagesInput>
  }

  export type InstitutionUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<InstitutionCreateWithoutMessagesInput, InstitutionUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: InstitutionCreateOrConnectWithoutMessagesInput
    upsert?: InstitutionUpsertWithoutMessagesInput
    connect?: InstitutionWhereUniqueInput
    update?: XOR<XOR<InstitutionUpdateToOneWithWhereWithoutMessagesInput, InstitutionUpdateWithoutMessagesInput>, InstitutionUncheckedUpdateWithoutMessagesInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumInstitutionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.InstitutionType | EnumInstitutionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InstitutionType[] | ListEnumInstitutionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InstitutionType[] | ListEnumInstitutionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInstitutionTypeFilter<$PrismaModel> | $Enums.InstitutionType
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
    isSet?: boolean
  }

  export type NestedEnumInstitutionPlanFilter<$PrismaModel = never> = {
    equals?: $Enums.InstitutionPlan | EnumInstitutionPlanFieldRefInput<$PrismaModel>
    in?: $Enums.InstitutionPlan[] | ListEnumInstitutionPlanFieldRefInput<$PrismaModel>
    notIn?: $Enums.InstitutionPlan[] | ListEnumInstitutionPlanFieldRefInput<$PrismaModel>
    not?: NestedEnumInstitutionPlanFilter<$PrismaModel> | $Enums.InstitutionPlan
  }

  export type NestedEnumSubscriptionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionStatusFilter<$PrismaModel> | $Enums.SubscriptionStatus
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedEnumInstitutionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InstitutionType | EnumInstitutionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InstitutionType[] | ListEnumInstitutionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InstitutionType[] | ListEnumInstitutionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInstitutionTypeWithAggregatesFilter<$PrismaModel> | $Enums.InstitutionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInstitutionTypeFilter<$PrismaModel>
    _max?: NestedEnumInstitutionTypeFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
    isSet?: boolean
  }

  export type NestedEnumInstitutionPlanWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InstitutionPlan | EnumInstitutionPlanFieldRefInput<$PrismaModel>
    in?: $Enums.InstitutionPlan[] | ListEnumInstitutionPlanFieldRefInput<$PrismaModel>
    notIn?: $Enums.InstitutionPlan[] | ListEnumInstitutionPlanFieldRefInput<$PrismaModel>
    not?: NestedEnumInstitutionPlanWithAggregatesFilter<$PrismaModel> | $Enums.InstitutionPlan
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInstitutionPlanFilter<$PrismaModel>
    _max?: NestedEnumInstitutionPlanFilter<$PrismaModel>
  }

  export type NestedEnumSubscriptionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionStatusWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionStatusFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionStatusFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
    isSet?: boolean
  }

  export type NestedEnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
    isSet?: boolean
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    isSet?: boolean
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
    isSet?: boolean
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type UsersOnInstitutionCreateWithoutInstitutionInput = {
    id?: string
    user: UserCreateNestedOneWithoutInstitutionsInput
  }

  export type UsersOnInstitutionUncheckedCreateWithoutInstitutionInput = {
    id?: string
    userId: string
  }

  export type UsersOnInstitutionCreateOrConnectWithoutInstitutionInput = {
    where: UsersOnInstitutionWhereUniqueInput
    create: XOR<UsersOnInstitutionCreateWithoutInstitutionInput, UsersOnInstitutionUncheckedCreateWithoutInstitutionInput>
  }

  export type UsersOnInstitutionCreateManyInstitutionInputEnvelope = {
    data: UsersOnInstitutionCreateManyInstitutionInput | UsersOnInstitutionCreateManyInstitutionInput[]
  }

  export type ClassCreateWithoutInstitutionInput = {
    id?: string
    name: string
    section?: string | null
    academicYear?: string | null
    capacity?: number | null
    roomNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    teacherIds?: ClassCreateteacherIdsInput | string[]
    students?: StudentCreateNestedManyWithoutClassInput
    teachers?: TeacherOnClassCreateNestedManyWithoutClassInput
    enrollments?: EnrollmentCreateNestedManyWithoutClassInput
    attendances?: AttendanceCreateNestedManyWithoutClassInput
    timetables?: TimetableCreateNestedManyWithoutClassInput
  }

  export type ClassUncheckedCreateWithoutInstitutionInput = {
    id?: string
    name: string
    section?: string | null
    academicYear?: string | null
    capacity?: number | null
    roomNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    teacherIds?: ClassCreateteacherIdsInput | string[]
    students?: StudentUncheckedCreateNestedManyWithoutClassInput
    teachers?: TeacherOnClassUncheckedCreateNestedManyWithoutClassInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutClassInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutClassInput
    timetables?: TimetableUncheckedCreateNestedManyWithoutClassInput
  }

  export type ClassCreateOrConnectWithoutInstitutionInput = {
    where: ClassWhereUniqueInput
    create: XOR<ClassCreateWithoutInstitutionInput, ClassUncheckedCreateWithoutInstitutionInput>
  }

  export type ClassCreateManyInstitutionInputEnvelope = {
    data: ClassCreateManyInstitutionInput | ClassCreateManyInstitutionInput[]
  }

  export type StudentCreateWithoutInstitutionInput = {
    id?: string
    firstName: string
    middleName?: string | null
    lastName: string
    admissionNumber?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    bloodGroup?: string | null
    address?: string | null
    gradeApplying?: string | null
    academicYear?: string | null
    phone?: string | null
    email?: string | null
    guardians?: InputJsonValue | null
    fingerprintEnrolled?: boolean
    fingerprintData?: InputJsonValue | null
    faceData?: InputJsonValue | null
    documents?: InputJsonValue | null
    photo?: string | null
    emergencyContacts?: InputJsonValue | null
    medicalConditions?: string | null
    allergies?: string | null
    medications?: string | null
    previousSchool?: string | null
    previousGrade?: string | null
    transferReason?: string | null
    enrollmentStatus?: string
    enrollmentDate?: Date | string | null
    nationality?: string | null
    religion?: string | null
    languagesSpoken?: StudentCreatelanguagesSpokenInput | string[]
    specialNeeds?: string | null
    transportRequired?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    parentIds?: StudentCreateparentIdsInput | string[]
    StudentDocument?: StudentDocumentCreateNestedManyWithoutStudentInput
    user?: UserCreateNestedOneWithoutStudentInput
    class?: ClassCreateNestedOneWithoutStudentsInput
    parents?: ParentCreateNestedManyWithoutStudentInput
    enrollments?: EnrollmentCreateNestedManyWithoutStudentInput
    attendances?: AttendanceCreateNestedManyWithoutStudentInput
    grades?: GradeCreateNestedManyWithoutStudentInput
    invoices?: InvoiceCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutInstitutionInput = {
    id?: string
    userId?: string | null
    firstName: string
    middleName?: string | null
    lastName: string
    admissionNumber?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    bloodGroup?: string | null
    address?: string | null
    gradeApplying?: string | null
    academicYear?: string | null
    classId?: string | null
    phone?: string | null
    email?: string | null
    guardians?: InputJsonValue | null
    fingerprintEnrolled?: boolean
    fingerprintData?: InputJsonValue | null
    faceData?: InputJsonValue | null
    documents?: InputJsonValue | null
    photo?: string | null
    emergencyContacts?: InputJsonValue | null
    medicalConditions?: string | null
    allergies?: string | null
    medications?: string | null
    previousSchool?: string | null
    previousGrade?: string | null
    transferReason?: string | null
    enrollmentStatus?: string
    enrollmentDate?: Date | string | null
    nationality?: string | null
    religion?: string | null
    languagesSpoken?: StudentCreatelanguagesSpokenInput | string[]
    specialNeeds?: string | null
    transportRequired?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    parentIds?: StudentCreateparentIdsInput | string[]
    StudentDocument?: StudentDocumentUncheckedCreateNestedManyWithoutStudentInput
    parents?: ParentUncheckedCreateNestedManyWithoutStudentInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutStudentInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutStudentInput
    grades?: GradeUncheckedCreateNestedManyWithoutStudentInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutInstitutionInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutInstitutionInput, StudentUncheckedCreateWithoutInstitutionInput>
  }

  export type StudentCreateManyInstitutionInputEnvelope = {
    data: StudentCreateManyInstitutionInput | StudentCreateManyInstitutionInput[]
  }

  export type TeacherOnInstitutionCreateWithoutInstitutionInput = {
    id?: string
    teacher: TeacherCreateNestedOneWithoutInstitutionInput
  }

  export type TeacherOnInstitutionUncheckedCreateWithoutInstitutionInput = {
    id?: string
    teacherId: string
  }

  export type TeacherOnInstitutionCreateOrConnectWithoutInstitutionInput = {
    where: TeacherOnInstitutionWhereUniqueInput
    create: XOR<TeacherOnInstitutionCreateWithoutInstitutionInput, TeacherOnInstitutionUncheckedCreateWithoutInstitutionInput>
  }

  export type TeacherOnInstitutionCreateManyInstitutionInputEnvelope = {
    data: TeacherOnInstitutionCreateManyInstitutionInput | TeacherOnInstitutionCreateManyInstitutionInput[]
  }

  export type InvoiceCreateWithoutInstitutionInput = {
    id?: string
    invoiceNumber: string
    description?: string | null
    amount: number
    amountPaid?: number
    status: string
    dueDate?: Date | string | null
    paidDate?: Date | string | null
    paymentMethod?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    student?: StudentCreateNestedOneWithoutInvoicesInput
  }

  export type InvoiceUncheckedCreateWithoutInstitutionInput = {
    id?: string
    studentId?: string | null
    invoiceNumber: string
    description?: string | null
    amount: number
    amountPaid?: number
    status: string
    dueDate?: Date | string | null
    paidDate?: Date | string | null
    paymentMethod?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceCreateOrConnectWithoutInstitutionInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutInstitutionInput, InvoiceUncheckedCreateWithoutInstitutionInput>
  }

  export type InvoiceCreateManyInstitutionInputEnvelope = {
    data: InvoiceCreateManyInstitutionInput | InvoiceCreateManyInstitutionInput[]
  }

  export type MessageCreateWithoutInstitutionInput = {
    id?: string
    toUserId: string
    subject?: string | null
    body: string
    isRead?: boolean
    readAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    fromUser: UserCreateNestedOneWithoutSentMessagesInput
  }

  export type MessageUncheckedCreateWithoutInstitutionInput = {
    id?: string
    fromUserId: string
    toUserId: string
    subject?: string | null
    body: string
    isRead?: boolean
    readAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessageCreateOrConnectWithoutInstitutionInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutInstitutionInput, MessageUncheckedCreateWithoutInstitutionInput>
  }

  export type MessageCreateManyInstitutionInputEnvelope = {
    data: MessageCreateManyInstitutionInput | MessageCreateManyInstitutionInput[]
  }

  export type UsersOnInstitutionUpsertWithWhereUniqueWithoutInstitutionInput = {
    where: UsersOnInstitutionWhereUniqueInput
    update: XOR<UsersOnInstitutionUpdateWithoutInstitutionInput, UsersOnInstitutionUncheckedUpdateWithoutInstitutionInput>
    create: XOR<UsersOnInstitutionCreateWithoutInstitutionInput, UsersOnInstitutionUncheckedCreateWithoutInstitutionInput>
  }

  export type UsersOnInstitutionUpdateWithWhereUniqueWithoutInstitutionInput = {
    where: UsersOnInstitutionWhereUniqueInput
    data: XOR<UsersOnInstitutionUpdateWithoutInstitutionInput, UsersOnInstitutionUncheckedUpdateWithoutInstitutionInput>
  }

  export type UsersOnInstitutionUpdateManyWithWhereWithoutInstitutionInput = {
    where: UsersOnInstitutionScalarWhereInput
    data: XOR<UsersOnInstitutionUpdateManyMutationInput, UsersOnInstitutionUncheckedUpdateManyWithoutInstitutionInput>
  }

  export type UsersOnInstitutionScalarWhereInput = {
    AND?: UsersOnInstitutionScalarWhereInput | UsersOnInstitutionScalarWhereInput[]
    OR?: UsersOnInstitutionScalarWhereInput[]
    NOT?: UsersOnInstitutionScalarWhereInput | UsersOnInstitutionScalarWhereInput[]
    id?: StringFilter<"UsersOnInstitution"> | string
    userId?: StringFilter<"UsersOnInstitution"> | string
    institutionId?: StringFilter<"UsersOnInstitution"> | string
  }

  export type ClassUpsertWithWhereUniqueWithoutInstitutionInput = {
    where: ClassWhereUniqueInput
    update: XOR<ClassUpdateWithoutInstitutionInput, ClassUncheckedUpdateWithoutInstitutionInput>
    create: XOR<ClassCreateWithoutInstitutionInput, ClassUncheckedCreateWithoutInstitutionInput>
  }

  export type ClassUpdateWithWhereUniqueWithoutInstitutionInput = {
    where: ClassWhereUniqueInput
    data: XOR<ClassUpdateWithoutInstitutionInput, ClassUncheckedUpdateWithoutInstitutionInput>
  }

  export type ClassUpdateManyWithWhereWithoutInstitutionInput = {
    where: ClassScalarWhereInput
    data: XOR<ClassUpdateManyMutationInput, ClassUncheckedUpdateManyWithoutInstitutionInput>
  }

  export type ClassScalarWhereInput = {
    AND?: ClassScalarWhereInput | ClassScalarWhereInput[]
    OR?: ClassScalarWhereInput[]
    NOT?: ClassScalarWhereInput | ClassScalarWhereInput[]
    id?: StringFilter<"Class"> | string
    institutionId?: StringFilter<"Class"> | string
    name?: StringFilter<"Class"> | string
    section?: StringNullableFilter<"Class"> | string | null
    academicYear?: StringNullableFilter<"Class"> | string | null
    capacity?: IntNullableFilter<"Class"> | number | null
    roomNumber?: StringNullableFilter<"Class"> | string | null
    createdAt?: DateTimeFilter<"Class"> | Date | string
    updatedAt?: DateTimeFilter<"Class"> | Date | string
    teacherIds?: StringNullableListFilter<"Class">
  }

  export type StudentUpsertWithWhereUniqueWithoutInstitutionInput = {
    where: StudentWhereUniqueInput
    update: XOR<StudentUpdateWithoutInstitutionInput, StudentUncheckedUpdateWithoutInstitutionInput>
    create: XOR<StudentCreateWithoutInstitutionInput, StudentUncheckedCreateWithoutInstitutionInput>
  }

  export type StudentUpdateWithWhereUniqueWithoutInstitutionInput = {
    where: StudentWhereUniqueInput
    data: XOR<StudentUpdateWithoutInstitutionInput, StudentUncheckedUpdateWithoutInstitutionInput>
  }

  export type StudentUpdateManyWithWhereWithoutInstitutionInput = {
    where: StudentScalarWhereInput
    data: XOR<StudentUpdateManyMutationInput, StudentUncheckedUpdateManyWithoutInstitutionInput>
  }

  export type StudentScalarWhereInput = {
    AND?: StudentScalarWhereInput | StudentScalarWhereInput[]
    OR?: StudentScalarWhereInput[]
    NOT?: StudentScalarWhereInput | StudentScalarWhereInput[]
    id?: StringFilter<"Student"> | string
    userId?: StringNullableFilter<"Student"> | string | null
    institutionId?: StringFilter<"Student"> | string
    firstName?: StringFilter<"Student"> | string
    middleName?: StringNullableFilter<"Student"> | string | null
    lastName?: StringFilter<"Student"> | string
    admissionNumber?: StringNullableFilter<"Student"> | string | null
    dateOfBirth?: DateTimeNullableFilter<"Student"> | Date | string | null
    gender?: StringNullableFilter<"Student"> | string | null
    bloodGroup?: StringNullableFilter<"Student"> | string | null
    address?: StringNullableFilter<"Student"> | string | null
    gradeApplying?: StringNullableFilter<"Student"> | string | null
    academicYear?: StringNullableFilter<"Student"> | string | null
    classId?: StringNullableFilter<"Student"> | string | null
    phone?: StringNullableFilter<"Student"> | string | null
    email?: StringNullableFilter<"Student"> | string | null
    guardians?: JsonNullableFilter<"Student">
    fingerprintEnrolled?: BoolFilter<"Student"> | boolean
    fingerprintData?: JsonNullableFilter<"Student">
    faceData?: JsonNullableFilter<"Student">
    documents?: JsonNullableFilter<"Student">
    photo?: StringNullableFilter<"Student"> | string | null
    emergencyContacts?: JsonNullableFilter<"Student">
    medicalConditions?: StringNullableFilter<"Student"> | string | null
    allergies?: StringNullableFilter<"Student"> | string | null
    medications?: StringNullableFilter<"Student"> | string | null
    previousSchool?: StringNullableFilter<"Student"> | string | null
    previousGrade?: StringNullableFilter<"Student"> | string | null
    transferReason?: StringNullableFilter<"Student"> | string | null
    enrollmentStatus?: StringFilter<"Student"> | string
    enrollmentDate?: DateTimeNullableFilter<"Student"> | Date | string | null
    nationality?: StringNullableFilter<"Student"> | string | null
    religion?: StringNullableFilter<"Student"> | string | null
    languagesSpoken?: StringNullableListFilter<"Student">
    specialNeeds?: StringNullableFilter<"Student"> | string | null
    transportRequired?: BoolFilter<"Student"> | boolean
    createdAt?: DateTimeFilter<"Student"> | Date | string
    updatedAt?: DateTimeFilter<"Student"> | Date | string
    parentIds?: StringNullableListFilter<"Student">
  }

  export type TeacherOnInstitutionUpsertWithWhereUniqueWithoutInstitutionInput = {
    where: TeacherOnInstitutionWhereUniqueInput
    update: XOR<TeacherOnInstitutionUpdateWithoutInstitutionInput, TeacherOnInstitutionUncheckedUpdateWithoutInstitutionInput>
    create: XOR<TeacherOnInstitutionCreateWithoutInstitutionInput, TeacherOnInstitutionUncheckedCreateWithoutInstitutionInput>
  }

  export type TeacherOnInstitutionUpdateWithWhereUniqueWithoutInstitutionInput = {
    where: TeacherOnInstitutionWhereUniqueInput
    data: XOR<TeacherOnInstitutionUpdateWithoutInstitutionInput, TeacherOnInstitutionUncheckedUpdateWithoutInstitutionInput>
  }

  export type TeacherOnInstitutionUpdateManyWithWhereWithoutInstitutionInput = {
    where: TeacherOnInstitutionScalarWhereInput
    data: XOR<TeacherOnInstitutionUpdateManyMutationInput, TeacherOnInstitutionUncheckedUpdateManyWithoutInstitutionInput>
  }

  export type TeacherOnInstitutionScalarWhereInput = {
    AND?: TeacherOnInstitutionScalarWhereInput | TeacherOnInstitutionScalarWhereInput[]
    OR?: TeacherOnInstitutionScalarWhereInput[]
    NOT?: TeacherOnInstitutionScalarWhereInput | TeacherOnInstitutionScalarWhereInput[]
    id?: StringFilter<"TeacherOnInstitution"> | string
    teacherId?: StringFilter<"TeacherOnInstitution"> | string
    institutionId?: StringFilter<"TeacherOnInstitution"> | string
  }

  export type InvoiceUpsertWithWhereUniqueWithoutInstitutionInput = {
    where: InvoiceWhereUniqueInput
    update: XOR<InvoiceUpdateWithoutInstitutionInput, InvoiceUncheckedUpdateWithoutInstitutionInput>
    create: XOR<InvoiceCreateWithoutInstitutionInput, InvoiceUncheckedCreateWithoutInstitutionInput>
  }

  export type InvoiceUpdateWithWhereUniqueWithoutInstitutionInput = {
    where: InvoiceWhereUniqueInput
    data: XOR<InvoiceUpdateWithoutInstitutionInput, InvoiceUncheckedUpdateWithoutInstitutionInput>
  }

  export type InvoiceUpdateManyWithWhereWithoutInstitutionInput = {
    where: InvoiceScalarWhereInput
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyWithoutInstitutionInput>
  }

  export type InvoiceScalarWhereInput = {
    AND?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
    OR?: InvoiceScalarWhereInput[]
    NOT?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
    id?: StringFilter<"Invoice"> | string
    institutionId?: StringFilter<"Invoice"> | string
    studentId?: StringNullableFilter<"Invoice"> | string | null
    invoiceNumber?: StringFilter<"Invoice"> | string
    description?: StringNullableFilter<"Invoice"> | string | null
    amount?: FloatFilter<"Invoice"> | number
    amountPaid?: FloatFilter<"Invoice"> | number
    status?: StringFilter<"Invoice"> | string
    dueDate?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    paidDate?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    paymentMethod?: StringNullableFilter<"Invoice"> | string | null
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeFilter<"Invoice"> | Date | string
  }

  export type MessageUpsertWithWhereUniqueWithoutInstitutionInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutInstitutionInput, MessageUncheckedUpdateWithoutInstitutionInput>
    create: XOR<MessageCreateWithoutInstitutionInput, MessageUncheckedCreateWithoutInstitutionInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutInstitutionInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutInstitutionInput, MessageUncheckedUpdateWithoutInstitutionInput>
  }

  export type MessageUpdateManyWithWhereWithoutInstitutionInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutInstitutionInput>
  }

  export type MessageScalarWhereInput = {
    AND?: MessageScalarWhereInput | MessageScalarWhereInput[]
    OR?: MessageScalarWhereInput[]
    NOT?: MessageScalarWhereInput | MessageScalarWhereInput[]
    id?: StringFilter<"Message"> | string
    fromUserId?: StringFilter<"Message"> | string
    toUserId?: StringFilter<"Message"> | string
    institutionId?: StringFilter<"Message"> | string
    subject?: StringNullableFilter<"Message"> | string | null
    body?: StringFilter<"Message"> | string
    isRead?: BoolFilter<"Message"> | boolean
    readAt?: DateTimeNullableFilter<"Message"> | Date | string | null
    createdAt?: DateTimeFilter<"Message"> | Date | string
    updatedAt?: DateTimeFilter<"Message"> | Date | string
  }

  export type UserCreateWithoutInstitutionsInput = {
    id?: string
    firstName: string
    middleName?: string | null
    lastName: string
    dateOfBirth: Date | string
    role: $Enums.Role
    email: string
    password: string
    avatar?: string | null
    phone?: string | null
    isActive?: boolean
    lastlogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    student?: StudentCreateNestedManyWithoutUserInput
    teacher?: TeacherCreateNestedManyWithoutUserInput
    parent?: UserToParentCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutFromUserInput
  }

  export type UserUncheckedCreateWithoutInstitutionsInput = {
    id?: string
    firstName: string
    middleName?: string | null
    lastName: string
    dateOfBirth: Date | string
    role: $Enums.Role
    email: string
    password: string
    avatar?: string | null
    phone?: string | null
    isActive?: boolean
    lastlogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    student?: StudentUncheckedCreateNestedManyWithoutUserInput
    teacher?: TeacherUncheckedCreateNestedManyWithoutUserInput
    parent?: UserToParentUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutFromUserInput
  }

  export type UserCreateOrConnectWithoutInstitutionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInstitutionsInput, UserUncheckedCreateWithoutInstitutionsInput>
  }

  export type InstitutionCreateWithoutUsersInput = {
    id?: string
    name: string
    institutionType?: $Enums.InstitutionType
    address: string
    city: string
    state: string
    country: string
    phone: string
    email: string
    website?: string | null
    plan?: $Enums.InstitutionPlan
    subscriptionStatus?: $Enums.SubscriptionStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    classes?: ClassCreateNestedManyWithoutInstitutionInput
    students?: StudentCreateNestedManyWithoutInstitutionInput
    teachers?: TeacherOnInstitutionCreateNestedManyWithoutInstitutionInput
    invoices?: InvoiceCreateNestedManyWithoutInstitutionInput
    messages?: MessageCreateNestedManyWithoutInstitutionInput
  }

  export type InstitutionUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    institutionType?: $Enums.InstitutionType
    address: string
    city: string
    state: string
    country: string
    phone: string
    email: string
    website?: string | null
    plan?: $Enums.InstitutionPlan
    subscriptionStatus?: $Enums.SubscriptionStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    classes?: ClassUncheckedCreateNestedManyWithoutInstitutionInput
    students?: StudentUncheckedCreateNestedManyWithoutInstitutionInput
    teachers?: TeacherOnInstitutionUncheckedCreateNestedManyWithoutInstitutionInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutInstitutionInput
    messages?: MessageUncheckedCreateNestedManyWithoutInstitutionInput
  }

  export type InstitutionCreateOrConnectWithoutUsersInput = {
    where: InstitutionWhereUniqueInput
    create: XOR<InstitutionCreateWithoutUsersInput, InstitutionUncheckedCreateWithoutUsersInput>
  }

  export type UserUpsertWithoutInstitutionsInput = {
    update: XOR<UserUpdateWithoutInstitutionsInput, UserUncheckedUpdateWithoutInstitutionsInput>
    create: XOR<UserCreateWithoutInstitutionsInput, UserUncheckedCreateWithoutInstitutionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutInstitutionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutInstitutionsInput, UserUncheckedUpdateWithoutInstitutionsInput>
  }

  export type UserUpdateWithoutInstitutionsInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastlogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateManyWithoutUserNestedInput
    teacher?: TeacherUpdateManyWithoutUserNestedInput
    parent?: UserToParentUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutFromUserNestedInput
  }

  export type UserUncheckedUpdateWithoutInstitutionsInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastlogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUncheckedUpdateManyWithoutUserNestedInput
    teacher?: TeacherUncheckedUpdateManyWithoutUserNestedInput
    parent?: UserToParentUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutFromUserNestedInput
  }

  export type InstitutionUpsertWithoutUsersInput = {
    update: XOR<InstitutionUpdateWithoutUsersInput, InstitutionUncheckedUpdateWithoutUsersInput>
    create: XOR<InstitutionCreateWithoutUsersInput, InstitutionUncheckedCreateWithoutUsersInput>
    where?: InstitutionWhereInput
  }

  export type InstitutionUpdateToOneWithWhereWithoutUsersInput = {
    where?: InstitutionWhereInput
    data: XOR<InstitutionUpdateWithoutUsersInput, InstitutionUncheckedUpdateWithoutUsersInput>
  }

  export type InstitutionUpdateWithoutUsersInput = {
    name?: StringFieldUpdateOperationsInput | string
    institutionType?: EnumInstitutionTypeFieldUpdateOperationsInput | $Enums.InstitutionType
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: EnumInstitutionPlanFieldUpdateOperationsInput | $Enums.InstitutionPlan
    subscriptionStatus?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classes?: ClassUpdateManyWithoutInstitutionNestedInput
    students?: StudentUpdateManyWithoutInstitutionNestedInput
    teachers?: TeacherOnInstitutionUpdateManyWithoutInstitutionNestedInput
    invoices?: InvoiceUpdateManyWithoutInstitutionNestedInput
    messages?: MessageUpdateManyWithoutInstitutionNestedInput
  }

  export type InstitutionUncheckedUpdateWithoutUsersInput = {
    name?: StringFieldUpdateOperationsInput | string
    institutionType?: EnumInstitutionTypeFieldUpdateOperationsInput | $Enums.InstitutionType
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: EnumInstitutionPlanFieldUpdateOperationsInput | $Enums.InstitutionPlan
    subscriptionStatus?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classes?: ClassUncheckedUpdateManyWithoutInstitutionNestedInput
    students?: StudentUncheckedUpdateManyWithoutInstitutionNestedInput
    teachers?: TeacherOnInstitutionUncheckedUpdateManyWithoutInstitutionNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutInstitutionNestedInput
    messages?: MessageUncheckedUpdateManyWithoutInstitutionNestedInput
  }

  export type StudentCreateWithoutUserInput = {
    id?: string
    firstName: string
    middleName?: string | null
    lastName: string
    admissionNumber?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    bloodGroup?: string | null
    address?: string | null
    gradeApplying?: string | null
    academicYear?: string | null
    phone?: string | null
    email?: string | null
    guardians?: InputJsonValue | null
    fingerprintEnrolled?: boolean
    fingerprintData?: InputJsonValue | null
    faceData?: InputJsonValue | null
    documents?: InputJsonValue | null
    photo?: string | null
    emergencyContacts?: InputJsonValue | null
    medicalConditions?: string | null
    allergies?: string | null
    medications?: string | null
    previousSchool?: string | null
    previousGrade?: string | null
    transferReason?: string | null
    enrollmentStatus?: string
    enrollmentDate?: Date | string | null
    nationality?: string | null
    religion?: string | null
    languagesSpoken?: StudentCreatelanguagesSpokenInput | string[]
    specialNeeds?: string | null
    transportRequired?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    parentIds?: StudentCreateparentIdsInput | string[]
    StudentDocument?: StudentDocumentCreateNestedManyWithoutStudentInput
    institution: InstitutionCreateNestedOneWithoutStudentsInput
    class?: ClassCreateNestedOneWithoutStudentsInput
    parents?: ParentCreateNestedManyWithoutStudentInput
    enrollments?: EnrollmentCreateNestedManyWithoutStudentInput
    attendances?: AttendanceCreateNestedManyWithoutStudentInput
    grades?: GradeCreateNestedManyWithoutStudentInput
    invoices?: InvoiceCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutUserInput = {
    id?: string
    institutionId: string
    firstName: string
    middleName?: string | null
    lastName: string
    admissionNumber?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    bloodGroup?: string | null
    address?: string | null
    gradeApplying?: string | null
    academicYear?: string | null
    classId?: string | null
    phone?: string | null
    email?: string | null
    guardians?: InputJsonValue | null
    fingerprintEnrolled?: boolean
    fingerprintData?: InputJsonValue | null
    faceData?: InputJsonValue | null
    documents?: InputJsonValue | null
    photo?: string | null
    emergencyContacts?: InputJsonValue | null
    medicalConditions?: string | null
    allergies?: string | null
    medications?: string | null
    previousSchool?: string | null
    previousGrade?: string | null
    transferReason?: string | null
    enrollmentStatus?: string
    enrollmentDate?: Date | string | null
    nationality?: string | null
    religion?: string | null
    languagesSpoken?: StudentCreatelanguagesSpokenInput | string[]
    specialNeeds?: string | null
    transportRequired?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    parentIds?: StudentCreateparentIdsInput | string[]
    StudentDocument?: StudentDocumentUncheckedCreateNestedManyWithoutStudentInput
    parents?: ParentUncheckedCreateNestedManyWithoutStudentInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutStudentInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutStudentInput
    grades?: GradeUncheckedCreateNestedManyWithoutStudentInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutUserInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutUserInput, StudentUncheckedCreateWithoutUserInput>
  }

  export type StudentCreateManyUserInputEnvelope = {
    data: StudentCreateManyUserInput | StudentCreateManyUserInput[]
  }

  export type TeacherCreateWithoutUserInput = {
    id?: string
    firstName: string
    middleName?: string | null
    lastName: string
    email?: string | null
    phone: string
    avatar?: string | null
    employeeNumber?: string | null
    subjects?: TeacherCreatesubjectsInput | string[]
    qualification?: string | null
    experience?: number | null
    salary?: number | null
    joinDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    institution?: TeacherOnInstitutionCreateNestedManyWithoutTeacherInput
    classes?: TeacherOnClassCreateNestedManyWithoutTeacherInput
  }

  export type TeacherUncheckedCreateWithoutUserInput = {
    id?: string
    firstName: string
    middleName?: string | null
    lastName: string
    email?: string | null
    phone: string
    avatar?: string | null
    employeeNumber?: string | null
    subjects?: TeacherCreatesubjectsInput | string[]
    qualification?: string | null
    experience?: number | null
    salary?: number | null
    joinDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    institution?: TeacherOnInstitutionUncheckedCreateNestedManyWithoutTeacherInput
    classes?: TeacherOnClassUncheckedCreateNestedManyWithoutTeacherInput
  }

  export type TeacherCreateOrConnectWithoutUserInput = {
    where: TeacherWhereUniqueInput
    create: XOR<TeacherCreateWithoutUserInput, TeacherUncheckedCreateWithoutUserInput>
  }

  export type TeacherCreateManyUserInputEnvelope = {
    data: TeacherCreateManyUserInput | TeacherCreateManyUserInput[]
  }

  export type UserToParentCreateWithoutUserInput = {
    id?: string
    parent: ParentCreateNestedOneWithoutUserInput
  }

  export type UserToParentUncheckedCreateWithoutUserInput = {
    id?: string
    parentId: string
  }

  export type UserToParentCreateOrConnectWithoutUserInput = {
    where: UserToParentWhereUniqueInput
    create: XOR<UserToParentCreateWithoutUserInput, UserToParentUncheckedCreateWithoutUserInput>
  }

  export type UserToParentCreateManyUserInputEnvelope = {
    data: UserToParentCreateManyUserInput | UserToParentCreateManyUserInput[]
  }

  export type UsersOnInstitutionCreateWithoutUserInput = {
    id?: string
    institution: InstitutionCreateNestedOneWithoutUsersInput
  }

  export type UsersOnInstitutionUncheckedCreateWithoutUserInput = {
    id?: string
    institutionId: string
  }

  export type UsersOnInstitutionCreateOrConnectWithoutUserInput = {
    where: UsersOnInstitutionWhereUniqueInput
    create: XOR<UsersOnInstitutionCreateWithoutUserInput, UsersOnInstitutionUncheckedCreateWithoutUserInput>
  }

  export type UsersOnInstitutionCreateManyUserInputEnvelope = {
    data: UsersOnInstitutionCreateManyUserInput | UsersOnInstitutionCreateManyUserInput[]
  }

  export type MessageCreateWithoutFromUserInput = {
    id?: string
    toUserId: string
    subject?: string | null
    body: string
    isRead?: boolean
    readAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    institution: InstitutionCreateNestedOneWithoutMessagesInput
  }

  export type MessageUncheckedCreateWithoutFromUserInput = {
    id?: string
    toUserId: string
    institutionId: string
    subject?: string | null
    body: string
    isRead?: boolean
    readAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessageCreateOrConnectWithoutFromUserInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutFromUserInput, MessageUncheckedCreateWithoutFromUserInput>
  }

  export type MessageCreateManyFromUserInputEnvelope = {
    data: MessageCreateManyFromUserInput | MessageCreateManyFromUserInput[]
  }

  export type StudentUpsertWithWhereUniqueWithoutUserInput = {
    where: StudentWhereUniqueInput
    update: XOR<StudentUpdateWithoutUserInput, StudentUncheckedUpdateWithoutUserInput>
    create: XOR<StudentCreateWithoutUserInput, StudentUncheckedCreateWithoutUserInput>
  }

  export type StudentUpdateWithWhereUniqueWithoutUserInput = {
    where: StudentWhereUniqueInput
    data: XOR<StudentUpdateWithoutUserInput, StudentUncheckedUpdateWithoutUserInput>
  }

  export type StudentUpdateManyWithWhereWithoutUserInput = {
    where: StudentScalarWhereInput
    data: XOR<StudentUpdateManyMutationInput, StudentUncheckedUpdateManyWithoutUserInput>
  }

  export type TeacherUpsertWithWhereUniqueWithoutUserInput = {
    where: TeacherWhereUniqueInput
    update: XOR<TeacherUpdateWithoutUserInput, TeacherUncheckedUpdateWithoutUserInput>
    create: XOR<TeacherCreateWithoutUserInput, TeacherUncheckedCreateWithoutUserInput>
  }

  export type TeacherUpdateWithWhereUniqueWithoutUserInput = {
    where: TeacherWhereUniqueInput
    data: XOR<TeacherUpdateWithoutUserInput, TeacherUncheckedUpdateWithoutUserInput>
  }

  export type TeacherUpdateManyWithWhereWithoutUserInput = {
    where: TeacherScalarWhereInput
    data: XOR<TeacherUpdateManyMutationInput, TeacherUncheckedUpdateManyWithoutUserInput>
  }

  export type TeacherScalarWhereInput = {
    AND?: TeacherScalarWhereInput | TeacherScalarWhereInput[]
    OR?: TeacherScalarWhereInput[]
    NOT?: TeacherScalarWhereInput | TeacherScalarWhereInput[]
    id?: StringFilter<"Teacher"> | string
    userId?: StringNullableFilter<"Teacher"> | string | null
    firstName?: StringFilter<"Teacher"> | string
    middleName?: StringNullableFilter<"Teacher"> | string | null
    lastName?: StringFilter<"Teacher"> | string
    email?: StringNullableFilter<"Teacher"> | string | null
    phone?: StringFilter<"Teacher"> | string
    avatar?: StringNullableFilter<"Teacher"> | string | null
    employeeNumber?: StringNullableFilter<"Teacher"> | string | null
    subjects?: StringNullableListFilter<"Teacher">
    qualification?: StringNullableFilter<"Teacher"> | string | null
    experience?: IntNullableFilter<"Teacher"> | number | null
    salary?: FloatNullableFilter<"Teacher"> | number | null
    joinDate?: DateTimeNullableFilter<"Teacher"> | Date | string | null
    createdAt?: DateTimeFilter<"Teacher"> | Date | string
    updatedAt?: DateTimeFilter<"Teacher"> | Date | string
  }

  export type UserToParentUpsertWithWhereUniqueWithoutUserInput = {
    where: UserToParentWhereUniqueInput
    update: XOR<UserToParentUpdateWithoutUserInput, UserToParentUncheckedUpdateWithoutUserInput>
    create: XOR<UserToParentCreateWithoutUserInput, UserToParentUncheckedCreateWithoutUserInput>
  }

  export type UserToParentUpdateWithWhereUniqueWithoutUserInput = {
    where: UserToParentWhereUniqueInput
    data: XOR<UserToParentUpdateWithoutUserInput, UserToParentUncheckedUpdateWithoutUserInput>
  }

  export type UserToParentUpdateManyWithWhereWithoutUserInput = {
    where: UserToParentScalarWhereInput
    data: XOR<UserToParentUpdateManyMutationInput, UserToParentUncheckedUpdateManyWithoutUserInput>
  }

  export type UserToParentScalarWhereInput = {
    AND?: UserToParentScalarWhereInput | UserToParentScalarWhereInput[]
    OR?: UserToParentScalarWhereInput[]
    NOT?: UserToParentScalarWhereInput | UserToParentScalarWhereInput[]
    id?: StringFilter<"UserToParent"> | string
    userId?: StringFilter<"UserToParent"> | string
    parentId?: StringFilter<"UserToParent"> | string
  }

  export type UsersOnInstitutionUpsertWithWhereUniqueWithoutUserInput = {
    where: UsersOnInstitutionWhereUniqueInput
    update: XOR<UsersOnInstitutionUpdateWithoutUserInput, UsersOnInstitutionUncheckedUpdateWithoutUserInput>
    create: XOR<UsersOnInstitutionCreateWithoutUserInput, UsersOnInstitutionUncheckedCreateWithoutUserInput>
  }

  export type UsersOnInstitutionUpdateWithWhereUniqueWithoutUserInput = {
    where: UsersOnInstitutionWhereUniqueInput
    data: XOR<UsersOnInstitutionUpdateWithoutUserInput, UsersOnInstitutionUncheckedUpdateWithoutUserInput>
  }

  export type UsersOnInstitutionUpdateManyWithWhereWithoutUserInput = {
    where: UsersOnInstitutionScalarWhereInput
    data: XOR<UsersOnInstitutionUpdateManyMutationInput, UsersOnInstitutionUncheckedUpdateManyWithoutUserInput>
  }

  export type MessageUpsertWithWhereUniqueWithoutFromUserInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutFromUserInput, MessageUncheckedUpdateWithoutFromUserInput>
    create: XOR<MessageCreateWithoutFromUserInput, MessageUncheckedCreateWithoutFromUserInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutFromUserInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutFromUserInput, MessageUncheckedUpdateWithoutFromUserInput>
  }

  export type MessageUpdateManyWithWhereWithoutFromUserInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutFromUserInput>
  }

  export type StudentDocumentCreateWithoutStudentInput = {
    id?: string
    documentType: string
    documentName: string
    documentUrl: string
    fileSize?: number | null
    mimeType?: string | null
    uploadedAt?: Date | string
    uploadedBy?: string | null
    verified?: boolean
    verifiedBy?: string | null
    verifiedAt?: Date | string | null
  }

  export type StudentDocumentUncheckedCreateWithoutStudentInput = {
    id?: string
    documentType: string
    documentName: string
    documentUrl: string
    fileSize?: number | null
    mimeType?: string | null
    uploadedAt?: Date | string
    uploadedBy?: string | null
    verified?: boolean
    verifiedBy?: string | null
    verifiedAt?: Date | string | null
  }

  export type StudentDocumentCreateOrConnectWithoutStudentInput = {
    where: StudentDocumentWhereUniqueInput
    create: XOR<StudentDocumentCreateWithoutStudentInput, StudentDocumentUncheckedCreateWithoutStudentInput>
  }

  export type StudentDocumentCreateManyStudentInputEnvelope = {
    data: StudentDocumentCreateManyStudentInput | StudentDocumentCreateManyStudentInput[]
  }

  export type UserCreateWithoutStudentInput = {
    id?: string
    firstName: string
    middleName?: string | null
    lastName: string
    dateOfBirth: Date | string
    role: $Enums.Role
    email: string
    password: string
    avatar?: string | null
    phone?: string | null
    isActive?: boolean
    lastlogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    teacher?: TeacherCreateNestedManyWithoutUserInput
    parent?: UserToParentCreateNestedManyWithoutUserInput
    institutions?: UsersOnInstitutionCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutFromUserInput
  }

  export type UserUncheckedCreateWithoutStudentInput = {
    id?: string
    firstName: string
    middleName?: string | null
    lastName: string
    dateOfBirth: Date | string
    role: $Enums.Role
    email: string
    password: string
    avatar?: string | null
    phone?: string | null
    isActive?: boolean
    lastlogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    teacher?: TeacherUncheckedCreateNestedManyWithoutUserInput
    parent?: UserToParentUncheckedCreateNestedManyWithoutUserInput
    institutions?: UsersOnInstitutionUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutFromUserInput
  }

  export type UserCreateOrConnectWithoutStudentInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutStudentInput, UserUncheckedCreateWithoutStudentInput>
  }

  export type InstitutionCreateWithoutStudentsInput = {
    id?: string
    name: string
    institutionType?: $Enums.InstitutionType
    address: string
    city: string
    state: string
    country: string
    phone: string
    email: string
    website?: string | null
    plan?: $Enums.InstitutionPlan
    subscriptionStatus?: $Enums.SubscriptionStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UsersOnInstitutionCreateNestedManyWithoutInstitutionInput
    classes?: ClassCreateNestedManyWithoutInstitutionInput
    teachers?: TeacherOnInstitutionCreateNestedManyWithoutInstitutionInput
    invoices?: InvoiceCreateNestedManyWithoutInstitutionInput
    messages?: MessageCreateNestedManyWithoutInstitutionInput
  }

  export type InstitutionUncheckedCreateWithoutStudentsInput = {
    id?: string
    name: string
    institutionType?: $Enums.InstitutionType
    address: string
    city: string
    state: string
    country: string
    phone: string
    email: string
    website?: string | null
    plan?: $Enums.InstitutionPlan
    subscriptionStatus?: $Enums.SubscriptionStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UsersOnInstitutionUncheckedCreateNestedManyWithoutInstitutionInput
    classes?: ClassUncheckedCreateNestedManyWithoutInstitutionInput
    teachers?: TeacherOnInstitutionUncheckedCreateNestedManyWithoutInstitutionInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutInstitutionInput
    messages?: MessageUncheckedCreateNestedManyWithoutInstitutionInput
  }

  export type InstitutionCreateOrConnectWithoutStudentsInput = {
    where: InstitutionWhereUniqueInput
    create: XOR<InstitutionCreateWithoutStudentsInput, InstitutionUncheckedCreateWithoutStudentsInput>
  }

  export type ClassCreateWithoutStudentsInput = {
    id?: string
    name: string
    section?: string | null
    academicYear?: string | null
    capacity?: number | null
    roomNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    teacherIds?: ClassCreateteacherIdsInput | string[]
    institution: InstitutionCreateNestedOneWithoutClassesInput
    teachers?: TeacherOnClassCreateNestedManyWithoutClassInput
    enrollments?: EnrollmentCreateNestedManyWithoutClassInput
    attendances?: AttendanceCreateNestedManyWithoutClassInput
    timetables?: TimetableCreateNestedManyWithoutClassInput
  }

  export type ClassUncheckedCreateWithoutStudentsInput = {
    id?: string
    institutionId: string
    name: string
    section?: string | null
    academicYear?: string | null
    capacity?: number | null
    roomNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    teacherIds?: ClassCreateteacherIdsInput | string[]
    teachers?: TeacherOnClassUncheckedCreateNestedManyWithoutClassInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutClassInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutClassInput
    timetables?: TimetableUncheckedCreateNestedManyWithoutClassInput
  }

  export type ClassCreateOrConnectWithoutStudentsInput = {
    where: ClassWhereUniqueInput
    create: XOR<ClassCreateWithoutStudentsInput, ClassUncheckedCreateWithoutStudentsInput>
  }

  export type ParentCreateWithoutStudentInput = {
    id?: string
    institutionId: string
    firstName: string
    middleName?: string | null
    lastName: string
    email: string
    phone: string
    occupation?: string | null
    relationship?: string | null
    address?: string | null
    isPrimaryContact?: boolean
    isEmergencyContact?: boolean
    preferredContactTime?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserToParentCreateNestedManyWithoutParentInput
  }

  export type ParentUncheckedCreateWithoutStudentInput = {
    id?: string
    institutionId: string
    firstName: string
    middleName?: string | null
    lastName: string
    email: string
    phone: string
    occupation?: string | null
    relationship?: string | null
    address?: string | null
    isPrimaryContact?: boolean
    isEmergencyContact?: boolean
    preferredContactTime?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserToParentUncheckedCreateNestedManyWithoutParentInput
  }

  export type ParentCreateOrConnectWithoutStudentInput = {
    where: ParentWhereUniqueInput
    create: XOR<ParentCreateWithoutStudentInput, ParentUncheckedCreateWithoutStudentInput>
  }

  export type ParentCreateManyStudentInputEnvelope = {
    data: ParentCreateManyStudentInput | ParentCreateManyStudentInput[]
  }

  export type EnrollmentCreateWithoutStudentInput = {
    id?: string
    academicYear: string
    enrollDate?: Date | string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    class: ClassCreateNestedOneWithoutEnrollmentsInput
  }

  export type EnrollmentUncheckedCreateWithoutStudentInput = {
    id?: string
    classId: string
    academicYear: string
    enrollDate?: Date | string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EnrollmentCreateOrConnectWithoutStudentInput = {
    where: EnrollmentWhereUniqueInput
    create: XOR<EnrollmentCreateWithoutStudentInput, EnrollmentUncheckedCreateWithoutStudentInput>
  }

  export type EnrollmentCreateManyStudentInputEnvelope = {
    data: EnrollmentCreateManyStudentInput | EnrollmentCreateManyStudentInput[]
  }

  export type AttendanceCreateWithoutStudentInput = {
    id?: string
    date: Date | string
    status: string
    remarks?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    class: ClassCreateNestedOneWithoutAttendancesInput
  }

  export type AttendanceUncheckedCreateWithoutStudentInput = {
    id?: string
    classId: string
    date: Date | string
    status: string
    remarks?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttendanceCreateOrConnectWithoutStudentInput = {
    where: AttendanceWhereUniqueInput
    create: XOR<AttendanceCreateWithoutStudentInput, AttendanceUncheckedCreateWithoutStudentInput>
  }

  export type AttendanceCreateManyStudentInputEnvelope = {
    data: AttendanceCreateManyStudentInput | AttendanceCreateManyStudentInput[]
  }

  export type GradeCreateWithoutStudentInput = {
    id?: string
    subject: string
    examType?: string | null
    score: number
    maxScore?: number
    grade?: string | null
    term: string
    academicYear: string
    remarks?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GradeUncheckedCreateWithoutStudentInput = {
    id?: string
    subject: string
    examType?: string | null
    score: number
    maxScore?: number
    grade?: string | null
    term: string
    academicYear: string
    remarks?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GradeCreateOrConnectWithoutStudentInput = {
    where: GradeWhereUniqueInput
    create: XOR<GradeCreateWithoutStudentInput, GradeUncheckedCreateWithoutStudentInput>
  }

  export type GradeCreateManyStudentInputEnvelope = {
    data: GradeCreateManyStudentInput | GradeCreateManyStudentInput[]
  }

  export type InvoiceCreateWithoutStudentInput = {
    id?: string
    invoiceNumber: string
    description?: string | null
    amount: number
    amountPaid?: number
    status: string
    dueDate?: Date | string | null
    paidDate?: Date | string | null
    paymentMethod?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    institution?: InstitutionCreateNestedOneWithoutInvoicesInput
  }

  export type InvoiceUncheckedCreateWithoutStudentInput = {
    id?: string
    institutionId: string
    invoiceNumber: string
    description?: string | null
    amount: number
    amountPaid?: number
    status: string
    dueDate?: Date | string | null
    paidDate?: Date | string | null
    paymentMethod?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceCreateOrConnectWithoutStudentInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutStudentInput, InvoiceUncheckedCreateWithoutStudentInput>
  }

  export type InvoiceCreateManyStudentInputEnvelope = {
    data: InvoiceCreateManyStudentInput | InvoiceCreateManyStudentInput[]
  }

  export type StudentDocumentUpsertWithWhereUniqueWithoutStudentInput = {
    where: StudentDocumentWhereUniqueInput
    update: XOR<StudentDocumentUpdateWithoutStudentInput, StudentDocumentUncheckedUpdateWithoutStudentInput>
    create: XOR<StudentDocumentCreateWithoutStudentInput, StudentDocumentUncheckedCreateWithoutStudentInput>
  }

  export type StudentDocumentUpdateWithWhereUniqueWithoutStudentInput = {
    where: StudentDocumentWhereUniqueInput
    data: XOR<StudentDocumentUpdateWithoutStudentInput, StudentDocumentUncheckedUpdateWithoutStudentInput>
  }

  export type StudentDocumentUpdateManyWithWhereWithoutStudentInput = {
    where: StudentDocumentScalarWhereInput
    data: XOR<StudentDocumentUpdateManyMutationInput, StudentDocumentUncheckedUpdateManyWithoutStudentInput>
  }

  export type StudentDocumentScalarWhereInput = {
    AND?: StudentDocumentScalarWhereInput | StudentDocumentScalarWhereInput[]
    OR?: StudentDocumentScalarWhereInput[]
    NOT?: StudentDocumentScalarWhereInput | StudentDocumentScalarWhereInput[]
    id?: StringFilter<"StudentDocument"> | string
    studentId?: StringNullableFilter<"StudentDocument"> | string | null
    documentType?: StringFilter<"StudentDocument"> | string
    documentName?: StringFilter<"StudentDocument"> | string
    documentUrl?: StringFilter<"StudentDocument"> | string
    fileSize?: IntNullableFilter<"StudentDocument"> | number | null
    mimeType?: StringNullableFilter<"StudentDocument"> | string | null
    uploadedAt?: DateTimeFilter<"StudentDocument"> | Date | string
    uploadedBy?: StringNullableFilter<"StudentDocument"> | string | null
    verified?: BoolFilter<"StudentDocument"> | boolean
    verifiedBy?: StringNullableFilter<"StudentDocument"> | string | null
    verifiedAt?: DateTimeNullableFilter<"StudentDocument"> | Date | string | null
  }

  export type UserUpsertWithoutStudentInput = {
    update: XOR<UserUpdateWithoutStudentInput, UserUncheckedUpdateWithoutStudentInput>
    create: XOR<UserCreateWithoutStudentInput, UserUncheckedCreateWithoutStudentInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutStudentInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutStudentInput, UserUncheckedUpdateWithoutStudentInput>
  }

  export type UserUpdateWithoutStudentInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastlogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teacher?: TeacherUpdateManyWithoutUserNestedInput
    parent?: UserToParentUpdateManyWithoutUserNestedInput
    institutions?: UsersOnInstitutionUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutFromUserNestedInput
  }

  export type UserUncheckedUpdateWithoutStudentInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastlogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teacher?: TeacherUncheckedUpdateManyWithoutUserNestedInput
    parent?: UserToParentUncheckedUpdateManyWithoutUserNestedInput
    institutions?: UsersOnInstitutionUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutFromUserNestedInput
  }

  export type InstitutionUpsertWithoutStudentsInput = {
    update: XOR<InstitutionUpdateWithoutStudentsInput, InstitutionUncheckedUpdateWithoutStudentsInput>
    create: XOR<InstitutionCreateWithoutStudentsInput, InstitutionUncheckedCreateWithoutStudentsInput>
    where?: InstitutionWhereInput
  }

  export type InstitutionUpdateToOneWithWhereWithoutStudentsInput = {
    where?: InstitutionWhereInput
    data: XOR<InstitutionUpdateWithoutStudentsInput, InstitutionUncheckedUpdateWithoutStudentsInput>
  }

  export type InstitutionUpdateWithoutStudentsInput = {
    name?: StringFieldUpdateOperationsInput | string
    institutionType?: EnumInstitutionTypeFieldUpdateOperationsInput | $Enums.InstitutionType
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: EnumInstitutionPlanFieldUpdateOperationsInput | $Enums.InstitutionPlan
    subscriptionStatus?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UsersOnInstitutionUpdateManyWithoutInstitutionNestedInput
    classes?: ClassUpdateManyWithoutInstitutionNestedInput
    teachers?: TeacherOnInstitutionUpdateManyWithoutInstitutionNestedInput
    invoices?: InvoiceUpdateManyWithoutInstitutionNestedInput
    messages?: MessageUpdateManyWithoutInstitutionNestedInput
  }

  export type InstitutionUncheckedUpdateWithoutStudentsInput = {
    name?: StringFieldUpdateOperationsInput | string
    institutionType?: EnumInstitutionTypeFieldUpdateOperationsInput | $Enums.InstitutionType
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: EnumInstitutionPlanFieldUpdateOperationsInput | $Enums.InstitutionPlan
    subscriptionStatus?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UsersOnInstitutionUncheckedUpdateManyWithoutInstitutionNestedInput
    classes?: ClassUncheckedUpdateManyWithoutInstitutionNestedInput
    teachers?: TeacherOnInstitutionUncheckedUpdateManyWithoutInstitutionNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutInstitutionNestedInput
    messages?: MessageUncheckedUpdateManyWithoutInstitutionNestedInput
  }

  export type ClassUpsertWithoutStudentsInput = {
    update: XOR<ClassUpdateWithoutStudentsInput, ClassUncheckedUpdateWithoutStudentsInput>
    create: XOR<ClassCreateWithoutStudentsInput, ClassUncheckedCreateWithoutStudentsInput>
    where?: ClassWhereInput
  }

  export type ClassUpdateToOneWithWhereWithoutStudentsInput = {
    where?: ClassWhereInput
    data: XOR<ClassUpdateWithoutStudentsInput, ClassUncheckedUpdateWithoutStudentsInput>
  }

  export type ClassUpdateWithoutStudentsInput = {
    name?: StringFieldUpdateOperationsInput | string
    section?: NullableStringFieldUpdateOperationsInput | string | null
    academicYear?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    roomNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teacherIds?: ClassUpdateteacherIdsInput | string[]
    institution?: InstitutionUpdateOneRequiredWithoutClassesNestedInput
    teachers?: TeacherOnClassUpdateManyWithoutClassNestedInput
    enrollments?: EnrollmentUpdateManyWithoutClassNestedInput
    attendances?: AttendanceUpdateManyWithoutClassNestedInput
    timetables?: TimetableUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateWithoutStudentsInput = {
    institutionId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    section?: NullableStringFieldUpdateOperationsInput | string | null
    academicYear?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    roomNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teacherIds?: ClassUpdateteacherIdsInput | string[]
    teachers?: TeacherOnClassUncheckedUpdateManyWithoutClassNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutClassNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutClassNestedInput
    timetables?: TimetableUncheckedUpdateManyWithoutClassNestedInput
  }

  export type ParentUpsertWithWhereUniqueWithoutStudentInput = {
    where: ParentWhereUniqueInput
    update: XOR<ParentUpdateWithoutStudentInput, ParentUncheckedUpdateWithoutStudentInput>
    create: XOR<ParentCreateWithoutStudentInput, ParentUncheckedCreateWithoutStudentInput>
  }

  export type ParentUpdateWithWhereUniqueWithoutStudentInput = {
    where: ParentWhereUniqueInput
    data: XOR<ParentUpdateWithoutStudentInput, ParentUncheckedUpdateWithoutStudentInput>
  }

  export type ParentUpdateManyWithWhereWithoutStudentInput = {
    where: ParentScalarWhereInput
    data: XOR<ParentUpdateManyMutationInput, ParentUncheckedUpdateManyWithoutStudentInput>
  }

  export type ParentScalarWhereInput = {
    AND?: ParentScalarWhereInput | ParentScalarWhereInput[]
    OR?: ParentScalarWhereInput[]
    NOT?: ParentScalarWhereInput | ParentScalarWhereInput[]
    id?: StringFilter<"Parent"> | string
    studentId?: StringNullableFilter<"Parent"> | string | null
    institutionId?: StringFilter<"Parent"> | string
    firstName?: StringFilter<"Parent"> | string
    middleName?: StringNullableFilter<"Parent"> | string | null
    lastName?: StringFilter<"Parent"> | string
    email?: StringFilter<"Parent"> | string
    phone?: StringFilter<"Parent"> | string
    occupation?: StringNullableFilter<"Parent"> | string | null
    relationship?: StringNullableFilter<"Parent"> | string | null
    address?: StringNullableFilter<"Parent"> | string | null
    isPrimaryContact?: BoolFilter<"Parent"> | boolean
    isEmergencyContact?: BoolFilter<"Parent"> | boolean
    preferredContactTime?: StringNullableFilter<"Parent"> | string | null
    createdAt?: DateTimeFilter<"Parent"> | Date | string
    updatedAt?: DateTimeFilter<"Parent"> | Date | string
  }

  export type EnrollmentUpsertWithWhereUniqueWithoutStudentInput = {
    where: EnrollmentWhereUniqueInput
    update: XOR<EnrollmentUpdateWithoutStudentInput, EnrollmentUncheckedUpdateWithoutStudentInput>
    create: XOR<EnrollmentCreateWithoutStudentInput, EnrollmentUncheckedCreateWithoutStudentInput>
  }

  export type EnrollmentUpdateWithWhereUniqueWithoutStudentInput = {
    where: EnrollmentWhereUniqueInput
    data: XOR<EnrollmentUpdateWithoutStudentInput, EnrollmentUncheckedUpdateWithoutStudentInput>
  }

  export type EnrollmentUpdateManyWithWhereWithoutStudentInput = {
    where: EnrollmentScalarWhereInput
    data: XOR<EnrollmentUpdateManyMutationInput, EnrollmentUncheckedUpdateManyWithoutStudentInput>
  }

  export type EnrollmentScalarWhereInput = {
    AND?: EnrollmentScalarWhereInput | EnrollmentScalarWhereInput[]
    OR?: EnrollmentScalarWhereInput[]
    NOT?: EnrollmentScalarWhereInput | EnrollmentScalarWhereInput[]
    id?: StringFilter<"Enrollment"> | string
    studentId?: StringFilter<"Enrollment"> | string
    classId?: StringFilter<"Enrollment"> | string
    academicYear?: StringFilter<"Enrollment"> | string
    enrollDate?: DateTimeFilter<"Enrollment"> | Date | string
    status?: StringFilter<"Enrollment"> | string
    createdAt?: DateTimeFilter<"Enrollment"> | Date | string
    updatedAt?: DateTimeFilter<"Enrollment"> | Date | string
  }

  export type AttendanceUpsertWithWhereUniqueWithoutStudentInput = {
    where: AttendanceWhereUniqueInput
    update: XOR<AttendanceUpdateWithoutStudentInput, AttendanceUncheckedUpdateWithoutStudentInput>
    create: XOR<AttendanceCreateWithoutStudentInput, AttendanceUncheckedCreateWithoutStudentInput>
  }

  export type AttendanceUpdateWithWhereUniqueWithoutStudentInput = {
    where: AttendanceWhereUniqueInput
    data: XOR<AttendanceUpdateWithoutStudentInput, AttendanceUncheckedUpdateWithoutStudentInput>
  }

  export type AttendanceUpdateManyWithWhereWithoutStudentInput = {
    where: AttendanceScalarWhereInput
    data: XOR<AttendanceUpdateManyMutationInput, AttendanceUncheckedUpdateManyWithoutStudentInput>
  }

  export type AttendanceScalarWhereInput = {
    AND?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
    OR?: AttendanceScalarWhereInput[]
    NOT?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
    id?: StringFilter<"Attendance"> | string
    studentId?: StringFilter<"Attendance"> | string
    classId?: StringFilter<"Attendance"> | string
    date?: DateTimeFilter<"Attendance"> | Date | string
    status?: StringFilter<"Attendance"> | string
    remarks?: StringNullableFilter<"Attendance"> | string | null
    createdAt?: DateTimeFilter<"Attendance"> | Date | string
    updatedAt?: DateTimeFilter<"Attendance"> | Date | string
  }

  export type GradeUpsertWithWhereUniqueWithoutStudentInput = {
    where: GradeWhereUniqueInput
    update: XOR<GradeUpdateWithoutStudentInput, GradeUncheckedUpdateWithoutStudentInput>
    create: XOR<GradeCreateWithoutStudentInput, GradeUncheckedCreateWithoutStudentInput>
  }

  export type GradeUpdateWithWhereUniqueWithoutStudentInput = {
    where: GradeWhereUniqueInput
    data: XOR<GradeUpdateWithoutStudentInput, GradeUncheckedUpdateWithoutStudentInput>
  }

  export type GradeUpdateManyWithWhereWithoutStudentInput = {
    where: GradeScalarWhereInput
    data: XOR<GradeUpdateManyMutationInput, GradeUncheckedUpdateManyWithoutStudentInput>
  }

  export type GradeScalarWhereInput = {
    AND?: GradeScalarWhereInput | GradeScalarWhereInput[]
    OR?: GradeScalarWhereInput[]
    NOT?: GradeScalarWhereInput | GradeScalarWhereInput[]
    id?: StringFilter<"Grade"> | string
    studentId?: StringFilter<"Grade"> | string
    subject?: StringFilter<"Grade"> | string
    examType?: StringNullableFilter<"Grade"> | string | null
    score?: FloatFilter<"Grade"> | number
    maxScore?: FloatFilter<"Grade"> | number
    grade?: StringNullableFilter<"Grade"> | string | null
    term?: StringFilter<"Grade"> | string
    academicYear?: StringFilter<"Grade"> | string
    remarks?: StringNullableFilter<"Grade"> | string | null
    createdAt?: DateTimeFilter<"Grade"> | Date | string
    updatedAt?: DateTimeFilter<"Grade"> | Date | string
  }

  export type InvoiceUpsertWithWhereUniqueWithoutStudentInput = {
    where: InvoiceWhereUniqueInput
    update: XOR<InvoiceUpdateWithoutStudentInput, InvoiceUncheckedUpdateWithoutStudentInput>
    create: XOR<InvoiceCreateWithoutStudentInput, InvoiceUncheckedCreateWithoutStudentInput>
  }

  export type InvoiceUpdateWithWhereUniqueWithoutStudentInput = {
    where: InvoiceWhereUniqueInput
    data: XOR<InvoiceUpdateWithoutStudentInput, InvoiceUncheckedUpdateWithoutStudentInput>
  }

  export type InvoiceUpdateManyWithWhereWithoutStudentInput = {
    where: InvoiceScalarWhereInput
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyWithoutStudentInput>
  }

  export type UserCreateWithoutParentInput = {
    id?: string
    firstName: string
    middleName?: string | null
    lastName: string
    dateOfBirth: Date | string
    role: $Enums.Role
    email: string
    password: string
    avatar?: string | null
    phone?: string | null
    isActive?: boolean
    lastlogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    student?: StudentCreateNestedManyWithoutUserInput
    teacher?: TeacherCreateNestedManyWithoutUserInput
    institutions?: UsersOnInstitutionCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutFromUserInput
  }

  export type UserUncheckedCreateWithoutParentInput = {
    id?: string
    firstName: string
    middleName?: string | null
    lastName: string
    dateOfBirth: Date | string
    role: $Enums.Role
    email: string
    password: string
    avatar?: string | null
    phone?: string | null
    isActive?: boolean
    lastlogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    student?: StudentUncheckedCreateNestedManyWithoutUserInput
    teacher?: TeacherUncheckedCreateNestedManyWithoutUserInput
    institutions?: UsersOnInstitutionUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutFromUserInput
  }

  export type UserCreateOrConnectWithoutParentInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutParentInput, UserUncheckedCreateWithoutParentInput>
  }

  export type ParentCreateWithoutUserInput = {
    id?: string
    institutionId: string
    firstName: string
    middleName?: string | null
    lastName: string
    email: string
    phone: string
    occupation?: string | null
    relationship?: string | null
    address?: string | null
    isPrimaryContact?: boolean
    isEmergencyContact?: boolean
    preferredContactTime?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    student?: StudentCreateNestedOneWithoutParentsInput
  }

  export type ParentUncheckedCreateWithoutUserInput = {
    id?: string
    studentId?: string | null
    institutionId: string
    firstName: string
    middleName?: string | null
    lastName: string
    email: string
    phone: string
    occupation?: string | null
    relationship?: string | null
    address?: string | null
    isPrimaryContact?: boolean
    isEmergencyContact?: boolean
    preferredContactTime?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ParentCreateOrConnectWithoutUserInput = {
    where: ParentWhereUniqueInput
    create: XOR<ParentCreateWithoutUserInput, ParentUncheckedCreateWithoutUserInput>
  }

  export type UserUpsertWithoutParentInput = {
    update: XOR<UserUpdateWithoutParentInput, UserUncheckedUpdateWithoutParentInput>
    create: XOR<UserCreateWithoutParentInput, UserUncheckedCreateWithoutParentInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutParentInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutParentInput, UserUncheckedUpdateWithoutParentInput>
  }

  export type UserUpdateWithoutParentInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastlogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateManyWithoutUserNestedInput
    teacher?: TeacherUpdateManyWithoutUserNestedInput
    institutions?: UsersOnInstitutionUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutFromUserNestedInput
  }

  export type UserUncheckedUpdateWithoutParentInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastlogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUncheckedUpdateManyWithoutUserNestedInput
    teacher?: TeacherUncheckedUpdateManyWithoutUserNestedInput
    institutions?: UsersOnInstitutionUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutFromUserNestedInput
  }

  export type ParentUpsertWithoutUserInput = {
    update: XOR<ParentUpdateWithoutUserInput, ParentUncheckedUpdateWithoutUserInput>
    create: XOR<ParentCreateWithoutUserInput, ParentUncheckedCreateWithoutUserInput>
    where?: ParentWhereInput
  }

  export type ParentUpdateToOneWithWhereWithoutUserInput = {
    where?: ParentWhereInput
    data: XOR<ParentUpdateWithoutUserInput, ParentUncheckedUpdateWithoutUserInput>
  }

  export type ParentUpdateWithoutUserInput = {
    institutionId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    relationship?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isPrimaryContact?: BoolFieldUpdateOperationsInput | boolean
    isEmergencyContact?: BoolFieldUpdateOperationsInput | boolean
    preferredContactTime?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneWithoutParentsNestedInput
  }

  export type ParentUncheckedUpdateWithoutUserInput = {
    studentId?: NullableStringFieldUpdateOperationsInput | string | null
    institutionId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    relationship?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isPrimaryContact?: BoolFieldUpdateOperationsInput | boolean
    isEmergencyContact?: BoolFieldUpdateOperationsInput | boolean
    preferredContactTime?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentCreateWithoutParentsInput = {
    id?: string
    firstName: string
    middleName?: string | null
    lastName: string
    admissionNumber?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    bloodGroup?: string | null
    address?: string | null
    gradeApplying?: string | null
    academicYear?: string | null
    phone?: string | null
    email?: string | null
    guardians?: InputJsonValue | null
    fingerprintEnrolled?: boolean
    fingerprintData?: InputJsonValue | null
    faceData?: InputJsonValue | null
    documents?: InputJsonValue | null
    photo?: string | null
    emergencyContacts?: InputJsonValue | null
    medicalConditions?: string | null
    allergies?: string | null
    medications?: string | null
    previousSchool?: string | null
    previousGrade?: string | null
    transferReason?: string | null
    enrollmentStatus?: string
    enrollmentDate?: Date | string | null
    nationality?: string | null
    religion?: string | null
    languagesSpoken?: StudentCreatelanguagesSpokenInput | string[]
    specialNeeds?: string | null
    transportRequired?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    parentIds?: StudentCreateparentIdsInput | string[]
    StudentDocument?: StudentDocumentCreateNestedManyWithoutStudentInput
    user?: UserCreateNestedOneWithoutStudentInput
    institution: InstitutionCreateNestedOneWithoutStudentsInput
    class?: ClassCreateNestedOneWithoutStudentsInput
    enrollments?: EnrollmentCreateNestedManyWithoutStudentInput
    attendances?: AttendanceCreateNestedManyWithoutStudentInput
    grades?: GradeCreateNestedManyWithoutStudentInput
    invoices?: InvoiceCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutParentsInput = {
    id?: string
    userId?: string | null
    institutionId: string
    firstName: string
    middleName?: string | null
    lastName: string
    admissionNumber?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    bloodGroup?: string | null
    address?: string | null
    gradeApplying?: string | null
    academicYear?: string | null
    classId?: string | null
    phone?: string | null
    email?: string | null
    guardians?: InputJsonValue | null
    fingerprintEnrolled?: boolean
    fingerprintData?: InputJsonValue | null
    faceData?: InputJsonValue | null
    documents?: InputJsonValue | null
    photo?: string | null
    emergencyContacts?: InputJsonValue | null
    medicalConditions?: string | null
    allergies?: string | null
    medications?: string | null
    previousSchool?: string | null
    previousGrade?: string | null
    transferReason?: string | null
    enrollmentStatus?: string
    enrollmentDate?: Date | string | null
    nationality?: string | null
    religion?: string | null
    languagesSpoken?: StudentCreatelanguagesSpokenInput | string[]
    specialNeeds?: string | null
    transportRequired?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    parentIds?: StudentCreateparentIdsInput | string[]
    StudentDocument?: StudentDocumentUncheckedCreateNestedManyWithoutStudentInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutStudentInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutStudentInput
    grades?: GradeUncheckedCreateNestedManyWithoutStudentInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutParentsInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutParentsInput, StudentUncheckedCreateWithoutParentsInput>
  }

  export type UserToParentCreateWithoutParentInput = {
    id?: string
    user: UserCreateNestedOneWithoutParentInput
  }

  export type UserToParentUncheckedCreateWithoutParentInput = {
    id?: string
    userId: string
  }

  export type UserToParentCreateOrConnectWithoutParentInput = {
    where: UserToParentWhereUniqueInput
    create: XOR<UserToParentCreateWithoutParentInput, UserToParentUncheckedCreateWithoutParentInput>
  }

  export type UserToParentCreateManyParentInputEnvelope = {
    data: UserToParentCreateManyParentInput | UserToParentCreateManyParentInput[]
  }

  export type StudentUpsertWithoutParentsInput = {
    update: XOR<StudentUpdateWithoutParentsInput, StudentUncheckedUpdateWithoutParentsInput>
    create: XOR<StudentCreateWithoutParentsInput, StudentUncheckedCreateWithoutParentsInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutParentsInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutParentsInput, StudentUncheckedUpdateWithoutParentsInput>
  }

  export type StudentUpdateWithoutParentsInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    admissionNumber?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gradeApplying?: NullableStringFieldUpdateOperationsInput | string | null
    academicYear?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    guardians?: InputJsonValue | InputJsonValue | null
    fingerprintEnrolled?: BoolFieldUpdateOperationsInput | boolean
    fingerprintData?: InputJsonValue | InputJsonValue | null
    faceData?: InputJsonValue | InputJsonValue | null
    documents?: InputJsonValue | InputJsonValue | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContacts?: InputJsonValue | InputJsonValue | null
    medicalConditions?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    medications?: NullableStringFieldUpdateOperationsInput | string | null
    previousSchool?: NullableStringFieldUpdateOperationsInput | string | null
    previousGrade?: NullableStringFieldUpdateOperationsInput | string | null
    transferReason?: NullableStringFieldUpdateOperationsInput | string | null
    enrollmentStatus?: StringFieldUpdateOperationsInput | string
    enrollmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    languagesSpoken?: StudentUpdatelanguagesSpokenInput | string[]
    specialNeeds?: NullableStringFieldUpdateOperationsInput | string | null
    transportRequired?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentIds?: StudentUpdateparentIdsInput | string[]
    StudentDocument?: StudentDocumentUpdateManyWithoutStudentNestedInput
    user?: UserUpdateOneWithoutStudentNestedInput
    institution?: InstitutionUpdateOneRequiredWithoutStudentsNestedInput
    class?: ClassUpdateOneWithoutStudentsNestedInput
    enrollments?: EnrollmentUpdateManyWithoutStudentNestedInput
    attendances?: AttendanceUpdateManyWithoutStudentNestedInput
    grades?: GradeUpdateManyWithoutStudentNestedInput
    invoices?: InvoiceUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutParentsInput = {
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    institutionId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    admissionNumber?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gradeApplying?: NullableStringFieldUpdateOperationsInput | string | null
    academicYear?: NullableStringFieldUpdateOperationsInput | string | null
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    guardians?: InputJsonValue | InputJsonValue | null
    fingerprintEnrolled?: BoolFieldUpdateOperationsInput | boolean
    fingerprintData?: InputJsonValue | InputJsonValue | null
    faceData?: InputJsonValue | InputJsonValue | null
    documents?: InputJsonValue | InputJsonValue | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContacts?: InputJsonValue | InputJsonValue | null
    medicalConditions?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    medications?: NullableStringFieldUpdateOperationsInput | string | null
    previousSchool?: NullableStringFieldUpdateOperationsInput | string | null
    previousGrade?: NullableStringFieldUpdateOperationsInput | string | null
    transferReason?: NullableStringFieldUpdateOperationsInput | string | null
    enrollmentStatus?: StringFieldUpdateOperationsInput | string
    enrollmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    languagesSpoken?: StudentUpdatelanguagesSpokenInput | string[]
    specialNeeds?: NullableStringFieldUpdateOperationsInput | string | null
    transportRequired?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentIds?: StudentUpdateparentIdsInput | string[]
    StudentDocument?: StudentDocumentUncheckedUpdateManyWithoutStudentNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutStudentNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutStudentNestedInput
    grades?: GradeUncheckedUpdateManyWithoutStudentNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type UserToParentUpsertWithWhereUniqueWithoutParentInput = {
    where: UserToParentWhereUniqueInput
    update: XOR<UserToParentUpdateWithoutParentInput, UserToParentUncheckedUpdateWithoutParentInput>
    create: XOR<UserToParentCreateWithoutParentInput, UserToParentUncheckedCreateWithoutParentInput>
  }

  export type UserToParentUpdateWithWhereUniqueWithoutParentInput = {
    where: UserToParentWhereUniqueInput
    data: XOR<UserToParentUpdateWithoutParentInput, UserToParentUncheckedUpdateWithoutParentInput>
  }

  export type UserToParentUpdateManyWithWhereWithoutParentInput = {
    where: UserToParentScalarWhereInput
    data: XOR<UserToParentUpdateManyMutationInput, UserToParentUncheckedUpdateManyWithoutParentInput>
  }

  export type StudentCreateWithoutStudentDocumentInput = {
    id?: string
    firstName: string
    middleName?: string | null
    lastName: string
    admissionNumber?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    bloodGroup?: string | null
    address?: string | null
    gradeApplying?: string | null
    academicYear?: string | null
    phone?: string | null
    email?: string | null
    guardians?: InputJsonValue | null
    fingerprintEnrolled?: boolean
    fingerprintData?: InputJsonValue | null
    faceData?: InputJsonValue | null
    documents?: InputJsonValue | null
    photo?: string | null
    emergencyContacts?: InputJsonValue | null
    medicalConditions?: string | null
    allergies?: string | null
    medications?: string | null
    previousSchool?: string | null
    previousGrade?: string | null
    transferReason?: string | null
    enrollmentStatus?: string
    enrollmentDate?: Date | string | null
    nationality?: string | null
    religion?: string | null
    languagesSpoken?: StudentCreatelanguagesSpokenInput | string[]
    specialNeeds?: string | null
    transportRequired?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    parentIds?: StudentCreateparentIdsInput | string[]
    user?: UserCreateNestedOneWithoutStudentInput
    institution: InstitutionCreateNestedOneWithoutStudentsInput
    class?: ClassCreateNestedOneWithoutStudentsInput
    parents?: ParentCreateNestedManyWithoutStudentInput
    enrollments?: EnrollmentCreateNestedManyWithoutStudentInput
    attendances?: AttendanceCreateNestedManyWithoutStudentInput
    grades?: GradeCreateNestedManyWithoutStudentInput
    invoices?: InvoiceCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutStudentDocumentInput = {
    id?: string
    userId?: string | null
    institutionId: string
    firstName: string
    middleName?: string | null
    lastName: string
    admissionNumber?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    bloodGroup?: string | null
    address?: string | null
    gradeApplying?: string | null
    academicYear?: string | null
    classId?: string | null
    phone?: string | null
    email?: string | null
    guardians?: InputJsonValue | null
    fingerprintEnrolled?: boolean
    fingerprintData?: InputJsonValue | null
    faceData?: InputJsonValue | null
    documents?: InputJsonValue | null
    photo?: string | null
    emergencyContacts?: InputJsonValue | null
    medicalConditions?: string | null
    allergies?: string | null
    medications?: string | null
    previousSchool?: string | null
    previousGrade?: string | null
    transferReason?: string | null
    enrollmentStatus?: string
    enrollmentDate?: Date | string | null
    nationality?: string | null
    religion?: string | null
    languagesSpoken?: StudentCreatelanguagesSpokenInput | string[]
    specialNeeds?: string | null
    transportRequired?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    parentIds?: StudentCreateparentIdsInput | string[]
    parents?: ParentUncheckedCreateNestedManyWithoutStudentInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutStudentInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutStudentInput
    grades?: GradeUncheckedCreateNestedManyWithoutStudentInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutStudentDocumentInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutStudentDocumentInput, StudentUncheckedCreateWithoutStudentDocumentInput>
  }

  export type StudentUpsertWithoutStudentDocumentInput = {
    update: XOR<StudentUpdateWithoutStudentDocumentInput, StudentUncheckedUpdateWithoutStudentDocumentInput>
    create: XOR<StudentCreateWithoutStudentDocumentInput, StudentUncheckedCreateWithoutStudentDocumentInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutStudentDocumentInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutStudentDocumentInput, StudentUncheckedUpdateWithoutStudentDocumentInput>
  }

  export type StudentUpdateWithoutStudentDocumentInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    admissionNumber?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gradeApplying?: NullableStringFieldUpdateOperationsInput | string | null
    academicYear?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    guardians?: InputJsonValue | InputJsonValue | null
    fingerprintEnrolled?: BoolFieldUpdateOperationsInput | boolean
    fingerprintData?: InputJsonValue | InputJsonValue | null
    faceData?: InputJsonValue | InputJsonValue | null
    documents?: InputJsonValue | InputJsonValue | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContacts?: InputJsonValue | InputJsonValue | null
    medicalConditions?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    medications?: NullableStringFieldUpdateOperationsInput | string | null
    previousSchool?: NullableStringFieldUpdateOperationsInput | string | null
    previousGrade?: NullableStringFieldUpdateOperationsInput | string | null
    transferReason?: NullableStringFieldUpdateOperationsInput | string | null
    enrollmentStatus?: StringFieldUpdateOperationsInput | string
    enrollmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    languagesSpoken?: StudentUpdatelanguagesSpokenInput | string[]
    specialNeeds?: NullableStringFieldUpdateOperationsInput | string | null
    transportRequired?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentIds?: StudentUpdateparentIdsInput | string[]
    user?: UserUpdateOneWithoutStudentNestedInput
    institution?: InstitutionUpdateOneRequiredWithoutStudentsNestedInput
    class?: ClassUpdateOneWithoutStudentsNestedInput
    parents?: ParentUpdateManyWithoutStudentNestedInput
    enrollments?: EnrollmentUpdateManyWithoutStudentNestedInput
    attendances?: AttendanceUpdateManyWithoutStudentNestedInput
    grades?: GradeUpdateManyWithoutStudentNestedInput
    invoices?: InvoiceUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutStudentDocumentInput = {
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    institutionId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    admissionNumber?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gradeApplying?: NullableStringFieldUpdateOperationsInput | string | null
    academicYear?: NullableStringFieldUpdateOperationsInput | string | null
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    guardians?: InputJsonValue | InputJsonValue | null
    fingerprintEnrolled?: BoolFieldUpdateOperationsInput | boolean
    fingerprintData?: InputJsonValue | InputJsonValue | null
    faceData?: InputJsonValue | InputJsonValue | null
    documents?: InputJsonValue | InputJsonValue | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContacts?: InputJsonValue | InputJsonValue | null
    medicalConditions?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    medications?: NullableStringFieldUpdateOperationsInput | string | null
    previousSchool?: NullableStringFieldUpdateOperationsInput | string | null
    previousGrade?: NullableStringFieldUpdateOperationsInput | string | null
    transferReason?: NullableStringFieldUpdateOperationsInput | string | null
    enrollmentStatus?: StringFieldUpdateOperationsInput | string
    enrollmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    languagesSpoken?: StudentUpdatelanguagesSpokenInput | string[]
    specialNeeds?: NullableStringFieldUpdateOperationsInput | string | null
    transportRequired?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentIds?: StudentUpdateparentIdsInput | string[]
    parents?: ParentUncheckedUpdateManyWithoutStudentNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutStudentNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutStudentNestedInput
    grades?: GradeUncheckedUpdateManyWithoutStudentNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type TeacherCreateWithoutInstitutionInput = {
    id?: string
    firstName: string
    middleName?: string | null
    lastName: string
    email?: string | null
    phone: string
    avatar?: string | null
    employeeNumber?: string | null
    subjects?: TeacherCreatesubjectsInput | string[]
    qualification?: string | null
    experience?: number | null
    salary?: number | null
    joinDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutTeacherInput
    classes?: TeacherOnClassCreateNestedManyWithoutTeacherInput
  }

  export type TeacherUncheckedCreateWithoutInstitutionInput = {
    id?: string
    userId?: string | null
    firstName: string
    middleName?: string | null
    lastName: string
    email?: string | null
    phone: string
    avatar?: string | null
    employeeNumber?: string | null
    subjects?: TeacherCreatesubjectsInput | string[]
    qualification?: string | null
    experience?: number | null
    salary?: number | null
    joinDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    classes?: TeacherOnClassUncheckedCreateNestedManyWithoutTeacherInput
  }

  export type TeacherCreateOrConnectWithoutInstitutionInput = {
    where: TeacherWhereUniqueInput
    create: XOR<TeacherCreateWithoutInstitutionInput, TeacherUncheckedCreateWithoutInstitutionInput>
  }

  export type InstitutionCreateWithoutTeachersInput = {
    id?: string
    name: string
    institutionType?: $Enums.InstitutionType
    address: string
    city: string
    state: string
    country: string
    phone: string
    email: string
    website?: string | null
    plan?: $Enums.InstitutionPlan
    subscriptionStatus?: $Enums.SubscriptionStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UsersOnInstitutionCreateNestedManyWithoutInstitutionInput
    classes?: ClassCreateNestedManyWithoutInstitutionInput
    students?: StudentCreateNestedManyWithoutInstitutionInput
    invoices?: InvoiceCreateNestedManyWithoutInstitutionInput
    messages?: MessageCreateNestedManyWithoutInstitutionInput
  }

  export type InstitutionUncheckedCreateWithoutTeachersInput = {
    id?: string
    name: string
    institutionType?: $Enums.InstitutionType
    address: string
    city: string
    state: string
    country: string
    phone: string
    email: string
    website?: string | null
    plan?: $Enums.InstitutionPlan
    subscriptionStatus?: $Enums.SubscriptionStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UsersOnInstitutionUncheckedCreateNestedManyWithoutInstitutionInput
    classes?: ClassUncheckedCreateNestedManyWithoutInstitutionInput
    students?: StudentUncheckedCreateNestedManyWithoutInstitutionInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutInstitutionInput
    messages?: MessageUncheckedCreateNestedManyWithoutInstitutionInput
  }

  export type InstitutionCreateOrConnectWithoutTeachersInput = {
    where: InstitutionWhereUniqueInput
    create: XOR<InstitutionCreateWithoutTeachersInput, InstitutionUncheckedCreateWithoutTeachersInput>
  }

  export type TeacherUpsertWithoutInstitutionInput = {
    update: XOR<TeacherUpdateWithoutInstitutionInput, TeacherUncheckedUpdateWithoutInstitutionInput>
    create: XOR<TeacherCreateWithoutInstitutionInput, TeacherUncheckedCreateWithoutInstitutionInput>
    where?: TeacherWhereInput
  }

  export type TeacherUpdateToOneWithWhereWithoutInstitutionInput = {
    where?: TeacherWhereInput
    data: XOR<TeacherUpdateWithoutInstitutionInput, TeacherUncheckedUpdateWithoutInstitutionInput>
  }

  export type TeacherUpdateWithoutInstitutionInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    employeeNumber?: NullableStringFieldUpdateOperationsInput | string | null
    subjects?: TeacherUpdatesubjectsInput | string[]
    qualification?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    joinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutTeacherNestedInput
    classes?: TeacherOnClassUpdateManyWithoutTeacherNestedInput
  }

  export type TeacherUncheckedUpdateWithoutInstitutionInput = {
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    employeeNumber?: NullableStringFieldUpdateOperationsInput | string | null
    subjects?: TeacherUpdatesubjectsInput | string[]
    qualification?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    joinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classes?: TeacherOnClassUncheckedUpdateManyWithoutTeacherNestedInput
  }

  export type InstitutionUpsertWithoutTeachersInput = {
    update: XOR<InstitutionUpdateWithoutTeachersInput, InstitutionUncheckedUpdateWithoutTeachersInput>
    create: XOR<InstitutionCreateWithoutTeachersInput, InstitutionUncheckedCreateWithoutTeachersInput>
    where?: InstitutionWhereInput
  }

  export type InstitutionUpdateToOneWithWhereWithoutTeachersInput = {
    where?: InstitutionWhereInput
    data: XOR<InstitutionUpdateWithoutTeachersInput, InstitutionUncheckedUpdateWithoutTeachersInput>
  }

  export type InstitutionUpdateWithoutTeachersInput = {
    name?: StringFieldUpdateOperationsInput | string
    institutionType?: EnumInstitutionTypeFieldUpdateOperationsInput | $Enums.InstitutionType
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: EnumInstitutionPlanFieldUpdateOperationsInput | $Enums.InstitutionPlan
    subscriptionStatus?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UsersOnInstitutionUpdateManyWithoutInstitutionNestedInput
    classes?: ClassUpdateManyWithoutInstitutionNestedInput
    students?: StudentUpdateManyWithoutInstitutionNestedInput
    invoices?: InvoiceUpdateManyWithoutInstitutionNestedInput
    messages?: MessageUpdateManyWithoutInstitutionNestedInput
  }

  export type InstitutionUncheckedUpdateWithoutTeachersInput = {
    name?: StringFieldUpdateOperationsInput | string
    institutionType?: EnumInstitutionTypeFieldUpdateOperationsInput | $Enums.InstitutionType
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: EnumInstitutionPlanFieldUpdateOperationsInput | $Enums.InstitutionPlan
    subscriptionStatus?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UsersOnInstitutionUncheckedUpdateManyWithoutInstitutionNestedInput
    classes?: ClassUncheckedUpdateManyWithoutInstitutionNestedInput
    students?: StudentUncheckedUpdateManyWithoutInstitutionNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutInstitutionNestedInput
    messages?: MessageUncheckedUpdateManyWithoutInstitutionNestedInput
  }

  export type UserCreateWithoutTeacherInput = {
    id?: string
    firstName: string
    middleName?: string | null
    lastName: string
    dateOfBirth: Date | string
    role: $Enums.Role
    email: string
    password: string
    avatar?: string | null
    phone?: string | null
    isActive?: boolean
    lastlogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    student?: StudentCreateNestedManyWithoutUserInput
    parent?: UserToParentCreateNestedManyWithoutUserInput
    institutions?: UsersOnInstitutionCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutFromUserInput
  }

  export type UserUncheckedCreateWithoutTeacherInput = {
    id?: string
    firstName: string
    middleName?: string | null
    lastName: string
    dateOfBirth: Date | string
    role: $Enums.Role
    email: string
    password: string
    avatar?: string | null
    phone?: string | null
    isActive?: boolean
    lastlogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    student?: StudentUncheckedCreateNestedManyWithoutUserInput
    parent?: UserToParentUncheckedCreateNestedManyWithoutUserInput
    institutions?: UsersOnInstitutionUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutFromUserInput
  }

  export type UserCreateOrConnectWithoutTeacherInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTeacherInput, UserUncheckedCreateWithoutTeacherInput>
  }

  export type TeacherOnInstitutionCreateWithoutTeacherInput = {
    id?: string
    institution: InstitutionCreateNestedOneWithoutTeachersInput
  }

  export type TeacherOnInstitutionUncheckedCreateWithoutTeacherInput = {
    id?: string
    institutionId: string
  }

  export type TeacherOnInstitutionCreateOrConnectWithoutTeacherInput = {
    where: TeacherOnInstitutionWhereUniqueInput
    create: XOR<TeacherOnInstitutionCreateWithoutTeacherInput, TeacherOnInstitutionUncheckedCreateWithoutTeacherInput>
  }

  export type TeacherOnInstitutionCreateManyTeacherInputEnvelope = {
    data: TeacherOnInstitutionCreateManyTeacherInput | TeacherOnInstitutionCreateManyTeacherInput[]
  }

  export type TeacherOnClassCreateWithoutTeacherInput = {
    id?: string
    class: ClassCreateNestedOneWithoutTeachersInput
  }

  export type TeacherOnClassUncheckedCreateWithoutTeacherInput = {
    id?: string
    classId: string
  }

  export type TeacherOnClassCreateOrConnectWithoutTeacherInput = {
    where: TeacherOnClassWhereUniqueInput
    create: XOR<TeacherOnClassCreateWithoutTeacherInput, TeacherOnClassUncheckedCreateWithoutTeacherInput>
  }

  export type TeacherOnClassCreateManyTeacherInputEnvelope = {
    data: TeacherOnClassCreateManyTeacherInput | TeacherOnClassCreateManyTeacherInput[]
  }

  export type UserUpsertWithoutTeacherInput = {
    update: XOR<UserUpdateWithoutTeacherInput, UserUncheckedUpdateWithoutTeacherInput>
    create: XOR<UserCreateWithoutTeacherInput, UserUncheckedCreateWithoutTeacherInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTeacherInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTeacherInput, UserUncheckedUpdateWithoutTeacherInput>
  }

  export type UserUpdateWithoutTeacherInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastlogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateManyWithoutUserNestedInput
    parent?: UserToParentUpdateManyWithoutUserNestedInput
    institutions?: UsersOnInstitutionUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutFromUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTeacherInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastlogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUncheckedUpdateManyWithoutUserNestedInput
    parent?: UserToParentUncheckedUpdateManyWithoutUserNestedInput
    institutions?: UsersOnInstitutionUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutFromUserNestedInput
  }

  export type TeacherOnInstitutionUpsertWithWhereUniqueWithoutTeacherInput = {
    where: TeacherOnInstitutionWhereUniqueInput
    update: XOR<TeacherOnInstitutionUpdateWithoutTeacherInput, TeacherOnInstitutionUncheckedUpdateWithoutTeacherInput>
    create: XOR<TeacherOnInstitutionCreateWithoutTeacherInput, TeacherOnInstitutionUncheckedCreateWithoutTeacherInput>
  }

  export type TeacherOnInstitutionUpdateWithWhereUniqueWithoutTeacherInput = {
    where: TeacherOnInstitutionWhereUniqueInput
    data: XOR<TeacherOnInstitutionUpdateWithoutTeacherInput, TeacherOnInstitutionUncheckedUpdateWithoutTeacherInput>
  }

  export type TeacherOnInstitutionUpdateManyWithWhereWithoutTeacherInput = {
    where: TeacherOnInstitutionScalarWhereInput
    data: XOR<TeacherOnInstitutionUpdateManyMutationInput, TeacherOnInstitutionUncheckedUpdateManyWithoutTeacherInput>
  }

  export type TeacherOnClassUpsertWithWhereUniqueWithoutTeacherInput = {
    where: TeacherOnClassWhereUniqueInput
    update: XOR<TeacherOnClassUpdateWithoutTeacherInput, TeacherOnClassUncheckedUpdateWithoutTeacherInput>
    create: XOR<TeacherOnClassCreateWithoutTeacherInput, TeacherOnClassUncheckedCreateWithoutTeacherInput>
  }

  export type TeacherOnClassUpdateWithWhereUniqueWithoutTeacherInput = {
    where: TeacherOnClassWhereUniqueInput
    data: XOR<TeacherOnClassUpdateWithoutTeacherInput, TeacherOnClassUncheckedUpdateWithoutTeacherInput>
  }

  export type TeacherOnClassUpdateManyWithWhereWithoutTeacherInput = {
    where: TeacherOnClassScalarWhereInput
    data: XOR<TeacherOnClassUpdateManyMutationInput, TeacherOnClassUncheckedUpdateManyWithoutTeacherInput>
  }

  export type TeacherOnClassScalarWhereInput = {
    AND?: TeacherOnClassScalarWhereInput | TeacherOnClassScalarWhereInput[]
    OR?: TeacherOnClassScalarWhereInput[]
    NOT?: TeacherOnClassScalarWhereInput | TeacherOnClassScalarWhereInput[]
    id?: StringFilter<"TeacherOnClass"> | string
    teacherId?: StringFilter<"TeacherOnClass"> | string
    classId?: StringFilter<"TeacherOnClass"> | string
  }

  export type TeacherCreateWithoutClassesInput = {
    id?: string
    firstName: string
    middleName?: string | null
    lastName: string
    email?: string | null
    phone: string
    avatar?: string | null
    employeeNumber?: string | null
    subjects?: TeacherCreatesubjectsInput | string[]
    qualification?: string | null
    experience?: number | null
    salary?: number | null
    joinDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutTeacherInput
    institution?: TeacherOnInstitutionCreateNestedManyWithoutTeacherInput
  }

  export type TeacherUncheckedCreateWithoutClassesInput = {
    id?: string
    userId?: string | null
    firstName: string
    middleName?: string | null
    lastName: string
    email?: string | null
    phone: string
    avatar?: string | null
    employeeNumber?: string | null
    subjects?: TeacherCreatesubjectsInput | string[]
    qualification?: string | null
    experience?: number | null
    salary?: number | null
    joinDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    institution?: TeacherOnInstitutionUncheckedCreateNestedManyWithoutTeacherInput
  }

  export type TeacherCreateOrConnectWithoutClassesInput = {
    where: TeacherWhereUniqueInput
    create: XOR<TeacherCreateWithoutClassesInput, TeacherUncheckedCreateWithoutClassesInput>
  }

  export type ClassCreateWithoutTeachersInput = {
    id?: string
    name: string
    section?: string | null
    academicYear?: string | null
    capacity?: number | null
    roomNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    teacherIds?: ClassCreateteacherIdsInput | string[]
    institution: InstitutionCreateNestedOneWithoutClassesInput
    students?: StudentCreateNestedManyWithoutClassInput
    enrollments?: EnrollmentCreateNestedManyWithoutClassInput
    attendances?: AttendanceCreateNestedManyWithoutClassInput
    timetables?: TimetableCreateNestedManyWithoutClassInput
  }

  export type ClassUncheckedCreateWithoutTeachersInput = {
    id?: string
    institutionId: string
    name: string
    section?: string | null
    academicYear?: string | null
    capacity?: number | null
    roomNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    teacherIds?: ClassCreateteacherIdsInput | string[]
    students?: StudentUncheckedCreateNestedManyWithoutClassInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutClassInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutClassInput
    timetables?: TimetableUncheckedCreateNestedManyWithoutClassInput
  }

  export type ClassCreateOrConnectWithoutTeachersInput = {
    where: ClassWhereUniqueInput
    create: XOR<ClassCreateWithoutTeachersInput, ClassUncheckedCreateWithoutTeachersInput>
  }

  export type TeacherUpsertWithoutClassesInput = {
    update: XOR<TeacherUpdateWithoutClassesInput, TeacherUncheckedUpdateWithoutClassesInput>
    create: XOR<TeacherCreateWithoutClassesInput, TeacherUncheckedCreateWithoutClassesInput>
    where?: TeacherWhereInput
  }

  export type TeacherUpdateToOneWithWhereWithoutClassesInput = {
    where?: TeacherWhereInput
    data: XOR<TeacherUpdateWithoutClassesInput, TeacherUncheckedUpdateWithoutClassesInput>
  }

  export type TeacherUpdateWithoutClassesInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    employeeNumber?: NullableStringFieldUpdateOperationsInput | string | null
    subjects?: TeacherUpdatesubjectsInput | string[]
    qualification?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    joinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutTeacherNestedInput
    institution?: TeacherOnInstitutionUpdateManyWithoutTeacherNestedInput
  }

  export type TeacherUncheckedUpdateWithoutClassesInput = {
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    employeeNumber?: NullableStringFieldUpdateOperationsInput | string | null
    subjects?: TeacherUpdatesubjectsInput | string[]
    qualification?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    joinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    institution?: TeacherOnInstitutionUncheckedUpdateManyWithoutTeacherNestedInput
  }

  export type ClassUpsertWithoutTeachersInput = {
    update: XOR<ClassUpdateWithoutTeachersInput, ClassUncheckedUpdateWithoutTeachersInput>
    create: XOR<ClassCreateWithoutTeachersInput, ClassUncheckedCreateWithoutTeachersInput>
    where?: ClassWhereInput
  }

  export type ClassUpdateToOneWithWhereWithoutTeachersInput = {
    where?: ClassWhereInput
    data: XOR<ClassUpdateWithoutTeachersInput, ClassUncheckedUpdateWithoutTeachersInput>
  }

  export type ClassUpdateWithoutTeachersInput = {
    name?: StringFieldUpdateOperationsInput | string
    section?: NullableStringFieldUpdateOperationsInput | string | null
    academicYear?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    roomNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teacherIds?: ClassUpdateteacherIdsInput | string[]
    institution?: InstitutionUpdateOneRequiredWithoutClassesNestedInput
    students?: StudentUpdateManyWithoutClassNestedInput
    enrollments?: EnrollmentUpdateManyWithoutClassNestedInput
    attendances?: AttendanceUpdateManyWithoutClassNestedInput
    timetables?: TimetableUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateWithoutTeachersInput = {
    institutionId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    section?: NullableStringFieldUpdateOperationsInput | string | null
    academicYear?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    roomNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teacherIds?: ClassUpdateteacherIdsInput | string[]
    students?: StudentUncheckedUpdateManyWithoutClassNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutClassNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutClassNestedInput
    timetables?: TimetableUncheckedUpdateManyWithoutClassNestedInput
  }

  export type InstitutionCreateWithoutClassesInput = {
    id?: string
    name: string
    institutionType?: $Enums.InstitutionType
    address: string
    city: string
    state: string
    country: string
    phone: string
    email: string
    website?: string | null
    plan?: $Enums.InstitutionPlan
    subscriptionStatus?: $Enums.SubscriptionStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UsersOnInstitutionCreateNestedManyWithoutInstitutionInput
    students?: StudentCreateNestedManyWithoutInstitutionInput
    teachers?: TeacherOnInstitutionCreateNestedManyWithoutInstitutionInput
    invoices?: InvoiceCreateNestedManyWithoutInstitutionInput
    messages?: MessageCreateNestedManyWithoutInstitutionInput
  }

  export type InstitutionUncheckedCreateWithoutClassesInput = {
    id?: string
    name: string
    institutionType?: $Enums.InstitutionType
    address: string
    city: string
    state: string
    country: string
    phone: string
    email: string
    website?: string | null
    plan?: $Enums.InstitutionPlan
    subscriptionStatus?: $Enums.SubscriptionStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UsersOnInstitutionUncheckedCreateNestedManyWithoutInstitutionInput
    students?: StudentUncheckedCreateNestedManyWithoutInstitutionInput
    teachers?: TeacherOnInstitutionUncheckedCreateNestedManyWithoutInstitutionInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutInstitutionInput
    messages?: MessageUncheckedCreateNestedManyWithoutInstitutionInput
  }

  export type InstitutionCreateOrConnectWithoutClassesInput = {
    where: InstitutionWhereUniqueInput
    create: XOR<InstitutionCreateWithoutClassesInput, InstitutionUncheckedCreateWithoutClassesInput>
  }

  export type StudentCreateWithoutClassInput = {
    id?: string
    firstName: string
    middleName?: string | null
    lastName: string
    admissionNumber?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    bloodGroup?: string | null
    address?: string | null
    gradeApplying?: string | null
    academicYear?: string | null
    phone?: string | null
    email?: string | null
    guardians?: InputJsonValue | null
    fingerprintEnrolled?: boolean
    fingerprintData?: InputJsonValue | null
    faceData?: InputJsonValue | null
    documents?: InputJsonValue | null
    photo?: string | null
    emergencyContacts?: InputJsonValue | null
    medicalConditions?: string | null
    allergies?: string | null
    medications?: string | null
    previousSchool?: string | null
    previousGrade?: string | null
    transferReason?: string | null
    enrollmentStatus?: string
    enrollmentDate?: Date | string | null
    nationality?: string | null
    religion?: string | null
    languagesSpoken?: StudentCreatelanguagesSpokenInput | string[]
    specialNeeds?: string | null
    transportRequired?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    parentIds?: StudentCreateparentIdsInput | string[]
    StudentDocument?: StudentDocumentCreateNestedManyWithoutStudentInput
    user?: UserCreateNestedOneWithoutStudentInput
    institution: InstitutionCreateNestedOneWithoutStudentsInput
    parents?: ParentCreateNestedManyWithoutStudentInput
    enrollments?: EnrollmentCreateNestedManyWithoutStudentInput
    attendances?: AttendanceCreateNestedManyWithoutStudentInput
    grades?: GradeCreateNestedManyWithoutStudentInput
    invoices?: InvoiceCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutClassInput = {
    id?: string
    userId?: string | null
    institutionId: string
    firstName: string
    middleName?: string | null
    lastName: string
    admissionNumber?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    bloodGroup?: string | null
    address?: string | null
    gradeApplying?: string | null
    academicYear?: string | null
    phone?: string | null
    email?: string | null
    guardians?: InputJsonValue | null
    fingerprintEnrolled?: boolean
    fingerprintData?: InputJsonValue | null
    faceData?: InputJsonValue | null
    documents?: InputJsonValue | null
    photo?: string | null
    emergencyContacts?: InputJsonValue | null
    medicalConditions?: string | null
    allergies?: string | null
    medications?: string | null
    previousSchool?: string | null
    previousGrade?: string | null
    transferReason?: string | null
    enrollmentStatus?: string
    enrollmentDate?: Date | string | null
    nationality?: string | null
    religion?: string | null
    languagesSpoken?: StudentCreatelanguagesSpokenInput | string[]
    specialNeeds?: string | null
    transportRequired?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    parentIds?: StudentCreateparentIdsInput | string[]
    StudentDocument?: StudentDocumentUncheckedCreateNestedManyWithoutStudentInput
    parents?: ParentUncheckedCreateNestedManyWithoutStudentInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutStudentInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutStudentInput
    grades?: GradeUncheckedCreateNestedManyWithoutStudentInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutClassInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutClassInput, StudentUncheckedCreateWithoutClassInput>
  }

  export type StudentCreateManyClassInputEnvelope = {
    data: StudentCreateManyClassInput | StudentCreateManyClassInput[]
  }

  export type TeacherOnClassCreateWithoutClassInput = {
    id?: string
    teacher: TeacherCreateNestedOneWithoutClassesInput
  }

  export type TeacherOnClassUncheckedCreateWithoutClassInput = {
    id?: string
    teacherId: string
  }

  export type TeacherOnClassCreateOrConnectWithoutClassInput = {
    where: TeacherOnClassWhereUniqueInput
    create: XOR<TeacherOnClassCreateWithoutClassInput, TeacherOnClassUncheckedCreateWithoutClassInput>
  }

  export type TeacherOnClassCreateManyClassInputEnvelope = {
    data: TeacherOnClassCreateManyClassInput | TeacherOnClassCreateManyClassInput[]
  }

  export type EnrollmentCreateWithoutClassInput = {
    id?: string
    academicYear: string
    enrollDate?: Date | string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutEnrollmentsInput
  }

  export type EnrollmentUncheckedCreateWithoutClassInput = {
    id?: string
    studentId: string
    academicYear: string
    enrollDate?: Date | string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EnrollmentCreateOrConnectWithoutClassInput = {
    where: EnrollmentWhereUniqueInput
    create: XOR<EnrollmentCreateWithoutClassInput, EnrollmentUncheckedCreateWithoutClassInput>
  }

  export type EnrollmentCreateManyClassInputEnvelope = {
    data: EnrollmentCreateManyClassInput | EnrollmentCreateManyClassInput[]
  }

  export type AttendanceCreateWithoutClassInput = {
    id?: string
    date: Date | string
    status: string
    remarks?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutAttendancesInput
  }

  export type AttendanceUncheckedCreateWithoutClassInput = {
    id?: string
    studentId: string
    date: Date | string
    status: string
    remarks?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttendanceCreateOrConnectWithoutClassInput = {
    where: AttendanceWhereUniqueInput
    create: XOR<AttendanceCreateWithoutClassInput, AttendanceUncheckedCreateWithoutClassInput>
  }

  export type AttendanceCreateManyClassInputEnvelope = {
    data: AttendanceCreateManyClassInput | AttendanceCreateManyClassInput[]
  }

  export type TimetableCreateWithoutClassInput = {
    id?: string
    dayOfWeek: number
    startTime: string
    endTime: string
    subject: string
    teacherId?: string | null
    room?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TimetableUncheckedCreateWithoutClassInput = {
    id?: string
    dayOfWeek: number
    startTime: string
    endTime: string
    subject: string
    teacherId?: string | null
    room?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TimetableCreateOrConnectWithoutClassInput = {
    where: TimetableWhereUniqueInput
    create: XOR<TimetableCreateWithoutClassInput, TimetableUncheckedCreateWithoutClassInput>
  }

  export type TimetableCreateManyClassInputEnvelope = {
    data: TimetableCreateManyClassInput | TimetableCreateManyClassInput[]
  }

  export type InstitutionUpsertWithoutClassesInput = {
    update: XOR<InstitutionUpdateWithoutClassesInput, InstitutionUncheckedUpdateWithoutClassesInput>
    create: XOR<InstitutionCreateWithoutClassesInput, InstitutionUncheckedCreateWithoutClassesInput>
    where?: InstitutionWhereInput
  }

  export type InstitutionUpdateToOneWithWhereWithoutClassesInput = {
    where?: InstitutionWhereInput
    data: XOR<InstitutionUpdateWithoutClassesInput, InstitutionUncheckedUpdateWithoutClassesInput>
  }

  export type InstitutionUpdateWithoutClassesInput = {
    name?: StringFieldUpdateOperationsInput | string
    institutionType?: EnumInstitutionTypeFieldUpdateOperationsInput | $Enums.InstitutionType
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: EnumInstitutionPlanFieldUpdateOperationsInput | $Enums.InstitutionPlan
    subscriptionStatus?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UsersOnInstitutionUpdateManyWithoutInstitutionNestedInput
    students?: StudentUpdateManyWithoutInstitutionNestedInput
    teachers?: TeacherOnInstitutionUpdateManyWithoutInstitutionNestedInput
    invoices?: InvoiceUpdateManyWithoutInstitutionNestedInput
    messages?: MessageUpdateManyWithoutInstitutionNestedInput
  }

  export type InstitutionUncheckedUpdateWithoutClassesInput = {
    name?: StringFieldUpdateOperationsInput | string
    institutionType?: EnumInstitutionTypeFieldUpdateOperationsInput | $Enums.InstitutionType
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: EnumInstitutionPlanFieldUpdateOperationsInput | $Enums.InstitutionPlan
    subscriptionStatus?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UsersOnInstitutionUncheckedUpdateManyWithoutInstitutionNestedInput
    students?: StudentUncheckedUpdateManyWithoutInstitutionNestedInput
    teachers?: TeacherOnInstitutionUncheckedUpdateManyWithoutInstitutionNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutInstitutionNestedInput
    messages?: MessageUncheckedUpdateManyWithoutInstitutionNestedInput
  }

  export type StudentUpsertWithWhereUniqueWithoutClassInput = {
    where: StudentWhereUniqueInput
    update: XOR<StudentUpdateWithoutClassInput, StudentUncheckedUpdateWithoutClassInput>
    create: XOR<StudentCreateWithoutClassInput, StudentUncheckedCreateWithoutClassInput>
  }

  export type StudentUpdateWithWhereUniqueWithoutClassInput = {
    where: StudentWhereUniqueInput
    data: XOR<StudentUpdateWithoutClassInput, StudentUncheckedUpdateWithoutClassInput>
  }

  export type StudentUpdateManyWithWhereWithoutClassInput = {
    where: StudentScalarWhereInput
    data: XOR<StudentUpdateManyMutationInput, StudentUncheckedUpdateManyWithoutClassInput>
  }

  export type TeacherOnClassUpsertWithWhereUniqueWithoutClassInput = {
    where: TeacherOnClassWhereUniqueInput
    update: XOR<TeacherOnClassUpdateWithoutClassInput, TeacherOnClassUncheckedUpdateWithoutClassInput>
    create: XOR<TeacherOnClassCreateWithoutClassInput, TeacherOnClassUncheckedCreateWithoutClassInput>
  }

  export type TeacherOnClassUpdateWithWhereUniqueWithoutClassInput = {
    where: TeacherOnClassWhereUniqueInput
    data: XOR<TeacherOnClassUpdateWithoutClassInput, TeacherOnClassUncheckedUpdateWithoutClassInput>
  }

  export type TeacherOnClassUpdateManyWithWhereWithoutClassInput = {
    where: TeacherOnClassScalarWhereInput
    data: XOR<TeacherOnClassUpdateManyMutationInput, TeacherOnClassUncheckedUpdateManyWithoutClassInput>
  }

  export type EnrollmentUpsertWithWhereUniqueWithoutClassInput = {
    where: EnrollmentWhereUniqueInput
    update: XOR<EnrollmentUpdateWithoutClassInput, EnrollmentUncheckedUpdateWithoutClassInput>
    create: XOR<EnrollmentCreateWithoutClassInput, EnrollmentUncheckedCreateWithoutClassInput>
  }

  export type EnrollmentUpdateWithWhereUniqueWithoutClassInput = {
    where: EnrollmentWhereUniqueInput
    data: XOR<EnrollmentUpdateWithoutClassInput, EnrollmentUncheckedUpdateWithoutClassInput>
  }

  export type EnrollmentUpdateManyWithWhereWithoutClassInput = {
    where: EnrollmentScalarWhereInput
    data: XOR<EnrollmentUpdateManyMutationInput, EnrollmentUncheckedUpdateManyWithoutClassInput>
  }

  export type AttendanceUpsertWithWhereUniqueWithoutClassInput = {
    where: AttendanceWhereUniqueInput
    update: XOR<AttendanceUpdateWithoutClassInput, AttendanceUncheckedUpdateWithoutClassInput>
    create: XOR<AttendanceCreateWithoutClassInput, AttendanceUncheckedCreateWithoutClassInput>
  }

  export type AttendanceUpdateWithWhereUniqueWithoutClassInput = {
    where: AttendanceWhereUniqueInput
    data: XOR<AttendanceUpdateWithoutClassInput, AttendanceUncheckedUpdateWithoutClassInput>
  }

  export type AttendanceUpdateManyWithWhereWithoutClassInput = {
    where: AttendanceScalarWhereInput
    data: XOR<AttendanceUpdateManyMutationInput, AttendanceUncheckedUpdateManyWithoutClassInput>
  }

  export type TimetableUpsertWithWhereUniqueWithoutClassInput = {
    where: TimetableWhereUniqueInput
    update: XOR<TimetableUpdateWithoutClassInput, TimetableUncheckedUpdateWithoutClassInput>
    create: XOR<TimetableCreateWithoutClassInput, TimetableUncheckedCreateWithoutClassInput>
  }

  export type TimetableUpdateWithWhereUniqueWithoutClassInput = {
    where: TimetableWhereUniqueInput
    data: XOR<TimetableUpdateWithoutClassInput, TimetableUncheckedUpdateWithoutClassInput>
  }

  export type TimetableUpdateManyWithWhereWithoutClassInput = {
    where: TimetableScalarWhereInput
    data: XOR<TimetableUpdateManyMutationInput, TimetableUncheckedUpdateManyWithoutClassInput>
  }

  export type TimetableScalarWhereInput = {
    AND?: TimetableScalarWhereInput | TimetableScalarWhereInput[]
    OR?: TimetableScalarWhereInput[]
    NOT?: TimetableScalarWhereInput | TimetableScalarWhereInput[]
    id?: StringFilter<"Timetable"> | string
    classId?: StringFilter<"Timetable"> | string
    dayOfWeek?: IntFilter<"Timetable"> | number
    startTime?: StringFilter<"Timetable"> | string
    endTime?: StringFilter<"Timetable"> | string
    subject?: StringFilter<"Timetable"> | string
    teacherId?: StringNullableFilter<"Timetable"> | string | null
    room?: StringNullableFilter<"Timetable"> | string | null
    createdAt?: DateTimeFilter<"Timetable"> | Date | string
    updatedAt?: DateTimeFilter<"Timetable"> | Date | string
  }

  export type StudentCreateWithoutEnrollmentsInput = {
    id?: string
    firstName: string
    middleName?: string | null
    lastName: string
    admissionNumber?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    bloodGroup?: string | null
    address?: string | null
    gradeApplying?: string | null
    academicYear?: string | null
    phone?: string | null
    email?: string | null
    guardians?: InputJsonValue | null
    fingerprintEnrolled?: boolean
    fingerprintData?: InputJsonValue | null
    faceData?: InputJsonValue | null
    documents?: InputJsonValue | null
    photo?: string | null
    emergencyContacts?: InputJsonValue | null
    medicalConditions?: string | null
    allergies?: string | null
    medications?: string | null
    previousSchool?: string | null
    previousGrade?: string | null
    transferReason?: string | null
    enrollmentStatus?: string
    enrollmentDate?: Date | string | null
    nationality?: string | null
    religion?: string | null
    languagesSpoken?: StudentCreatelanguagesSpokenInput | string[]
    specialNeeds?: string | null
    transportRequired?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    parentIds?: StudentCreateparentIdsInput | string[]
    StudentDocument?: StudentDocumentCreateNestedManyWithoutStudentInput
    user?: UserCreateNestedOneWithoutStudentInput
    institution: InstitutionCreateNestedOneWithoutStudentsInput
    class?: ClassCreateNestedOneWithoutStudentsInput
    parents?: ParentCreateNestedManyWithoutStudentInput
    attendances?: AttendanceCreateNestedManyWithoutStudentInput
    grades?: GradeCreateNestedManyWithoutStudentInput
    invoices?: InvoiceCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutEnrollmentsInput = {
    id?: string
    userId?: string | null
    institutionId: string
    firstName: string
    middleName?: string | null
    lastName: string
    admissionNumber?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    bloodGroup?: string | null
    address?: string | null
    gradeApplying?: string | null
    academicYear?: string | null
    classId?: string | null
    phone?: string | null
    email?: string | null
    guardians?: InputJsonValue | null
    fingerprintEnrolled?: boolean
    fingerprintData?: InputJsonValue | null
    faceData?: InputJsonValue | null
    documents?: InputJsonValue | null
    photo?: string | null
    emergencyContacts?: InputJsonValue | null
    medicalConditions?: string | null
    allergies?: string | null
    medications?: string | null
    previousSchool?: string | null
    previousGrade?: string | null
    transferReason?: string | null
    enrollmentStatus?: string
    enrollmentDate?: Date | string | null
    nationality?: string | null
    religion?: string | null
    languagesSpoken?: StudentCreatelanguagesSpokenInput | string[]
    specialNeeds?: string | null
    transportRequired?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    parentIds?: StudentCreateparentIdsInput | string[]
    StudentDocument?: StudentDocumentUncheckedCreateNestedManyWithoutStudentInput
    parents?: ParentUncheckedCreateNestedManyWithoutStudentInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutStudentInput
    grades?: GradeUncheckedCreateNestedManyWithoutStudentInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutEnrollmentsInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutEnrollmentsInput, StudentUncheckedCreateWithoutEnrollmentsInput>
  }

  export type ClassCreateWithoutEnrollmentsInput = {
    id?: string
    name: string
    section?: string | null
    academicYear?: string | null
    capacity?: number | null
    roomNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    teacherIds?: ClassCreateteacherIdsInput | string[]
    institution: InstitutionCreateNestedOneWithoutClassesInput
    students?: StudentCreateNestedManyWithoutClassInput
    teachers?: TeacherOnClassCreateNestedManyWithoutClassInput
    attendances?: AttendanceCreateNestedManyWithoutClassInput
    timetables?: TimetableCreateNestedManyWithoutClassInput
  }

  export type ClassUncheckedCreateWithoutEnrollmentsInput = {
    id?: string
    institutionId: string
    name: string
    section?: string | null
    academicYear?: string | null
    capacity?: number | null
    roomNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    teacherIds?: ClassCreateteacherIdsInput | string[]
    students?: StudentUncheckedCreateNestedManyWithoutClassInput
    teachers?: TeacherOnClassUncheckedCreateNestedManyWithoutClassInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutClassInput
    timetables?: TimetableUncheckedCreateNestedManyWithoutClassInput
  }

  export type ClassCreateOrConnectWithoutEnrollmentsInput = {
    where: ClassWhereUniqueInput
    create: XOR<ClassCreateWithoutEnrollmentsInput, ClassUncheckedCreateWithoutEnrollmentsInput>
  }

  export type StudentUpsertWithoutEnrollmentsInput = {
    update: XOR<StudentUpdateWithoutEnrollmentsInput, StudentUncheckedUpdateWithoutEnrollmentsInput>
    create: XOR<StudentCreateWithoutEnrollmentsInput, StudentUncheckedCreateWithoutEnrollmentsInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutEnrollmentsInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutEnrollmentsInput, StudentUncheckedUpdateWithoutEnrollmentsInput>
  }

  export type StudentUpdateWithoutEnrollmentsInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    admissionNumber?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gradeApplying?: NullableStringFieldUpdateOperationsInput | string | null
    academicYear?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    guardians?: InputJsonValue | InputJsonValue | null
    fingerprintEnrolled?: BoolFieldUpdateOperationsInput | boolean
    fingerprintData?: InputJsonValue | InputJsonValue | null
    faceData?: InputJsonValue | InputJsonValue | null
    documents?: InputJsonValue | InputJsonValue | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContacts?: InputJsonValue | InputJsonValue | null
    medicalConditions?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    medications?: NullableStringFieldUpdateOperationsInput | string | null
    previousSchool?: NullableStringFieldUpdateOperationsInput | string | null
    previousGrade?: NullableStringFieldUpdateOperationsInput | string | null
    transferReason?: NullableStringFieldUpdateOperationsInput | string | null
    enrollmentStatus?: StringFieldUpdateOperationsInput | string
    enrollmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    languagesSpoken?: StudentUpdatelanguagesSpokenInput | string[]
    specialNeeds?: NullableStringFieldUpdateOperationsInput | string | null
    transportRequired?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentIds?: StudentUpdateparentIdsInput | string[]
    StudentDocument?: StudentDocumentUpdateManyWithoutStudentNestedInput
    user?: UserUpdateOneWithoutStudentNestedInput
    institution?: InstitutionUpdateOneRequiredWithoutStudentsNestedInput
    class?: ClassUpdateOneWithoutStudentsNestedInput
    parents?: ParentUpdateManyWithoutStudentNestedInput
    attendances?: AttendanceUpdateManyWithoutStudentNestedInput
    grades?: GradeUpdateManyWithoutStudentNestedInput
    invoices?: InvoiceUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutEnrollmentsInput = {
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    institutionId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    admissionNumber?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gradeApplying?: NullableStringFieldUpdateOperationsInput | string | null
    academicYear?: NullableStringFieldUpdateOperationsInput | string | null
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    guardians?: InputJsonValue | InputJsonValue | null
    fingerprintEnrolled?: BoolFieldUpdateOperationsInput | boolean
    fingerprintData?: InputJsonValue | InputJsonValue | null
    faceData?: InputJsonValue | InputJsonValue | null
    documents?: InputJsonValue | InputJsonValue | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContacts?: InputJsonValue | InputJsonValue | null
    medicalConditions?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    medications?: NullableStringFieldUpdateOperationsInput | string | null
    previousSchool?: NullableStringFieldUpdateOperationsInput | string | null
    previousGrade?: NullableStringFieldUpdateOperationsInput | string | null
    transferReason?: NullableStringFieldUpdateOperationsInput | string | null
    enrollmentStatus?: StringFieldUpdateOperationsInput | string
    enrollmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    languagesSpoken?: StudentUpdatelanguagesSpokenInput | string[]
    specialNeeds?: NullableStringFieldUpdateOperationsInput | string | null
    transportRequired?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentIds?: StudentUpdateparentIdsInput | string[]
    StudentDocument?: StudentDocumentUncheckedUpdateManyWithoutStudentNestedInput
    parents?: ParentUncheckedUpdateManyWithoutStudentNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutStudentNestedInput
    grades?: GradeUncheckedUpdateManyWithoutStudentNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type ClassUpsertWithoutEnrollmentsInput = {
    update: XOR<ClassUpdateWithoutEnrollmentsInput, ClassUncheckedUpdateWithoutEnrollmentsInput>
    create: XOR<ClassCreateWithoutEnrollmentsInput, ClassUncheckedCreateWithoutEnrollmentsInput>
    where?: ClassWhereInput
  }

  export type ClassUpdateToOneWithWhereWithoutEnrollmentsInput = {
    where?: ClassWhereInput
    data: XOR<ClassUpdateWithoutEnrollmentsInput, ClassUncheckedUpdateWithoutEnrollmentsInput>
  }

  export type ClassUpdateWithoutEnrollmentsInput = {
    name?: StringFieldUpdateOperationsInput | string
    section?: NullableStringFieldUpdateOperationsInput | string | null
    academicYear?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    roomNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teacherIds?: ClassUpdateteacherIdsInput | string[]
    institution?: InstitutionUpdateOneRequiredWithoutClassesNestedInput
    students?: StudentUpdateManyWithoutClassNestedInput
    teachers?: TeacherOnClassUpdateManyWithoutClassNestedInput
    attendances?: AttendanceUpdateManyWithoutClassNestedInput
    timetables?: TimetableUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateWithoutEnrollmentsInput = {
    institutionId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    section?: NullableStringFieldUpdateOperationsInput | string | null
    academicYear?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    roomNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teacherIds?: ClassUpdateteacherIdsInput | string[]
    students?: StudentUncheckedUpdateManyWithoutClassNestedInput
    teachers?: TeacherOnClassUncheckedUpdateManyWithoutClassNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutClassNestedInput
    timetables?: TimetableUncheckedUpdateManyWithoutClassNestedInput
  }

  export type ClassCreateWithoutAttendancesInput = {
    id?: string
    name: string
    section?: string | null
    academicYear?: string | null
    capacity?: number | null
    roomNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    teacherIds?: ClassCreateteacherIdsInput | string[]
    institution: InstitutionCreateNestedOneWithoutClassesInput
    students?: StudentCreateNestedManyWithoutClassInput
    teachers?: TeacherOnClassCreateNestedManyWithoutClassInput
    enrollments?: EnrollmentCreateNestedManyWithoutClassInput
    timetables?: TimetableCreateNestedManyWithoutClassInput
  }

  export type ClassUncheckedCreateWithoutAttendancesInput = {
    id?: string
    institutionId: string
    name: string
    section?: string | null
    academicYear?: string | null
    capacity?: number | null
    roomNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    teacherIds?: ClassCreateteacherIdsInput | string[]
    students?: StudentUncheckedCreateNestedManyWithoutClassInput
    teachers?: TeacherOnClassUncheckedCreateNestedManyWithoutClassInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutClassInput
    timetables?: TimetableUncheckedCreateNestedManyWithoutClassInput
  }

  export type ClassCreateOrConnectWithoutAttendancesInput = {
    where: ClassWhereUniqueInput
    create: XOR<ClassCreateWithoutAttendancesInput, ClassUncheckedCreateWithoutAttendancesInput>
  }

  export type StudentCreateWithoutAttendancesInput = {
    id?: string
    firstName: string
    middleName?: string | null
    lastName: string
    admissionNumber?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    bloodGroup?: string | null
    address?: string | null
    gradeApplying?: string | null
    academicYear?: string | null
    phone?: string | null
    email?: string | null
    guardians?: InputJsonValue | null
    fingerprintEnrolled?: boolean
    fingerprintData?: InputJsonValue | null
    faceData?: InputJsonValue | null
    documents?: InputJsonValue | null
    photo?: string | null
    emergencyContacts?: InputJsonValue | null
    medicalConditions?: string | null
    allergies?: string | null
    medications?: string | null
    previousSchool?: string | null
    previousGrade?: string | null
    transferReason?: string | null
    enrollmentStatus?: string
    enrollmentDate?: Date | string | null
    nationality?: string | null
    religion?: string | null
    languagesSpoken?: StudentCreatelanguagesSpokenInput | string[]
    specialNeeds?: string | null
    transportRequired?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    parentIds?: StudentCreateparentIdsInput | string[]
    StudentDocument?: StudentDocumentCreateNestedManyWithoutStudentInput
    user?: UserCreateNestedOneWithoutStudentInput
    institution: InstitutionCreateNestedOneWithoutStudentsInput
    class?: ClassCreateNestedOneWithoutStudentsInput
    parents?: ParentCreateNestedManyWithoutStudentInput
    enrollments?: EnrollmentCreateNestedManyWithoutStudentInput
    grades?: GradeCreateNestedManyWithoutStudentInput
    invoices?: InvoiceCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutAttendancesInput = {
    id?: string
    userId?: string | null
    institutionId: string
    firstName: string
    middleName?: string | null
    lastName: string
    admissionNumber?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    bloodGroup?: string | null
    address?: string | null
    gradeApplying?: string | null
    academicYear?: string | null
    classId?: string | null
    phone?: string | null
    email?: string | null
    guardians?: InputJsonValue | null
    fingerprintEnrolled?: boolean
    fingerprintData?: InputJsonValue | null
    faceData?: InputJsonValue | null
    documents?: InputJsonValue | null
    photo?: string | null
    emergencyContacts?: InputJsonValue | null
    medicalConditions?: string | null
    allergies?: string | null
    medications?: string | null
    previousSchool?: string | null
    previousGrade?: string | null
    transferReason?: string | null
    enrollmentStatus?: string
    enrollmentDate?: Date | string | null
    nationality?: string | null
    religion?: string | null
    languagesSpoken?: StudentCreatelanguagesSpokenInput | string[]
    specialNeeds?: string | null
    transportRequired?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    parentIds?: StudentCreateparentIdsInput | string[]
    StudentDocument?: StudentDocumentUncheckedCreateNestedManyWithoutStudentInput
    parents?: ParentUncheckedCreateNestedManyWithoutStudentInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutStudentInput
    grades?: GradeUncheckedCreateNestedManyWithoutStudentInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutAttendancesInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutAttendancesInput, StudentUncheckedCreateWithoutAttendancesInput>
  }

  export type ClassUpsertWithoutAttendancesInput = {
    update: XOR<ClassUpdateWithoutAttendancesInput, ClassUncheckedUpdateWithoutAttendancesInput>
    create: XOR<ClassCreateWithoutAttendancesInput, ClassUncheckedCreateWithoutAttendancesInput>
    where?: ClassWhereInput
  }

  export type ClassUpdateToOneWithWhereWithoutAttendancesInput = {
    where?: ClassWhereInput
    data: XOR<ClassUpdateWithoutAttendancesInput, ClassUncheckedUpdateWithoutAttendancesInput>
  }

  export type ClassUpdateWithoutAttendancesInput = {
    name?: StringFieldUpdateOperationsInput | string
    section?: NullableStringFieldUpdateOperationsInput | string | null
    academicYear?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    roomNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teacherIds?: ClassUpdateteacherIdsInput | string[]
    institution?: InstitutionUpdateOneRequiredWithoutClassesNestedInput
    students?: StudentUpdateManyWithoutClassNestedInput
    teachers?: TeacherOnClassUpdateManyWithoutClassNestedInput
    enrollments?: EnrollmentUpdateManyWithoutClassNestedInput
    timetables?: TimetableUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateWithoutAttendancesInput = {
    institutionId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    section?: NullableStringFieldUpdateOperationsInput | string | null
    academicYear?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    roomNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teacherIds?: ClassUpdateteacherIdsInput | string[]
    students?: StudentUncheckedUpdateManyWithoutClassNestedInput
    teachers?: TeacherOnClassUncheckedUpdateManyWithoutClassNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutClassNestedInput
    timetables?: TimetableUncheckedUpdateManyWithoutClassNestedInput
  }

  export type StudentUpsertWithoutAttendancesInput = {
    update: XOR<StudentUpdateWithoutAttendancesInput, StudentUncheckedUpdateWithoutAttendancesInput>
    create: XOR<StudentCreateWithoutAttendancesInput, StudentUncheckedCreateWithoutAttendancesInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutAttendancesInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutAttendancesInput, StudentUncheckedUpdateWithoutAttendancesInput>
  }

  export type StudentUpdateWithoutAttendancesInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    admissionNumber?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gradeApplying?: NullableStringFieldUpdateOperationsInput | string | null
    academicYear?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    guardians?: InputJsonValue | InputJsonValue | null
    fingerprintEnrolled?: BoolFieldUpdateOperationsInput | boolean
    fingerprintData?: InputJsonValue | InputJsonValue | null
    faceData?: InputJsonValue | InputJsonValue | null
    documents?: InputJsonValue | InputJsonValue | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContacts?: InputJsonValue | InputJsonValue | null
    medicalConditions?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    medications?: NullableStringFieldUpdateOperationsInput | string | null
    previousSchool?: NullableStringFieldUpdateOperationsInput | string | null
    previousGrade?: NullableStringFieldUpdateOperationsInput | string | null
    transferReason?: NullableStringFieldUpdateOperationsInput | string | null
    enrollmentStatus?: StringFieldUpdateOperationsInput | string
    enrollmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    languagesSpoken?: StudentUpdatelanguagesSpokenInput | string[]
    specialNeeds?: NullableStringFieldUpdateOperationsInput | string | null
    transportRequired?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentIds?: StudentUpdateparentIdsInput | string[]
    StudentDocument?: StudentDocumentUpdateManyWithoutStudentNestedInput
    user?: UserUpdateOneWithoutStudentNestedInput
    institution?: InstitutionUpdateOneRequiredWithoutStudentsNestedInput
    class?: ClassUpdateOneWithoutStudentsNestedInput
    parents?: ParentUpdateManyWithoutStudentNestedInput
    enrollments?: EnrollmentUpdateManyWithoutStudentNestedInput
    grades?: GradeUpdateManyWithoutStudentNestedInput
    invoices?: InvoiceUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutAttendancesInput = {
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    institutionId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    admissionNumber?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gradeApplying?: NullableStringFieldUpdateOperationsInput | string | null
    academicYear?: NullableStringFieldUpdateOperationsInput | string | null
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    guardians?: InputJsonValue | InputJsonValue | null
    fingerprintEnrolled?: BoolFieldUpdateOperationsInput | boolean
    fingerprintData?: InputJsonValue | InputJsonValue | null
    faceData?: InputJsonValue | InputJsonValue | null
    documents?: InputJsonValue | InputJsonValue | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContacts?: InputJsonValue | InputJsonValue | null
    medicalConditions?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    medications?: NullableStringFieldUpdateOperationsInput | string | null
    previousSchool?: NullableStringFieldUpdateOperationsInput | string | null
    previousGrade?: NullableStringFieldUpdateOperationsInput | string | null
    transferReason?: NullableStringFieldUpdateOperationsInput | string | null
    enrollmentStatus?: StringFieldUpdateOperationsInput | string
    enrollmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    languagesSpoken?: StudentUpdatelanguagesSpokenInput | string[]
    specialNeeds?: NullableStringFieldUpdateOperationsInput | string | null
    transportRequired?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentIds?: StudentUpdateparentIdsInput | string[]
    StudentDocument?: StudentDocumentUncheckedUpdateManyWithoutStudentNestedInput
    parents?: ParentUncheckedUpdateManyWithoutStudentNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutStudentNestedInput
    grades?: GradeUncheckedUpdateManyWithoutStudentNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type StudentCreateWithoutGradesInput = {
    id?: string
    firstName: string
    middleName?: string | null
    lastName: string
    admissionNumber?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    bloodGroup?: string | null
    address?: string | null
    gradeApplying?: string | null
    academicYear?: string | null
    phone?: string | null
    email?: string | null
    guardians?: InputJsonValue | null
    fingerprintEnrolled?: boolean
    fingerprintData?: InputJsonValue | null
    faceData?: InputJsonValue | null
    documents?: InputJsonValue | null
    photo?: string | null
    emergencyContacts?: InputJsonValue | null
    medicalConditions?: string | null
    allergies?: string | null
    medications?: string | null
    previousSchool?: string | null
    previousGrade?: string | null
    transferReason?: string | null
    enrollmentStatus?: string
    enrollmentDate?: Date | string | null
    nationality?: string | null
    religion?: string | null
    languagesSpoken?: StudentCreatelanguagesSpokenInput | string[]
    specialNeeds?: string | null
    transportRequired?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    parentIds?: StudentCreateparentIdsInput | string[]
    StudentDocument?: StudentDocumentCreateNestedManyWithoutStudentInput
    user?: UserCreateNestedOneWithoutStudentInput
    institution: InstitutionCreateNestedOneWithoutStudentsInput
    class?: ClassCreateNestedOneWithoutStudentsInput
    parents?: ParentCreateNestedManyWithoutStudentInput
    enrollments?: EnrollmentCreateNestedManyWithoutStudentInput
    attendances?: AttendanceCreateNestedManyWithoutStudentInput
    invoices?: InvoiceCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutGradesInput = {
    id?: string
    userId?: string | null
    institutionId: string
    firstName: string
    middleName?: string | null
    lastName: string
    admissionNumber?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    bloodGroup?: string | null
    address?: string | null
    gradeApplying?: string | null
    academicYear?: string | null
    classId?: string | null
    phone?: string | null
    email?: string | null
    guardians?: InputJsonValue | null
    fingerprintEnrolled?: boolean
    fingerprintData?: InputJsonValue | null
    faceData?: InputJsonValue | null
    documents?: InputJsonValue | null
    photo?: string | null
    emergencyContacts?: InputJsonValue | null
    medicalConditions?: string | null
    allergies?: string | null
    medications?: string | null
    previousSchool?: string | null
    previousGrade?: string | null
    transferReason?: string | null
    enrollmentStatus?: string
    enrollmentDate?: Date | string | null
    nationality?: string | null
    religion?: string | null
    languagesSpoken?: StudentCreatelanguagesSpokenInput | string[]
    specialNeeds?: string | null
    transportRequired?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    parentIds?: StudentCreateparentIdsInput | string[]
    StudentDocument?: StudentDocumentUncheckedCreateNestedManyWithoutStudentInput
    parents?: ParentUncheckedCreateNestedManyWithoutStudentInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutStudentInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutStudentInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutGradesInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutGradesInput, StudentUncheckedCreateWithoutGradesInput>
  }

  export type StudentUpsertWithoutGradesInput = {
    update: XOR<StudentUpdateWithoutGradesInput, StudentUncheckedUpdateWithoutGradesInput>
    create: XOR<StudentCreateWithoutGradesInput, StudentUncheckedCreateWithoutGradesInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutGradesInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutGradesInput, StudentUncheckedUpdateWithoutGradesInput>
  }

  export type StudentUpdateWithoutGradesInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    admissionNumber?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gradeApplying?: NullableStringFieldUpdateOperationsInput | string | null
    academicYear?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    guardians?: InputJsonValue | InputJsonValue | null
    fingerprintEnrolled?: BoolFieldUpdateOperationsInput | boolean
    fingerprintData?: InputJsonValue | InputJsonValue | null
    faceData?: InputJsonValue | InputJsonValue | null
    documents?: InputJsonValue | InputJsonValue | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContacts?: InputJsonValue | InputJsonValue | null
    medicalConditions?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    medications?: NullableStringFieldUpdateOperationsInput | string | null
    previousSchool?: NullableStringFieldUpdateOperationsInput | string | null
    previousGrade?: NullableStringFieldUpdateOperationsInput | string | null
    transferReason?: NullableStringFieldUpdateOperationsInput | string | null
    enrollmentStatus?: StringFieldUpdateOperationsInput | string
    enrollmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    languagesSpoken?: StudentUpdatelanguagesSpokenInput | string[]
    specialNeeds?: NullableStringFieldUpdateOperationsInput | string | null
    transportRequired?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentIds?: StudentUpdateparentIdsInput | string[]
    StudentDocument?: StudentDocumentUpdateManyWithoutStudentNestedInput
    user?: UserUpdateOneWithoutStudentNestedInput
    institution?: InstitutionUpdateOneRequiredWithoutStudentsNestedInput
    class?: ClassUpdateOneWithoutStudentsNestedInput
    parents?: ParentUpdateManyWithoutStudentNestedInput
    enrollments?: EnrollmentUpdateManyWithoutStudentNestedInput
    attendances?: AttendanceUpdateManyWithoutStudentNestedInput
    invoices?: InvoiceUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutGradesInput = {
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    institutionId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    admissionNumber?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gradeApplying?: NullableStringFieldUpdateOperationsInput | string | null
    academicYear?: NullableStringFieldUpdateOperationsInput | string | null
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    guardians?: InputJsonValue | InputJsonValue | null
    fingerprintEnrolled?: BoolFieldUpdateOperationsInput | boolean
    fingerprintData?: InputJsonValue | InputJsonValue | null
    faceData?: InputJsonValue | InputJsonValue | null
    documents?: InputJsonValue | InputJsonValue | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContacts?: InputJsonValue | InputJsonValue | null
    medicalConditions?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    medications?: NullableStringFieldUpdateOperationsInput | string | null
    previousSchool?: NullableStringFieldUpdateOperationsInput | string | null
    previousGrade?: NullableStringFieldUpdateOperationsInput | string | null
    transferReason?: NullableStringFieldUpdateOperationsInput | string | null
    enrollmentStatus?: StringFieldUpdateOperationsInput | string
    enrollmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    languagesSpoken?: StudentUpdatelanguagesSpokenInput | string[]
    specialNeeds?: NullableStringFieldUpdateOperationsInput | string | null
    transportRequired?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentIds?: StudentUpdateparentIdsInput | string[]
    StudentDocument?: StudentDocumentUncheckedUpdateManyWithoutStudentNestedInput
    parents?: ParentUncheckedUpdateManyWithoutStudentNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutStudentNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutStudentNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type ClassCreateWithoutTimetablesInput = {
    id?: string
    name: string
    section?: string | null
    academicYear?: string | null
    capacity?: number | null
    roomNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    teacherIds?: ClassCreateteacherIdsInput | string[]
    institution: InstitutionCreateNestedOneWithoutClassesInput
    students?: StudentCreateNestedManyWithoutClassInput
    teachers?: TeacherOnClassCreateNestedManyWithoutClassInput
    enrollments?: EnrollmentCreateNestedManyWithoutClassInput
    attendances?: AttendanceCreateNestedManyWithoutClassInput
  }

  export type ClassUncheckedCreateWithoutTimetablesInput = {
    id?: string
    institutionId: string
    name: string
    section?: string | null
    academicYear?: string | null
    capacity?: number | null
    roomNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    teacherIds?: ClassCreateteacherIdsInput | string[]
    students?: StudentUncheckedCreateNestedManyWithoutClassInput
    teachers?: TeacherOnClassUncheckedCreateNestedManyWithoutClassInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutClassInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutClassInput
  }

  export type ClassCreateOrConnectWithoutTimetablesInput = {
    where: ClassWhereUniqueInput
    create: XOR<ClassCreateWithoutTimetablesInput, ClassUncheckedCreateWithoutTimetablesInput>
  }

  export type ClassUpsertWithoutTimetablesInput = {
    update: XOR<ClassUpdateWithoutTimetablesInput, ClassUncheckedUpdateWithoutTimetablesInput>
    create: XOR<ClassCreateWithoutTimetablesInput, ClassUncheckedCreateWithoutTimetablesInput>
    where?: ClassWhereInput
  }

  export type ClassUpdateToOneWithWhereWithoutTimetablesInput = {
    where?: ClassWhereInput
    data: XOR<ClassUpdateWithoutTimetablesInput, ClassUncheckedUpdateWithoutTimetablesInput>
  }

  export type ClassUpdateWithoutTimetablesInput = {
    name?: StringFieldUpdateOperationsInput | string
    section?: NullableStringFieldUpdateOperationsInput | string | null
    academicYear?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    roomNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teacherIds?: ClassUpdateteacherIdsInput | string[]
    institution?: InstitutionUpdateOneRequiredWithoutClassesNestedInput
    students?: StudentUpdateManyWithoutClassNestedInput
    teachers?: TeacherOnClassUpdateManyWithoutClassNestedInput
    enrollments?: EnrollmentUpdateManyWithoutClassNestedInput
    attendances?: AttendanceUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateWithoutTimetablesInput = {
    institutionId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    section?: NullableStringFieldUpdateOperationsInput | string | null
    academicYear?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    roomNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teacherIds?: ClassUpdateteacherIdsInput | string[]
    students?: StudentUncheckedUpdateManyWithoutClassNestedInput
    teachers?: TeacherOnClassUncheckedUpdateManyWithoutClassNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutClassNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutClassNestedInput
  }

  export type InstitutionCreateWithoutInvoicesInput = {
    id?: string
    name: string
    institutionType?: $Enums.InstitutionType
    address: string
    city: string
    state: string
    country: string
    phone: string
    email: string
    website?: string | null
    plan?: $Enums.InstitutionPlan
    subscriptionStatus?: $Enums.SubscriptionStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UsersOnInstitutionCreateNestedManyWithoutInstitutionInput
    classes?: ClassCreateNestedManyWithoutInstitutionInput
    students?: StudentCreateNestedManyWithoutInstitutionInput
    teachers?: TeacherOnInstitutionCreateNestedManyWithoutInstitutionInput
    messages?: MessageCreateNestedManyWithoutInstitutionInput
  }

  export type InstitutionUncheckedCreateWithoutInvoicesInput = {
    id?: string
    name: string
    institutionType?: $Enums.InstitutionType
    address: string
    city: string
    state: string
    country: string
    phone: string
    email: string
    website?: string | null
    plan?: $Enums.InstitutionPlan
    subscriptionStatus?: $Enums.SubscriptionStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UsersOnInstitutionUncheckedCreateNestedManyWithoutInstitutionInput
    classes?: ClassUncheckedCreateNestedManyWithoutInstitutionInput
    students?: StudentUncheckedCreateNestedManyWithoutInstitutionInput
    teachers?: TeacherOnInstitutionUncheckedCreateNestedManyWithoutInstitutionInput
    messages?: MessageUncheckedCreateNestedManyWithoutInstitutionInput
  }

  export type InstitutionCreateOrConnectWithoutInvoicesInput = {
    where: InstitutionWhereUniqueInput
    create: XOR<InstitutionCreateWithoutInvoicesInput, InstitutionUncheckedCreateWithoutInvoicesInput>
  }

  export type StudentCreateWithoutInvoicesInput = {
    id?: string
    firstName: string
    middleName?: string | null
    lastName: string
    admissionNumber?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    bloodGroup?: string | null
    address?: string | null
    gradeApplying?: string | null
    academicYear?: string | null
    phone?: string | null
    email?: string | null
    guardians?: InputJsonValue | null
    fingerprintEnrolled?: boolean
    fingerprintData?: InputJsonValue | null
    faceData?: InputJsonValue | null
    documents?: InputJsonValue | null
    photo?: string | null
    emergencyContacts?: InputJsonValue | null
    medicalConditions?: string | null
    allergies?: string | null
    medications?: string | null
    previousSchool?: string | null
    previousGrade?: string | null
    transferReason?: string | null
    enrollmentStatus?: string
    enrollmentDate?: Date | string | null
    nationality?: string | null
    religion?: string | null
    languagesSpoken?: StudentCreatelanguagesSpokenInput | string[]
    specialNeeds?: string | null
    transportRequired?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    parentIds?: StudentCreateparentIdsInput | string[]
    StudentDocument?: StudentDocumentCreateNestedManyWithoutStudentInput
    user?: UserCreateNestedOneWithoutStudentInput
    institution: InstitutionCreateNestedOneWithoutStudentsInput
    class?: ClassCreateNestedOneWithoutStudentsInput
    parents?: ParentCreateNestedManyWithoutStudentInput
    enrollments?: EnrollmentCreateNestedManyWithoutStudentInput
    attendances?: AttendanceCreateNestedManyWithoutStudentInput
    grades?: GradeCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutInvoicesInput = {
    id?: string
    userId?: string | null
    institutionId: string
    firstName: string
    middleName?: string | null
    lastName: string
    admissionNumber?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    bloodGroup?: string | null
    address?: string | null
    gradeApplying?: string | null
    academicYear?: string | null
    classId?: string | null
    phone?: string | null
    email?: string | null
    guardians?: InputJsonValue | null
    fingerprintEnrolled?: boolean
    fingerprintData?: InputJsonValue | null
    faceData?: InputJsonValue | null
    documents?: InputJsonValue | null
    photo?: string | null
    emergencyContacts?: InputJsonValue | null
    medicalConditions?: string | null
    allergies?: string | null
    medications?: string | null
    previousSchool?: string | null
    previousGrade?: string | null
    transferReason?: string | null
    enrollmentStatus?: string
    enrollmentDate?: Date | string | null
    nationality?: string | null
    religion?: string | null
    languagesSpoken?: StudentCreatelanguagesSpokenInput | string[]
    specialNeeds?: string | null
    transportRequired?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    parentIds?: StudentCreateparentIdsInput | string[]
    StudentDocument?: StudentDocumentUncheckedCreateNestedManyWithoutStudentInput
    parents?: ParentUncheckedCreateNestedManyWithoutStudentInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutStudentInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutStudentInput
    grades?: GradeUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutInvoicesInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutInvoicesInput, StudentUncheckedCreateWithoutInvoicesInput>
  }

  export type InstitutionUpsertWithoutInvoicesInput = {
    update: XOR<InstitutionUpdateWithoutInvoicesInput, InstitutionUncheckedUpdateWithoutInvoicesInput>
    create: XOR<InstitutionCreateWithoutInvoicesInput, InstitutionUncheckedCreateWithoutInvoicesInput>
    where?: InstitutionWhereInput
  }

  export type InstitutionUpdateToOneWithWhereWithoutInvoicesInput = {
    where?: InstitutionWhereInput
    data: XOR<InstitutionUpdateWithoutInvoicesInput, InstitutionUncheckedUpdateWithoutInvoicesInput>
  }

  export type InstitutionUpdateWithoutInvoicesInput = {
    name?: StringFieldUpdateOperationsInput | string
    institutionType?: EnumInstitutionTypeFieldUpdateOperationsInput | $Enums.InstitutionType
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: EnumInstitutionPlanFieldUpdateOperationsInput | $Enums.InstitutionPlan
    subscriptionStatus?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UsersOnInstitutionUpdateManyWithoutInstitutionNestedInput
    classes?: ClassUpdateManyWithoutInstitutionNestedInput
    students?: StudentUpdateManyWithoutInstitutionNestedInput
    teachers?: TeacherOnInstitutionUpdateManyWithoutInstitutionNestedInput
    messages?: MessageUpdateManyWithoutInstitutionNestedInput
  }

  export type InstitutionUncheckedUpdateWithoutInvoicesInput = {
    name?: StringFieldUpdateOperationsInput | string
    institutionType?: EnumInstitutionTypeFieldUpdateOperationsInput | $Enums.InstitutionType
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: EnumInstitutionPlanFieldUpdateOperationsInput | $Enums.InstitutionPlan
    subscriptionStatus?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UsersOnInstitutionUncheckedUpdateManyWithoutInstitutionNestedInput
    classes?: ClassUncheckedUpdateManyWithoutInstitutionNestedInput
    students?: StudentUncheckedUpdateManyWithoutInstitutionNestedInput
    teachers?: TeacherOnInstitutionUncheckedUpdateManyWithoutInstitutionNestedInput
    messages?: MessageUncheckedUpdateManyWithoutInstitutionNestedInput
  }

  export type StudentUpsertWithoutInvoicesInput = {
    update: XOR<StudentUpdateWithoutInvoicesInput, StudentUncheckedUpdateWithoutInvoicesInput>
    create: XOR<StudentCreateWithoutInvoicesInput, StudentUncheckedCreateWithoutInvoicesInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutInvoicesInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutInvoicesInput, StudentUncheckedUpdateWithoutInvoicesInput>
  }

  export type StudentUpdateWithoutInvoicesInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    admissionNumber?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gradeApplying?: NullableStringFieldUpdateOperationsInput | string | null
    academicYear?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    guardians?: InputJsonValue | InputJsonValue | null
    fingerprintEnrolled?: BoolFieldUpdateOperationsInput | boolean
    fingerprintData?: InputJsonValue | InputJsonValue | null
    faceData?: InputJsonValue | InputJsonValue | null
    documents?: InputJsonValue | InputJsonValue | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContacts?: InputJsonValue | InputJsonValue | null
    medicalConditions?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    medications?: NullableStringFieldUpdateOperationsInput | string | null
    previousSchool?: NullableStringFieldUpdateOperationsInput | string | null
    previousGrade?: NullableStringFieldUpdateOperationsInput | string | null
    transferReason?: NullableStringFieldUpdateOperationsInput | string | null
    enrollmentStatus?: StringFieldUpdateOperationsInput | string
    enrollmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    languagesSpoken?: StudentUpdatelanguagesSpokenInput | string[]
    specialNeeds?: NullableStringFieldUpdateOperationsInput | string | null
    transportRequired?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentIds?: StudentUpdateparentIdsInput | string[]
    StudentDocument?: StudentDocumentUpdateManyWithoutStudentNestedInput
    user?: UserUpdateOneWithoutStudentNestedInput
    institution?: InstitutionUpdateOneRequiredWithoutStudentsNestedInput
    class?: ClassUpdateOneWithoutStudentsNestedInput
    parents?: ParentUpdateManyWithoutStudentNestedInput
    enrollments?: EnrollmentUpdateManyWithoutStudentNestedInput
    attendances?: AttendanceUpdateManyWithoutStudentNestedInput
    grades?: GradeUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutInvoicesInput = {
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    institutionId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    admissionNumber?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gradeApplying?: NullableStringFieldUpdateOperationsInput | string | null
    academicYear?: NullableStringFieldUpdateOperationsInput | string | null
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    guardians?: InputJsonValue | InputJsonValue | null
    fingerprintEnrolled?: BoolFieldUpdateOperationsInput | boolean
    fingerprintData?: InputJsonValue | InputJsonValue | null
    faceData?: InputJsonValue | InputJsonValue | null
    documents?: InputJsonValue | InputJsonValue | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContacts?: InputJsonValue | InputJsonValue | null
    medicalConditions?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    medications?: NullableStringFieldUpdateOperationsInput | string | null
    previousSchool?: NullableStringFieldUpdateOperationsInput | string | null
    previousGrade?: NullableStringFieldUpdateOperationsInput | string | null
    transferReason?: NullableStringFieldUpdateOperationsInput | string | null
    enrollmentStatus?: StringFieldUpdateOperationsInput | string
    enrollmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    languagesSpoken?: StudentUpdatelanguagesSpokenInput | string[]
    specialNeeds?: NullableStringFieldUpdateOperationsInput | string | null
    transportRequired?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentIds?: StudentUpdateparentIdsInput | string[]
    StudentDocument?: StudentDocumentUncheckedUpdateManyWithoutStudentNestedInput
    parents?: ParentUncheckedUpdateManyWithoutStudentNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutStudentNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutStudentNestedInput
    grades?: GradeUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type UserCreateWithoutSentMessagesInput = {
    id?: string
    firstName: string
    middleName?: string | null
    lastName: string
    dateOfBirth: Date | string
    role: $Enums.Role
    email: string
    password: string
    avatar?: string | null
    phone?: string | null
    isActive?: boolean
    lastlogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    student?: StudentCreateNestedManyWithoutUserInput
    teacher?: TeacherCreateNestedManyWithoutUserInput
    parent?: UserToParentCreateNestedManyWithoutUserInput
    institutions?: UsersOnInstitutionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSentMessagesInput = {
    id?: string
    firstName: string
    middleName?: string | null
    lastName: string
    dateOfBirth: Date | string
    role: $Enums.Role
    email: string
    password: string
    avatar?: string | null
    phone?: string | null
    isActive?: boolean
    lastlogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    student?: StudentUncheckedCreateNestedManyWithoutUserInput
    teacher?: TeacherUncheckedCreateNestedManyWithoutUserInput
    parent?: UserToParentUncheckedCreateNestedManyWithoutUserInput
    institutions?: UsersOnInstitutionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSentMessagesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSentMessagesInput, UserUncheckedCreateWithoutSentMessagesInput>
  }

  export type InstitutionCreateWithoutMessagesInput = {
    id?: string
    name: string
    institutionType?: $Enums.InstitutionType
    address: string
    city: string
    state: string
    country: string
    phone: string
    email: string
    website?: string | null
    plan?: $Enums.InstitutionPlan
    subscriptionStatus?: $Enums.SubscriptionStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UsersOnInstitutionCreateNestedManyWithoutInstitutionInput
    classes?: ClassCreateNestedManyWithoutInstitutionInput
    students?: StudentCreateNestedManyWithoutInstitutionInput
    teachers?: TeacherOnInstitutionCreateNestedManyWithoutInstitutionInput
    invoices?: InvoiceCreateNestedManyWithoutInstitutionInput
  }

  export type InstitutionUncheckedCreateWithoutMessagesInput = {
    id?: string
    name: string
    institutionType?: $Enums.InstitutionType
    address: string
    city: string
    state: string
    country: string
    phone: string
    email: string
    website?: string | null
    plan?: $Enums.InstitutionPlan
    subscriptionStatus?: $Enums.SubscriptionStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UsersOnInstitutionUncheckedCreateNestedManyWithoutInstitutionInput
    classes?: ClassUncheckedCreateNestedManyWithoutInstitutionInput
    students?: StudentUncheckedCreateNestedManyWithoutInstitutionInput
    teachers?: TeacherOnInstitutionUncheckedCreateNestedManyWithoutInstitutionInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutInstitutionInput
  }

  export type InstitutionCreateOrConnectWithoutMessagesInput = {
    where: InstitutionWhereUniqueInput
    create: XOR<InstitutionCreateWithoutMessagesInput, InstitutionUncheckedCreateWithoutMessagesInput>
  }

  export type UserUpsertWithoutSentMessagesInput = {
    update: XOR<UserUpdateWithoutSentMessagesInput, UserUncheckedUpdateWithoutSentMessagesInput>
    create: XOR<UserCreateWithoutSentMessagesInput, UserUncheckedCreateWithoutSentMessagesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSentMessagesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSentMessagesInput, UserUncheckedUpdateWithoutSentMessagesInput>
  }

  export type UserUpdateWithoutSentMessagesInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastlogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateManyWithoutUserNestedInput
    teacher?: TeacherUpdateManyWithoutUserNestedInput
    parent?: UserToParentUpdateManyWithoutUserNestedInput
    institutions?: UsersOnInstitutionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSentMessagesInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastlogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUncheckedUpdateManyWithoutUserNestedInput
    teacher?: TeacherUncheckedUpdateManyWithoutUserNestedInput
    parent?: UserToParentUncheckedUpdateManyWithoutUserNestedInput
    institutions?: UsersOnInstitutionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type InstitutionUpsertWithoutMessagesInput = {
    update: XOR<InstitutionUpdateWithoutMessagesInput, InstitutionUncheckedUpdateWithoutMessagesInput>
    create: XOR<InstitutionCreateWithoutMessagesInput, InstitutionUncheckedCreateWithoutMessagesInput>
    where?: InstitutionWhereInput
  }

  export type InstitutionUpdateToOneWithWhereWithoutMessagesInput = {
    where?: InstitutionWhereInput
    data: XOR<InstitutionUpdateWithoutMessagesInput, InstitutionUncheckedUpdateWithoutMessagesInput>
  }

  export type InstitutionUpdateWithoutMessagesInput = {
    name?: StringFieldUpdateOperationsInput | string
    institutionType?: EnumInstitutionTypeFieldUpdateOperationsInput | $Enums.InstitutionType
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: EnumInstitutionPlanFieldUpdateOperationsInput | $Enums.InstitutionPlan
    subscriptionStatus?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UsersOnInstitutionUpdateManyWithoutInstitutionNestedInput
    classes?: ClassUpdateManyWithoutInstitutionNestedInput
    students?: StudentUpdateManyWithoutInstitutionNestedInput
    teachers?: TeacherOnInstitutionUpdateManyWithoutInstitutionNestedInput
    invoices?: InvoiceUpdateManyWithoutInstitutionNestedInput
  }

  export type InstitutionUncheckedUpdateWithoutMessagesInput = {
    name?: StringFieldUpdateOperationsInput | string
    institutionType?: EnumInstitutionTypeFieldUpdateOperationsInput | $Enums.InstitutionType
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: EnumInstitutionPlanFieldUpdateOperationsInput | $Enums.InstitutionPlan
    subscriptionStatus?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UsersOnInstitutionUncheckedUpdateManyWithoutInstitutionNestedInput
    classes?: ClassUncheckedUpdateManyWithoutInstitutionNestedInput
    students?: StudentUncheckedUpdateManyWithoutInstitutionNestedInput
    teachers?: TeacherOnInstitutionUncheckedUpdateManyWithoutInstitutionNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutInstitutionNestedInput
  }

  export type UsersOnInstitutionCreateManyInstitutionInput = {
    id?: string
    userId: string
  }

  export type ClassCreateManyInstitutionInput = {
    id?: string
    name: string
    section?: string | null
    academicYear?: string | null
    capacity?: number | null
    roomNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    teacherIds?: ClassCreateteacherIdsInput | string[]
  }

  export type StudentCreateManyInstitutionInput = {
    id?: string
    userId?: string | null
    firstName: string
    middleName?: string | null
    lastName: string
    admissionNumber?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    bloodGroup?: string | null
    address?: string | null
    gradeApplying?: string | null
    academicYear?: string | null
    classId?: string | null
    phone?: string | null
    email?: string | null
    guardians?: InputJsonValue | null
    fingerprintEnrolled?: boolean
    fingerprintData?: InputJsonValue | null
    faceData?: InputJsonValue | null
    documents?: InputJsonValue | null
    photo?: string | null
    emergencyContacts?: InputJsonValue | null
    medicalConditions?: string | null
    allergies?: string | null
    medications?: string | null
    previousSchool?: string | null
    previousGrade?: string | null
    transferReason?: string | null
    enrollmentStatus?: string
    enrollmentDate?: Date | string | null
    nationality?: string | null
    religion?: string | null
    languagesSpoken?: StudentCreatelanguagesSpokenInput | string[]
    specialNeeds?: string | null
    transportRequired?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    parentIds?: StudentCreateparentIdsInput | string[]
  }

  export type TeacherOnInstitutionCreateManyInstitutionInput = {
    id?: string
    teacherId: string
  }

  export type InvoiceCreateManyInstitutionInput = {
    id?: string
    studentId?: string | null
    invoiceNumber: string
    description?: string | null
    amount: number
    amountPaid?: number
    status: string
    dueDate?: Date | string | null
    paidDate?: Date | string | null
    paymentMethod?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessageCreateManyInstitutionInput = {
    id?: string
    fromUserId: string
    toUserId: string
    subject?: string | null
    body: string
    isRead?: boolean
    readAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UsersOnInstitutionUpdateWithoutInstitutionInput = {
    user?: UserUpdateOneRequiredWithoutInstitutionsNestedInput
  }

  export type UsersOnInstitutionUncheckedUpdateWithoutInstitutionInput = {
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type UsersOnInstitutionUncheckedUpdateManyWithoutInstitutionInput = {
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type ClassUpdateWithoutInstitutionInput = {
    name?: StringFieldUpdateOperationsInput | string
    section?: NullableStringFieldUpdateOperationsInput | string | null
    academicYear?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    roomNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teacherIds?: ClassUpdateteacherIdsInput | string[]
    students?: StudentUpdateManyWithoutClassNestedInput
    teachers?: TeacherOnClassUpdateManyWithoutClassNestedInput
    enrollments?: EnrollmentUpdateManyWithoutClassNestedInput
    attendances?: AttendanceUpdateManyWithoutClassNestedInput
    timetables?: TimetableUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateWithoutInstitutionInput = {
    name?: StringFieldUpdateOperationsInput | string
    section?: NullableStringFieldUpdateOperationsInput | string | null
    academicYear?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    roomNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teacherIds?: ClassUpdateteacherIdsInput | string[]
    students?: StudentUncheckedUpdateManyWithoutClassNestedInput
    teachers?: TeacherOnClassUncheckedUpdateManyWithoutClassNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutClassNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutClassNestedInput
    timetables?: TimetableUncheckedUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateManyWithoutInstitutionInput = {
    name?: StringFieldUpdateOperationsInput | string
    section?: NullableStringFieldUpdateOperationsInput | string | null
    academicYear?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    roomNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teacherIds?: ClassUpdateteacherIdsInput | string[]
  }

  export type StudentUpdateWithoutInstitutionInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    admissionNumber?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gradeApplying?: NullableStringFieldUpdateOperationsInput | string | null
    academicYear?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    guardians?: InputJsonValue | InputJsonValue | null
    fingerprintEnrolled?: BoolFieldUpdateOperationsInput | boolean
    fingerprintData?: InputJsonValue | InputJsonValue | null
    faceData?: InputJsonValue | InputJsonValue | null
    documents?: InputJsonValue | InputJsonValue | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContacts?: InputJsonValue | InputJsonValue | null
    medicalConditions?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    medications?: NullableStringFieldUpdateOperationsInput | string | null
    previousSchool?: NullableStringFieldUpdateOperationsInput | string | null
    previousGrade?: NullableStringFieldUpdateOperationsInput | string | null
    transferReason?: NullableStringFieldUpdateOperationsInput | string | null
    enrollmentStatus?: StringFieldUpdateOperationsInput | string
    enrollmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    languagesSpoken?: StudentUpdatelanguagesSpokenInput | string[]
    specialNeeds?: NullableStringFieldUpdateOperationsInput | string | null
    transportRequired?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentIds?: StudentUpdateparentIdsInput | string[]
    StudentDocument?: StudentDocumentUpdateManyWithoutStudentNestedInput
    user?: UserUpdateOneWithoutStudentNestedInput
    class?: ClassUpdateOneWithoutStudentsNestedInput
    parents?: ParentUpdateManyWithoutStudentNestedInput
    enrollments?: EnrollmentUpdateManyWithoutStudentNestedInput
    attendances?: AttendanceUpdateManyWithoutStudentNestedInput
    grades?: GradeUpdateManyWithoutStudentNestedInput
    invoices?: InvoiceUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutInstitutionInput = {
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    admissionNumber?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gradeApplying?: NullableStringFieldUpdateOperationsInput | string | null
    academicYear?: NullableStringFieldUpdateOperationsInput | string | null
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    guardians?: InputJsonValue | InputJsonValue | null
    fingerprintEnrolled?: BoolFieldUpdateOperationsInput | boolean
    fingerprintData?: InputJsonValue | InputJsonValue | null
    faceData?: InputJsonValue | InputJsonValue | null
    documents?: InputJsonValue | InputJsonValue | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContacts?: InputJsonValue | InputJsonValue | null
    medicalConditions?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    medications?: NullableStringFieldUpdateOperationsInput | string | null
    previousSchool?: NullableStringFieldUpdateOperationsInput | string | null
    previousGrade?: NullableStringFieldUpdateOperationsInput | string | null
    transferReason?: NullableStringFieldUpdateOperationsInput | string | null
    enrollmentStatus?: StringFieldUpdateOperationsInput | string
    enrollmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    languagesSpoken?: StudentUpdatelanguagesSpokenInput | string[]
    specialNeeds?: NullableStringFieldUpdateOperationsInput | string | null
    transportRequired?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentIds?: StudentUpdateparentIdsInput | string[]
    StudentDocument?: StudentDocumentUncheckedUpdateManyWithoutStudentNestedInput
    parents?: ParentUncheckedUpdateManyWithoutStudentNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutStudentNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutStudentNestedInput
    grades?: GradeUncheckedUpdateManyWithoutStudentNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateManyWithoutInstitutionInput = {
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    admissionNumber?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gradeApplying?: NullableStringFieldUpdateOperationsInput | string | null
    academicYear?: NullableStringFieldUpdateOperationsInput | string | null
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    guardians?: InputJsonValue | InputJsonValue | null
    fingerprintEnrolled?: BoolFieldUpdateOperationsInput | boolean
    fingerprintData?: InputJsonValue | InputJsonValue | null
    faceData?: InputJsonValue | InputJsonValue | null
    documents?: InputJsonValue | InputJsonValue | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContacts?: InputJsonValue | InputJsonValue | null
    medicalConditions?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    medications?: NullableStringFieldUpdateOperationsInput | string | null
    previousSchool?: NullableStringFieldUpdateOperationsInput | string | null
    previousGrade?: NullableStringFieldUpdateOperationsInput | string | null
    transferReason?: NullableStringFieldUpdateOperationsInput | string | null
    enrollmentStatus?: StringFieldUpdateOperationsInput | string
    enrollmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    languagesSpoken?: StudentUpdatelanguagesSpokenInput | string[]
    specialNeeds?: NullableStringFieldUpdateOperationsInput | string | null
    transportRequired?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentIds?: StudentUpdateparentIdsInput | string[]
  }

  export type TeacherOnInstitutionUpdateWithoutInstitutionInput = {
    teacher?: TeacherUpdateOneRequiredWithoutInstitutionNestedInput
  }

  export type TeacherOnInstitutionUncheckedUpdateWithoutInstitutionInput = {
    teacherId?: StringFieldUpdateOperationsInput | string
  }

  export type TeacherOnInstitutionUncheckedUpdateManyWithoutInstitutionInput = {
    teacherId?: StringFieldUpdateOperationsInput | string
  }

  export type InvoiceUpdateWithoutInstitutionInput = {
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    amountPaid?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneWithoutInvoicesNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutInstitutionInput = {
    studentId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    amountPaid?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUncheckedUpdateManyWithoutInstitutionInput = {
    studentId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    amountPaid?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUpdateWithoutInstitutionInput = {
    toUserId?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    body?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fromUser?: UserUpdateOneRequiredWithoutSentMessagesNestedInput
  }

  export type MessageUncheckedUpdateWithoutInstitutionInput = {
    fromUserId?: StringFieldUpdateOperationsInput | string
    toUserId?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    body?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateManyWithoutInstitutionInput = {
    fromUserId?: StringFieldUpdateOperationsInput | string
    toUserId?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    body?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentCreateManyUserInput = {
    id?: string
    institutionId: string
    firstName: string
    middleName?: string | null
    lastName: string
    admissionNumber?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    bloodGroup?: string | null
    address?: string | null
    gradeApplying?: string | null
    academicYear?: string | null
    classId?: string | null
    phone?: string | null
    email?: string | null
    guardians?: InputJsonValue | null
    fingerprintEnrolled?: boolean
    fingerprintData?: InputJsonValue | null
    faceData?: InputJsonValue | null
    documents?: InputJsonValue | null
    photo?: string | null
    emergencyContacts?: InputJsonValue | null
    medicalConditions?: string | null
    allergies?: string | null
    medications?: string | null
    previousSchool?: string | null
    previousGrade?: string | null
    transferReason?: string | null
    enrollmentStatus?: string
    enrollmentDate?: Date | string | null
    nationality?: string | null
    religion?: string | null
    languagesSpoken?: StudentCreatelanguagesSpokenInput | string[]
    specialNeeds?: string | null
    transportRequired?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    parentIds?: StudentCreateparentIdsInput | string[]
  }

  export type TeacherCreateManyUserInput = {
    id?: string
    firstName: string
    middleName?: string | null
    lastName: string
    email?: string | null
    phone: string
    avatar?: string | null
    employeeNumber?: string | null
    subjects?: TeacherCreatesubjectsInput | string[]
    qualification?: string | null
    experience?: number | null
    salary?: number | null
    joinDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserToParentCreateManyUserInput = {
    id?: string
    parentId: string
  }

  export type UsersOnInstitutionCreateManyUserInput = {
    id?: string
    institutionId: string
  }

  export type MessageCreateManyFromUserInput = {
    id?: string
    toUserId: string
    institutionId: string
    subject?: string | null
    body: string
    isRead?: boolean
    readAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentUpdateWithoutUserInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    admissionNumber?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gradeApplying?: NullableStringFieldUpdateOperationsInput | string | null
    academicYear?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    guardians?: InputJsonValue | InputJsonValue | null
    fingerprintEnrolled?: BoolFieldUpdateOperationsInput | boolean
    fingerprintData?: InputJsonValue | InputJsonValue | null
    faceData?: InputJsonValue | InputJsonValue | null
    documents?: InputJsonValue | InputJsonValue | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContacts?: InputJsonValue | InputJsonValue | null
    medicalConditions?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    medications?: NullableStringFieldUpdateOperationsInput | string | null
    previousSchool?: NullableStringFieldUpdateOperationsInput | string | null
    previousGrade?: NullableStringFieldUpdateOperationsInput | string | null
    transferReason?: NullableStringFieldUpdateOperationsInput | string | null
    enrollmentStatus?: StringFieldUpdateOperationsInput | string
    enrollmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    languagesSpoken?: StudentUpdatelanguagesSpokenInput | string[]
    specialNeeds?: NullableStringFieldUpdateOperationsInput | string | null
    transportRequired?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentIds?: StudentUpdateparentIdsInput | string[]
    StudentDocument?: StudentDocumentUpdateManyWithoutStudentNestedInput
    institution?: InstitutionUpdateOneRequiredWithoutStudentsNestedInput
    class?: ClassUpdateOneWithoutStudentsNestedInput
    parents?: ParentUpdateManyWithoutStudentNestedInput
    enrollments?: EnrollmentUpdateManyWithoutStudentNestedInput
    attendances?: AttendanceUpdateManyWithoutStudentNestedInput
    grades?: GradeUpdateManyWithoutStudentNestedInput
    invoices?: InvoiceUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutUserInput = {
    institutionId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    admissionNumber?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gradeApplying?: NullableStringFieldUpdateOperationsInput | string | null
    academicYear?: NullableStringFieldUpdateOperationsInput | string | null
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    guardians?: InputJsonValue | InputJsonValue | null
    fingerprintEnrolled?: BoolFieldUpdateOperationsInput | boolean
    fingerprintData?: InputJsonValue | InputJsonValue | null
    faceData?: InputJsonValue | InputJsonValue | null
    documents?: InputJsonValue | InputJsonValue | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContacts?: InputJsonValue | InputJsonValue | null
    medicalConditions?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    medications?: NullableStringFieldUpdateOperationsInput | string | null
    previousSchool?: NullableStringFieldUpdateOperationsInput | string | null
    previousGrade?: NullableStringFieldUpdateOperationsInput | string | null
    transferReason?: NullableStringFieldUpdateOperationsInput | string | null
    enrollmentStatus?: StringFieldUpdateOperationsInput | string
    enrollmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    languagesSpoken?: StudentUpdatelanguagesSpokenInput | string[]
    specialNeeds?: NullableStringFieldUpdateOperationsInput | string | null
    transportRequired?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentIds?: StudentUpdateparentIdsInput | string[]
    StudentDocument?: StudentDocumentUncheckedUpdateManyWithoutStudentNestedInput
    parents?: ParentUncheckedUpdateManyWithoutStudentNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutStudentNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutStudentNestedInput
    grades?: GradeUncheckedUpdateManyWithoutStudentNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateManyWithoutUserInput = {
    institutionId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    admissionNumber?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gradeApplying?: NullableStringFieldUpdateOperationsInput | string | null
    academicYear?: NullableStringFieldUpdateOperationsInput | string | null
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    guardians?: InputJsonValue | InputJsonValue | null
    fingerprintEnrolled?: BoolFieldUpdateOperationsInput | boolean
    fingerprintData?: InputJsonValue | InputJsonValue | null
    faceData?: InputJsonValue | InputJsonValue | null
    documents?: InputJsonValue | InputJsonValue | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContacts?: InputJsonValue | InputJsonValue | null
    medicalConditions?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    medications?: NullableStringFieldUpdateOperationsInput | string | null
    previousSchool?: NullableStringFieldUpdateOperationsInput | string | null
    previousGrade?: NullableStringFieldUpdateOperationsInput | string | null
    transferReason?: NullableStringFieldUpdateOperationsInput | string | null
    enrollmentStatus?: StringFieldUpdateOperationsInput | string
    enrollmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    languagesSpoken?: StudentUpdatelanguagesSpokenInput | string[]
    specialNeeds?: NullableStringFieldUpdateOperationsInput | string | null
    transportRequired?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentIds?: StudentUpdateparentIdsInput | string[]
  }

  export type TeacherUpdateWithoutUserInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    employeeNumber?: NullableStringFieldUpdateOperationsInput | string | null
    subjects?: TeacherUpdatesubjectsInput | string[]
    qualification?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    joinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    institution?: TeacherOnInstitutionUpdateManyWithoutTeacherNestedInput
    classes?: TeacherOnClassUpdateManyWithoutTeacherNestedInput
  }

  export type TeacherUncheckedUpdateWithoutUserInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    employeeNumber?: NullableStringFieldUpdateOperationsInput | string | null
    subjects?: TeacherUpdatesubjectsInput | string[]
    qualification?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    joinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    institution?: TeacherOnInstitutionUncheckedUpdateManyWithoutTeacherNestedInput
    classes?: TeacherOnClassUncheckedUpdateManyWithoutTeacherNestedInput
  }

  export type TeacherUncheckedUpdateManyWithoutUserInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    employeeNumber?: NullableStringFieldUpdateOperationsInput | string | null
    subjects?: TeacherUpdatesubjectsInput | string[]
    qualification?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    joinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserToParentUpdateWithoutUserInput = {
    parent?: ParentUpdateOneRequiredWithoutUserNestedInput
  }

  export type UserToParentUncheckedUpdateWithoutUserInput = {
    parentId?: StringFieldUpdateOperationsInput | string
  }

  export type UserToParentUncheckedUpdateManyWithoutUserInput = {
    parentId?: StringFieldUpdateOperationsInput | string
  }

  export type UsersOnInstitutionUpdateWithoutUserInput = {
    institution?: InstitutionUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UsersOnInstitutionUncheckedUpdateWithoutUserInput = {
    institutionId?: StringFieldUpdateOperationsInput | string
  }

  export type UsersOnInstitutionUncheckedUpdateManyWithoutUserInput = {
    institutionId?: StringFieldUpdateOperationsInput | string
  }

  export type MessageUpdateWithoutFromUserInput = {
    toUserId?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    body?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    institution?: InstitutionUpdateOneRequiredWithoutMessagesNestedInput
  }

  export type MessageUncheckedUpdateWithoutFromUserInput = {
    toUserId?: StringFieldUpdateOperationsInput | string
    institutionId?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    body?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateManyWithoutFromUserInput = {
    toUserId?: StringFieldUpdateOperationsInput | string
    institutionId?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    body?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentDocumentCreateManyStudentInput = {
    id?: string
    documentType: string
    documentName: string
    documentUrl: string
    fileSize?: number | null
    mimeType?: string | null
    uploadedAt?: Date | string
    uploadedBy?: string | null
    verified?: boolean
    verifiedBy?: string | null
    verifiedAt?: Date | string | null
  }

  export type ParentCreateManyStudentInput = {
    id?: string
    institutionId: string
    firstName: string
    middleName?: string | null
    lastName: string
    email: string
    phone: string
    occupation?: string | null
    relationship?: string | null
    address?: string | null
    isPrimaryContact?: boolean
    isEmergencyContact?: boolean
    preferredContactTime?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EnrollmentCreateManyStudentInput = {
    id?: string
    classId: string
    academicYear: string
    enrollDate?: Date | string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttendanceCreateManyStudentInput = {
    id?: string
    classId: string
    date: Date | string
    status: string
    remarks?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GradeCreateManyStudentInput = {
    id?: string
    subject: string
    examType?: string | null
    score: number
    maxScore?: number
    grade?: string | null
    term: string
    academicYear: string
    remarks?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceCreateManyStudentInput = {
    id?: string
    institutionId: string
    invoiceNumber: string
    description?: string | null
    amount: number
    amountPaid?: number
    status: string
    dueDate?: Date | string | null
    paidDate?: Date | string | null
    paymentMethod?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentDocumentUpdateWithoutStudentInput = {
    documentType?: StringFieldUpdateOperationsInput | string
    documentName?: StringFieldUpdateOperationsInput | string
    documentUrl?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type StudentDocumentUncheckedUpdateWithoutStudentInput = {
    documentType?: StringFieldUpdateOperationsInput | string
    documentName?: StringFieldUpdateOperationsInput | string
    documentUrl?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type StudentDocumentUncheckedUpdateManyWithoutStudentInput = {
    documentType?: StringFieldUpdateOperationsInput | string
    documentName?: StringFieldUpdateOperationsInput | string
    documentUrl?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ParentUpdateWithoutStudentInput = {
    institutionId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    relationship?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isPrimaryContact?: BoolFieldUpdateOperationsInput | boolean
    isEmergencyContact?: BoolFieldUpdateOperationsInput | boolean
    preferredContactTime?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserToParentUpdateManyWithoutParentNestedInput
  }

  export type ParentUncheckedUpdateWithoutStudentInput = {
    institutionId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    relationship?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isPrimaryContact?: BoolFieldUpdateOperationsInput | boolean
    isEmergencyContact?: BoolFieldUpdateOperationsInput | boolean
    preferredContactTime?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserToParentUncheckedUpdateManyWithoutParentNestedInput
  }

  export type ParentUncheckedUpdateManyWithoutStudentInput = {
    institutionId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    relationship?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isPrimaryContact?: BoolFieldUpdateOperationsInput | boolean
    isEmergencyContact?: BoolFieldUpdateOperationsInput | boolean
    preferredContactTime?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EnrollmentUpdateWithoutStudentInput = {
    academicYear?: StringFieldUpdateOperationsInput | string
    enrollDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    class?: ClassUpdateOneRequiredWithoutEnrollmentsNestedInput
  }

  export type EnrollmentUncheckedUpdateWithoutStudentInput = {
    classId?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    enrollDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EnrollmentUncheckedUpdateManyWithoutStudentInput = {
    classId?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    enrollDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceUpdateWithoutStudentInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    class?: ClassUpdateOneRequiredWithoutAttendancesNestedInput
  }

  export type AttendanceUncheckedUpdateWithoutStudentInput = {
    classId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceUncheckedUpdateManyWithoutStudentInput = {
    classId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GradeUpdateWithoutStudentInput = {
    subject?: StringFieldUpdateOperationsInput | string
    examType?: NullableStringFieldUpdateOperationsInput | string | null
    score?: FloatFieldUpdateOperationsInput | number
    maxScore?: FloatFieldUpdateOperationsInput | number
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    term?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GradeUncheckedUpdateWithoutStudentInput = {
    subject?: StringFieldUpdateOperationsInput | string
    examType?: NullableStringFieldUpdateOperationsInput | string | null
    score?: FloatFieldUpdateOperationsInput | number
    maxScore?: FloatFieldUpdateOperationsInput | number
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    term?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GradeUncheckedUpdateManyWithoutStudentInput = {
    subject?: StringFieldUpdateOperationsInput | string
    examType?: NullableStringFieldUpdateOperationsInput | string | null
    score?: FloatFieldUpdateOperationsInput | number
    maxScore?: FloatFieldUpdateOperationsInput | number
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    term?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUpdateWithoutStudentInput = {
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    amountPaid?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    institution?: InstitutionUpdateOneWithoutInvoicesNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutStudentInput = {
    institutionId?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    amountPaid?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUncheckedUpdateManyWithoutStudentInput = {
    institutionId?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    amountPaid?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserToParentCreateManyParentInput = {
    id?: string
    userId: string
  }

  export type UserToParentUpdateWithoutParentInput = {
    user?: UserUpdateOneRequiredWithoutParentNestedInput
  }

  export type UserToParentUncheckedUpdateWithoutParentInput = {
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type UserToParentUncheckedUpdateManyWithoutParentInput = {
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type TeacherOnInstitutionCreateManyTeacherInput = {
    id?: string
    institutionId: string
  }

  export type TeacherOnClassCreateManyTeacherInput = {
    id?: string
    classId: string
  }

  export type TeacherOnInstitutionUpdateWithoutTeacherInput = {
    institution?: InstitutionUpdateOneRequiredWithoutTeachersNestedInput
  }

  export type TeacherOnInstitutionUncheckedUpdateWithoutTeacherInput = {
    institutionId?: StringFieldUpdateOperationsInput | string
  }

  export type TeacherOnInstitutionUncheckedUpdateManyWithoutTeacherInput = {
    institutionId?: StringFieldUpdateOperationsInput | string
  }

  export type TeacherOnClassUpdateWithoutTeacherInput = {
    class?: ClassUpdateOneRequiredWithoutTeachersNestedInput
  }

  export type TeacherOnClassUncheckedUpdateWithoutTeacherInput = {
    classId?: StringFieldUpdateOperationsInput | string
  }

  export type TeacherOnClassUncheckedUpdateManyWithoutTeacherInput = {
    classId?: StringFieldUpdateOperationsInput | string
  }

  export type StudentCreateManyClassInput = {
    id?: string
    userId?: string | null
    institutionId: string
    firstName: string
    middleName?: string | null
    lastName: string
    admissionNumber?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    bloodGroup?: string | null
    address?: string | null
    gradeApplying?: string | null
    academicYear?: string | null
    phone?: string | null
    email?: string | null
    guardians?: InputJsonValue | null
    fingerprintEnrolled?: boolean
    fingerprintData?: InputJsonValue | null
    faceData?: InputJsonValue | null
    documents?: InputJsonValue | null
    photo?: string | null
    emergencyContacts?: InputJsonValue | null
    medicalConditions?: string | null
    allergies?: string | null
    medications?: string | null
    previousSchool?: string | null
    previousGrade?: string | null
    transferReason?: string | null
    enrollmentStatus?: string
    enrollmentDate?: Date | string | null
    nationality?: string | null
    religion?: string | null
    languagesSpoken?: StudentCreatelanguagesSpokenInput | string[]
    specialNeeds?: string | null
    transportRequired?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    parentIds?: StudentCreateparentIdsInput | string[]
  }

  export type TeacherOnClassCreateManyClassInput = {
    id?: string
    teacherId: string
  }

  export type EnrollmentCreateManyClassInput = {
    id?: string
    studentId: string
    academicYear: string
    enrollDate?: Date | string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttendanceCreateManyClassInput = {
    id?: string
    studentId: string
    date: Date | string
    status: string
    remarks?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TimetableCreateManyClassInput = {
    id?: string
    dayOfWeek: number
    startTime: string
    endTime: string
    subject: string
    teacherId?: string | null
    room?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentUpdateWithoutClassInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    admissionNumber?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gradeApplying?: NullableStringFieldUpdateOperationsInput | string | null
    academicYear?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    guardians?: InputJsonValue | InputJsonValue | null
    fingerprintEnrolled?: BoolFieldUpdateOperationsInput | boolean
    fingerprintData?: InputJsonValue | InputJsonValue | null
    faceData?: InputJsonValue | InputJsonValue | null
    documents?: InputJsonValue | InputJsonValue | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContacts?: InputJsonValue | InputJsonValue | null
    medicalConditions?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    medications?: NullableStringFieldUpdateOperationsInput | string | null
    previousSchool?: NullableStringFieldUpdateOperationsInput | string | null
    previousGrade?: NullableStringFieldUpdateOperationsInput | string | null
    transferReason?: NullableStringFieldUpdateOperationsInput | string | null
    enrollmentStatus?: StringFieldUpdateOperationsInput | string
    enrollmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    languagesSpoken?: StudentUpdatelanguagesSpokenInput | string[]
    specialNeeds?: NullableStringFieldUpdateOperationsInput | string | null
    transportRequired?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentIds?: StudentUpdateparentIdsInput | string[]
    StudentDocument?: StudentDocumentUpdateManyWithoutStudentNestedInput
    user?: UserUpdateOneWithoutStudentNestedInput
    institution?: InstitutionUpdateOneRequiredWithoutStudentsNestedInput
    parents?: ParentUpdateManyWithoutStudentNestedInput
    enrollments?: EnrollmentUpdateManyWithoutStudentNestedInput
    attendances?: AttendanceUpdateManyWithoutStudentNestedInput
    grades?: GradeUpdateManyWithoutStudentNestedInput
    invoices?: InvoiceUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutClassInput = {
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    institutionId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    admissionNumber?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gradeApplying?: NullableStringFieldUpdateOperationsInput | string | null
    academicYear?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    guardians?: InputJsonValue | InputJsonValue | null
    fingerprintEnrolled?: BoolFieldUpdateOperationsInput | boolean
    fingerprintData?: InputJsonValue | InputJsonValue | null
    faceData?: InputJsonValue | InputJsonValue | null
    documents?: InputJsonValue | InputJsonValue | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContacts?: InputJsonValue | InputJsonValue | null
    medicalConditions?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    medications?: NullableStringFieldUpdateOperationsInput | string | null
    previousSchool?: NullableStringFieldUpdateOperationsInput | string | null
    previousGrade?: NullableStringFieldUpdateOperationsInput | string | null
    transferReason?: NullableStringFieldUpdateOperationsInput | string | null
    enrollmentStatus?: StringFieldUpdateOperationsInput | string
    enrollmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    languagesSpoken?: StudentUpdatelanguagesSpokenInput | string[]
    specialNeeds?: NullableStringFieldUpdateOperationsInput | string | null
    transportRequired?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentIds?: StudentUpdateparentIdsInput | string[]
    StudentDocument?: StudentDocumentUncheckedUpdateManyWithoutStudentNestedInput
    parents?: ParentUncheckedUpdateManyWithoutStudentNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutStudentNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutStudentNestedInput
    grades?: GradeUncheckedUpdateManyWithoutStudentNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateManyWithoutClassInput = {
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    institutionId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    admissionNumber?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    gradeApplying?: NullableStringFieldUpdateOperationsInput | string | null
    academicYear?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    guardians?: InputJsonValue | InputJsonValue | null
    fingerprintEnrolled?: BoolFieldUpdateOperationsInput | boolean
    fingerprintData?: InputJsonValue | InputJsonValue | null
    faceData?: InputJsonValue | InputJsonValue | null
    documents?: InputJsonValue | InputJsonValue | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContacts?: InputJsonValue | InputJsonValue | null
    medicalConditions?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    medications?: NullableStringFieldUpdateOperationsInput | string | null
    previousSchool?: NullableStringFieldUpdateOperationsInput | string | null
    previousGrade?: NullableStringFieldUpdateOperationsInput | string | null
    transferReason?: NullableStringFieldUpdateOperationsInput | string | null
    enrollmentStatus?: StringFieldUpdateOperationsInput | string
    enrollmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    languagesSpoken?: StudentUpdatelanguagesSpokenInput | string[]
    specialNeeds?: NullableStringFieldUpdateOperationsInput | string | null
    transportRequired?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentIds?: StudentUpdateparentIdsInput | string[]
  }

  export type TeacherOnClassUpdateWithoutClassInput = {
    teacher?: TeacherUpdateOneRequiredWithoutClassesNestedInput
  }

  export type TeacherOnClassUncheckedUpdateWithoutClassInput = {
    teacherId?: StringFieldUpdateOperationsInput | string
  }

  export type TeacherOnClassUncheckedUpdateManyWithoutClassInput = {
    teacherId?: StringFieldUpdateOperationsInput | string
  }

  export type EnrollmentUpdateWithoutClassInput = {
    academicYear?: StringFieldUpdateOperationsInput | string
    enrollDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutEnrollmentsNestedInput
  }

  export type EnrollmentUncheckedUpdateWithoutClassInput = {
    studentId?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    enrollDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EnrollmentUncheckedUpdateManyWithoutClassInput = {
    studentId?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    enrollDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceUpdateWithoutClassInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutAttendancesNestedInput
  }

  export type AttendanceUncheckedUpdateWithoutClassInput = {
    studentId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceUncheckedUpdateManyWithoutClassInput = {
    studentId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TimetableUpdateWithoutClassInput = {
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TimetableUncheckedUpdateWithoutClassInput = {
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TimetableUncheckedUpdateManyWithoutClassInput = {
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}